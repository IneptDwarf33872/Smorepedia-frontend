{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst propertyByString = require('./utils').propertyByString;\nconst isPosInt32 = require('./utils').isPosInt32;\nconst requireNoWP = require('./utils').requireNoWP;\nconst RoundingModes = {\n  UP: 0,\n  DOWN: 1,\n  CEILING: 2,\n  FLOOR: 3,\n  HALF_UP: 4,\n  HALF_DOWN: 5,\n  HALF_EVEN: 6,\n  UNNECESSARY: 7\n};\nconst DEFAULT_PRECISION = 20;\nclass NumberTypeHandler {\n  constructor(cfg) {\n    assert(cfg.dbNumber != null);\n    try {\n      this._initCons(cfg);\n\n      //These can be customized in future to allow creation of number\n      //instances by callable functions (instead of constructor). \n      this.isInstance = val => val instanceof this._cons;\n      this.create = val => new this._cons(val);\n      this._initMethod(cfg, 'stringValue', 1, ['toString'], []);\n      this._initMethod(cfg, 'compare', 2, ['comparedTo', 'compareTo', 'cmp', 'compare']);\n      this._initMethod(cfg, 'valuesEqual', 2, ['equals', 'isEqualTo', 'eq'], [], true);\n      if (this.valuesEqual == null) {\n        this.valuesEqual = (v1, v2) => this.compare(v1, v2) === 0;\n      }\n      this._initMethod(cfg, 'numberValue', 1, ['toNumber'], [], true);\n      if (this.numberValue == null) {\n        this.numberValue = v => Number(this.stringValue(v));\n      }\n      this._initMethod(cfg, 'add', 2, ['plus', 'add']);\n      this._initMethod(cfg, 'subtract', 2, ['minus', 'sub', 'subtract']);\n      this._initMethod(cfg, 'multiply', 2, ['times', 'multipliedBy', 'multiply', 'mul']);\n      this._initMethod(cfg, 'divide', 2, ['dividedBy', 'divide', 'div']);\n      this._initRoundingModesMap(cfg);\n      this._initGetRoundingMode(cfg);\n      this._initGetPrecision(cfg);\n      this._initRoundingMode(cfg);\n      this._initPrecision(cfg);\n    } catch (err) {\n      throw new NoSQLArgumentError('Failed to initialize dbNumber \\\nconfiguration', cfg, err);\n    }\n  }\n  get precision() {\n    return this._precision;\n  }\n  get roundingMode() {\n    return this._roundingMode;\n  }\n  _initCons(cfg) {\n    switch (typeof cfg.dbNumber) {\n      case 'function':\n        this._cons = cfg.dbNumber;\n        return;\n      case 'string':\n        this._cons = requireNoWP(cfg.dbNumber);\n        break;\n      case 'object':\n        if (cfg.dbNumber.module != null) {\n          if (typeof cfg.dbNumber.module !== 'string') {\n            throw new NoSQLArgumentError('Invalid dbNumber.module \\\nproperty, must be string', cfg);\n          }\n          this._mod = requireNoWP(cfg.dbNumber.module);\n          if (cfg.dbNumber.Constructor == null) {\n            this._cons = this._mod;\n            break;\n          } else if (typeof cfg.dbNumber.Constructor === 'string') {\n            this._cons = this._mod[cfg.dbNumber.Constructor];\n            break;\n          }\n        }\n        this._cons = typeof cfg.dbNumber.Constructor === 'string' ? requireNoWP(cfg.dbNumber.Constructor) : cfg.dbNumber.Constructor;\n        break;\n      default:\n        throw new NoSQLArgumentError('Invalid dbNumber property', cfg);\n    }\n    if (this._cons == null) {\n      throw new NoSQLArgumentError('Missing dbNumber constructor', cfg);\n    }\n    if (typeof this._cons !== 'function') {\n      throw new NoSQLArgumentError('Invalid dbNumber constructor', cfg);\n    }\n  }\n  _findFuncByProp(cfg, name, isStatic) {\n    if (typeof cfg.dbNumber !== 'object') {\n      return null;\n    }\n    const subName = isStatic ? 'static' : 'instance';\n    const sub = cfg.dbNumber[subName];\n    if (sub == null) {\n      return null;\n    }\n    if (typeof sub !== 'object') {\n      throw new NoSQLArgumentError(`Invalid dbNumber.${subName} property`, cfg);\n    }\n    const obj = isStatic ? this._cons : this._cons.prototype;\n    let func = sub[name];\n    if (func == null) {\n      return null;\n    }\n    if (typeof func === 'string') {\n      func = obj[func];\n    }\n    if (typeof func !== 'function') {\n      throw new NoSQLArgumentError(`Property \\\ndbNumber.${subName}.${name} points to missing or invalid method of \\\n${this._cons.name}`, cfg);\n    }\n    return func;\n  }\n  _findFunc(cfg, name, cands, staticCands, retNull) {\n    let func = this._findFuncByProp(cfg, name, false);\n    if (func != null) {\n      return {\n        isStatic: false,\n        func\n      };\n    }\n    func = this._findFuncByProp(cfg, name, true);\n    if (func != null) {\n      return {\n        isStatic: true,\n        func\n      };\n    }\n    if (cands != null) {\n      for (let cand of cands) {\n        func = this._cons.prototype[cand];\n        if (typeof func === 'function') {\n          return {\n            isStatic: false,\n            func\n          };\n        }\n      }\n    }\n    if (staticCands == null) {\n      staticCands = cands;\n    }\n    if (staticCands != null) {\n      for (let cand of staticCands) {\n        func = this._cons[cand];\n        if (typeof func === 'function') {\n          return {\n            isStatic: true,\n            func\n          };\n        }\n      }\n    }\n    if (retNull) {\n      return null;\n    }\n    throw new NoSQLArgumentError(`Could not find dbNumber method for \\\n${name}`, cfg);\n  }\n  _initMethod(cfg, name, numArgs, cands, staticCands, isSoft) {\n    const meth = this._findFunc(cfg, name, cands, staticCands, isSoft);\n    if (meth == null) {\n      return;\n    }\n    if (meth.isStatic) {\n      this[name] = meth.func.bind(this._cons);\n    } else {\n      //not certain if this optimization is needed or the default case\n      //is sufficient\n      switch (numArgs) {\n        case 1:\n          this[name] = v => meth.func.call(v);\n          break;\n        case 2:\n          this[name] = (v1, v2) => meth.func.call(v1, v2);\n          break;\n        default:\n          this[name] = (inst, ...args) => meth.func.call(inst, ...args);\n          break;\n      }\n    }\n  }\n  _findRoundingModes(cfg) {\n    const candObjs = [this._cons];\n    if (this._mod != null) {\n      candObjs.push(this._mod);\n    }\n    //First look at dbNumber.RoundingModes which should be either a\n    //property name of rounding modes object or that object itself\n    if (cfg.dbNumber.RoundingModes != null) {\n      if (typeof cfg.dbNumber.RoundingModes === 'string') {\n        for (let candObj of candObjs) {\n          const roundingModes = propertyByString(candObj, cfg.dbNumber.RoundingModes);\n          if (roundingModes !== null && typeof roundingModes === 'object' || typeof roundingModes === 'function') {\n            return roundingModes;\n          }\n        }\n        throw new NoSQLArgumentError(`Missing or invalid value for \\\ndbNumber.RoundingModes property ${cfg.dbNumber.RoundingModes}`);\n      }\n      if (typeof cfg.dbNumber.RoundingModes !== 'object' && typeof cfg.dbNumber.RoundingModes !== 'function') {\n        throw new NoSQLArgumentError(`Invalid \\\ndbNumber.RoundingModes: ${util.inspect(cfg.dbNumber.RoundingModes)}`, cfg);\n      }\n      return cfg.dbNumber.RoundingModes;\n    }\n    //Otherwise check candidate property names on module or\n    //constructor\n    const candProps = ['RoundingModes', 'RoundingMode'];\n    for (let candObj of candObjs) {\n      for (let candProp of candProps) {\n        const roundingModes = candObj[candProp];\n        if (roundingModes !== null && typeof roundingModes === 'object' || typeof roundingModes === 'function') {\n          return roundingModes;\n        }\n      }\n    }\n    //If still not found, assume that constructor itself contains rounding\n    //mode constants\n    return this._cons;\n  }\n\n  //create a Map mapping 3rd party rounding mode constants to Java's\n  _initRoundingModesMap(cfg) {\n    this._roundingModes = this._findRoundingModes(cfg);\n    //Create a mapping from 3rd party rounding mode values to Java's\n    this._roundingModesMap = new Map();\n    for (let ent of Object.entries(RoundingModes)) {\n      //Look for properties with and without ROUND_ prefix\n      let val = this._roundingModes['ROUND_' + ent[0]];\n      if (val == null) {\n        val = this._roundingModes[ent[0]];\n      }\n      if (val != null) {\n        this._roundingModesMap.set(val, ent[1]);\n      }\n    }\n  }\n  _initGetRoundingMode(cfg) {\n    let rm;\n    let rmFunc;\n    if (cfg.dbNumber.getRoundingMode != null) {\n      switch (typeof cfg.dbNumber.getRoundingMode) {\n        case 'function':\n          rmFunc = cfg.dbNumber.getRoundingMode;\n          break;\n        case 'string':\n          rm = propertyByString(this._cons, cfg.dbNumber.getRoundingMode);\n          if (rm == null) {\n            throw new NoSQLArgumentError(`Missing value for \\\n    dbNumber.getRoundingMode property ${cfg.dbNumber.getRoundingMode}`, cfg);\n          }\n          rmFunc = cons => propertyByString(cons, cfg.dbNumber.getRoundingMode);\n          break;\n        default:\n          throw new NoSQLArgumentError(`Invalid \\\ndbNumber.getRoundingMode: ${util.inspect(cfg.dbNumber.getRoundingMode)}`);\n      }\n    } else {\n      //If dbNumber.getRoundingMode is not set and rounding modes\n      //mapping is not available, assume that the user just wants to set\n      //dbNumber.roundingMode explicitly or use default\n      if (this._roundingModesMap.size === 0) {\n        return;\n      }\n      //Otherwise check candidate names\n      let cands = ['rounding', 'roundingMode', 'ROUNDING_MODE', 'RM'];\n      for (let cand of cands) {\n        rm = this._cons[cand];\n        if (rm != null) {\n          rmFunc = cons => cons[cand];\n          break;\n        }\n      }\n      //If not found any way to get rounding mode, let the user set\n      //dbNumber.roundingMode explicitly or use default\n      if (rmFunc == null) {\n        return;\n      }\n    }\n    this._getRoundingMode = cons => {\n      const rmVal = rmFunc(cons);\n      const rm = this._roundingModesMap.get(rmVal);\n      if (rm == null) {\n        throw new NoSQLArgumentError(`Could not determine rounding \\\nmode with value ${util.inspect(rmVal)}, please check configuration \\\nproperties dbNumber.RoundingModes and dbNumber.getRoundingMode`, cfg);\n      }\n      return rm;\n    };\n  }\n  _initGetPrecision(cfg) {\n    let prec;\n    let precFunc;\n    if (cfg.dbNumber.getPrecision != null) {\n      switch (typeof cfg.dbNumber.getPrecision) {\n        case 'function':\n          precFunc = cfg.dbNumber.getPrecision;\n          break;\n        case 'string':\n          prec = propertyByString(this._cons, cfg.dbNumber.getPrecision);\n          if (!isPosInt32(prec)) {\n            throw new NoSQLArgumentError(`Missing or invalid value \\\nfor dbNumber.getRoundingMode property ${cfg.dbNumber.getPrecision}`, cfg);\n          }\n          precFunc = cons => propertyByString(cons, cfg.dbNumber.getPrecision);\n          break;\n        default:\n          throw new NoSQLArgumentError(`Invalid \\\ndbNumber.getPrecision: ${util.inspect(cfg.dbNumber.getPrecision)}`);\n      }\n    }\n    if (precFunc == null) {\n      const cands = ['precision', 'PRECISION'];\n      for (let cand of cands) {\n        prec = this._cons[cand];\n        if (isPosInt32(prec)) {\n          precFunc = cons => cons[cand];\n          break;\n        }\n      }\n      if (precFunc == null) {\n        return;\n      }\n    }\n    this._getPrecision = cons => {\n      let prec = precFunc(cons);\n      if (!isPosInt32(prec)) {\n        throw new NoSQLArgumentError(`Got invalid precision value: \\\n${util.inspect(prec)}, please check configuration property \\\ndbNumber.getPrecision`, cfg);\n      }\n      return prec;\n    };\n  }\n\n  //get rounding mode constant in Java's format via _roundingModesMap\n  _initRoundingMode(cfg) {\n    if (cfg.dbNumber.roundingMode != null) {\n      if (typeof cfg.dbNumber.roundingMode === 'string') {\n        //check if dbNumber.roundingMode could be just a name of\n        //the rounding mode enumeration constant (with or without\n        //ROUND_ prefix)\n        const rm = cfg.dbNumber.roundingMode.startsWith('ROUND_') ? cfg.dbNumber.roundingMode.substring(6) : cfg.dbNumber.roundingMode;\n        if (rm in RoundingModes) {\n          this._roundingMode = RoundingModes[rm];\n          return;\n        }\n      }\n      this._roundingMode = this._roundingModesMap.get(cfg.dbNumber.roundingMode);\n      if (this._roundingMode == null) {\n        throw new NoSQLArgumentError(`Could not determine rounding \\\nmode set by configuration property dbNumber.roundingMode with value \\\n${util.inspect(cfg.dbNumber.roundingMode)}, please check configuration \\\nproperties dbNumber.roundingMode and dbNumber.RoundingModes`, cfg);\n      }\n      return;\n    }\n    if (this._getRoundingMode != null) {\n      this._roundingMode = this._getRoundingMode(this._cons);\n    } else {\n      //if rounding mode cannot be found, use default ROUND_HALF_UP\n      this._roundingMode = RoundingModes.HALF_UP;\n    }\n  }\n  _initPrecision(cfg) {\n    if (cfg.dbNumber.precision != null) {\n      if (!isPosInt32(cfg.dbNumber.precision)) {\n        throw new NoSQLArgumentError(`Invalid value of \\\ndbNumber.precision: ${cfg.dbNumber.precision}`, cfg);\n      }\n      this._precision = cfg.dbNumber.precision;\n    } else if (this._getPrecision != null) {\n      this._precision = this._getPrecision(this._cons);\n    } else {\n      this._precision = DEFAULT_PRECISION;\n    }\n  }\n}\nmodule.exports = NumberTypeHandler;","map":{"version":3,"names":["assert","require","util","NoSQLArgumentError","propertyByString","isPosInt32","requireNoWP","RoundingModes","UP","DOWN","CEILING","FLOOR","HALF_UP","HALF_DOWN","HALF_EVEN","UNNECESSARY","DEFAULT_PRECISION","NumberTypeHandler","constructor","cfg","dbNumber","_initCons","isInstance","val","_cons","create","_initMethod","valuesEqual","v1","v2","compare","numberValue","v","Number","stringValue","_initRoundingModesMap","_initGetRoundingMode","_initGetPrecision","_initRoundingMode","_initPrecision","err","precision","_precision","roundingMode","_roundingMode","module","_mod","Constructor","_findFuncByProp","name","isStatic","subName","sub","obj","prototype","func","_findFunc","cands","staticCands","retNull","cand","numArgs","isSoft","meth","bind","call","inst","args","_findRoundingModes","candObjs","push","candObj","roundingModes","inspect","candProps","candProp","_roundingModes","_roundingModesMap","Map","ent","Object","entries","set","rm","rmFunc","getRoundingMode","cons","size","_getRoundingMode","rmVal","get","prec","precFunc","getPrecision","_getPrecision","startsWith","substring","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/db_number.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst propertyByString = require('./utils').propertyByString;\nconst isPosInt32 = require('./utils').isPosInt32;\nconst requireNoWP = require('./utils').requireNoWP;\n\nconst RoundingModes = {\n    UP: 0,\n    DOWN: 1,\n    CEILING: 2,\n    FLOOR: 3,\n    HALF_UP: 4,\n    HALF_DOWN: 5,\n    HALF_EVEN: 6,\n    UNNECESSARY: 7\n};\n\nconst DEFAULT_PRECISION = 20;\n\nclass NumberTypeHandler {\n\n    constructor(cfg) {\n        assert(cfg.dbNumber != null);\n        try {\n            this._initCons(cfg);\n\n            //These can be customized in future to allow creation of number\n            //instances by callable functions (instead of constructor). \n            this.isInstance = val => val instanceof this._cons;\n            this.create = val => new this._cons(val);\n            \n            this._initMethod(cfg, 'stringValue', 1, [ 'toString' ], []);\n            this._initMethod(cfg, 'compare', 2,\n                [ 'comparedTo', 'compareTo', 'cmp', 'compare' ]);\n            this._initMethod(cfg, 'valuesEqual', 2,\n                [ 'equals', 'isEqualTo', 'eq' ], [], true);\n            if (this.valuesEqual == null) {\n                this.valuesEqual = (v1, v2) => this.compare(v1, v2) === 0;\n            }\n            this._initMethod(cfg, 'numberValue', 1, [ 'toNumber' ], [], true);\n            if (this.numberValue == null) {\n                this.numberValue = v => Number(this.stringValue(v));\n            }\n            this._initMethod(cfg, 'add', 2, [ 'plus', 'add' ]);\n            this._initMethod(cfg, 'subtract', 2,\n                [ 'minus', 'sub', 'subtract' ]);\n            this._initMethod(cfg, 'multiply', 2,\n                [ 'times', 'multipliedBy', 'multiply', 'mul' ]);\n            this._initMethod(cfg, 'divide', 2,\n                [ 'dividedBy', 'divide', 'div' ]);\n            this._initRoundingModesMap(cfg);\n            this._initGetRoundingMode(cfg);\n            this._initGetPrecision(cfg);\n            this._initRoundingMode(cfg);\n            this._initPrecision(cfg);\n        } catch(err) {\n            throw new NoSQLArgumentError('Failed to initialize dbNumber \\\nconfiguration', cfg, err);\n        }\n    }\n\n    get precision() {\n        return this._precision;\n    }\n\n    get roundingMode() {\n        return this._roundingMode;\n    }\n\n    _initCons(cfg) {\n        switch(typeof cfg.dbNumber) {\n        case 'function':\n            this._cons = cfg.dbNumber;\n            return;\n        case 'string':\n            this._cons = requireNoWP(cfg.dbNumber);\n            break;\n        case 'object':\n            if (cfg.dbNumber.module != null) {\n                if (typeof cfg.dbNumber.module !== 'string') {\n                    throw new NoSQLArgumentError('Invalid dbNumber.module \\\nproperty, must be string', cfg);\n                }\n                this._mod = requireNoWP(cfg.dbNumber.module);\n                if (cfg.dbNumber.Constructor == null) {\n                    this._cons = this._mod;\n                    break;\n                } else if (typeof cfg.dbNumber.Constructor === 'string') {\n                    this._cons = this._mod[cfg.dbNumber.Constructor];\n                    break;\n                }\n            }\n            this._cons = typeof cfg.dbNumber.Constructor === 'string' ?\n                requireNoWP(cfg.dbNumber.Constructor) :\n                cfg.dbNumber.Constructor;\n            break;\n        default:\n            throw new NoSQLArgumentError('Invalid dbNumber property', cfg);\n        }\n        if (this._cons == null) {\n            throw new NoSQLArgumentError('Missing dbNumber constructor', cfg);\n        }\n        if (typeof this._cons !== 'function') {\n            throw new NoSQLArgumentError('Invalid dbNumber constructor', cfg);\n        }\n    }\n\n    _findFuncByProp(cfg, name, isStatic) {\n        if (typeof cfg.dbNumber !== 'object') {\n            return null;\n        }\n        const subName = isStatic ? 'static' : 'instance';\n        const sub = cfg.dbNumber[subName];\n        if (sub == null) {\n            return null;\n        }\n        if (typeof sub !== 'object') {\n            throw new NoSQLArgumentError(\n                `Invalid dbNumber.${subName} property`, cfg);\n        }\n        const obj = isStatic ? this._cons : this._cons.prototype;\n        let func = sub[name];\n        if (func == null) {\n            return null;\n        }\n        if (typeof func === 'string') {\n            func = obj[func];\n        }\n        if (typeof func !== 'function') {\n            throw new NoSQLArgumentError(`Property \\\ndbNumber.${subName}.${name} points to missing or invalid method of \\\n${this._cons.name}`, cfg);\n        }\n        return func;\n    }\n\n    _findFunc(cfg, name, cands, staticCands, retNull) {\n        let func = this._findFuncByProp(cfg, name, false);\n        if (func != null) {\n            return { isStatic: false, func };\n        }\n        func = this._findFuncByProp(cfg, name, true);\n        if (func != null) {\n            return { isStatic: true, func };\n        }\n        if (cands != null) {\n            for(let cand of cands) {\n                func = this._cons.prototype[cand];\n                if (typeof func === 'function') {\n                    return { isStatic: false, func };\n                }\n            }\n        }\n        if (staticCands == null) {\n            staticCands = cands;\n        }\n        if (staticCands != null) {\n            for(let cand of staticCands) {\n                func = this._cons[cand];\n                if (typeof func === 'function') {\n                    return { isStatic: true, func };\n                }\n            }\n        }\n        if (retNull) {\n            return null;\n        }\n        throw new NoSQLArgumentError(`Could not find dbNumber method for \\\n${name}`, cfg);\n    }\n\n    _initMethod(cfg, name, numArgs, cands, staticCands, isSoft) {\n        const meth = this._findFunc(cfg, name, cands, staticCands, isSoft);\n        if (meth == null) {\n            return;\n        }\n        if (meth.isStatic) {\n            this[name] = meth.func.bind(this._cons);\n        } else {\n            //not certain if this optimization is needed or the default case\n            //is sufficient\n            switch(numArgs) {\n            case 1:\n                this[name] = v => meth.func.call(v);\n                break;\n            case 2:\n                this[name] = (v1, v2) => meth.func.call(v1, v2);\n                break;\n            default:\n                this[name] = (inst, ...args) => meth.func.call(inst, ...args);\n                break;\n            }\n        }\n    }\n\n    _findRoundingModes(cfg) {\n        const candObjs = [ this._cons ];\n        if (this._mod != null) {\n            candObjs.push(this._mod);\n        }\n        //First look at dbNumber.RoundingModes which should be either a\n        //property name of rounding modes object or that object itself\n        if (cfg.dbNumber.RoundingModes != null) {\n            if (typeof cfg.dbNumber.RoundingModes === 'string') {\n                for(let candObj of candObjs) {\n                    const roundingModes = propertyByString(candObj,\n                        cfg.dbNumber.RoundingModes);\n                    if (roundingModes !== null &&\n                        typeof roundingModes === 'object' ||\n                        typeof roundingModes === 'function') {\n                        return roundingModes;\n                    }\n                }\n                throw new NoSQLArgumentError(`Missing or invalid value for \\\ndbNumber.RoundingModes property ${cfg.dbNumber.RoundingModes}`);\n            }\n            if (typeof cfg.dbNumber.RoundingModes !== 'object' &&\n                typeof cfg.dbNumber.RoundingModes !== 'function') {\n                throw new NoSQLArgumentError(`Invalid \\\ndbNumber.RoundingModes: ${util.inspect(cfg.dbNumber.RoundingModes)}`, cfg);\n            }\n            return cfg.dbNumber.RoundingModes;\n        }\n        //Otherwise check candidate property names on module or\n        //constructor\n        const candProps = [ 'RoundingModes', 'RoundingMode' ];\n        for(let candObj of candObjs) {\n            for(let candProp of candProps) {\n                const roundingModes = candObj[candProp];\n                if (roundingModes !== null &&\n                    typeof roundingModes === 'object' ||\n                    typeof roundingModes === 'function') {\n                    return roundingModes;\n                }\n            }\n        }\n        //If still not found, assume that constructor itself contains rounding\n        //mode constants\n        return this._cons;\n    }\n\n    //create a Map mapping 3rd party rounding mode constants to Java's\n    _initRoundingModesMap(cfg) {\n        this._roundingModes = this._findRoundingModes(cfg);\n        //Create a mapping from 3rd party rounding mode values to Java's\n        this._roundingModesMap = new Map();\n        for(let ent of Object.entries(RoundingModes)) {\n            //Look for properties with and without ROUND_ prefix\n            let val = this._roundingModes['ROUND_' + ent[0]];\n            if (val == null) {\n                val = this._roundingModes[ent[0]];\n            }\n            if (val != null) {\n                this._roundingModesMap.set(val, ent[1]);\n            }\n        }\n    }\n\n    _initGetRoundingMode(cfg) {\n        let rm;\n        let rmFunc;\n        if (cfg.dbNumber.getRoundingMode != null) {\n            switch(typeof cfg.dbNumber.getRoundingMode) {\n            case 'function':\n                rmFunc = cfg.dbNumber.getRoundingMode;\n                break;\n            case 'string':\n                rm = propertyByString(this._cons,\n                    cfg.dbNumber.getRoundingMode);\n                if (rm == null) {\n                    throw new NoSQLArgumentError(`Missing value for \\\n    dbNumber.getRoundingMode property ${cfg.dbNumber.getRoundingMode}`, cfg);\n                }\n                rmFunc = cons => propertyByString(cons,\n                    cfg.dbNumber.getRoundingMode);\n                break;\n            default:\n                throw new NoSQLArgumentError(`Invalid \\\ndbNumber.getRoundingMode: ${util.inspect(cfg.dbNumber.getRoundingMode)}`);\n            }\n        } else {\n            //If dbNumber.getRoundingMode is not set and rounding modes\n            //mapping is not available, assume that the user just wants to set\n            //dbNumber.roundingMode explicitly or use default\n            if (this._roundingModesMap.size === 0) {\n                return;\n            }\n            //Otherwise check candidate names\n            let cands = [ 'rounding', 'roundingMode', 'ROUNDING_MODE',\n                'RM' ];\n            for(let cand of cands) {\n                rm = this._cons[cand];\n                if (rm != null) {\n                    rmFunc = cons => cons[cand];\n                    break;\n                }\n            }\n            //If not found any way to get rounding mode, let the user set\n            //dbNumber.roundingMode explicitly or use default\n            if (rmFunc == null) {\n                return;\n            }\n        }\n\n        this._getRoundingMode = cons => {\n            const rmVal = rmFunc(cons);\n            const rm = this._roundingModesMap.get(rmVal);\n            if (rm == null) {\n                throw new NoSQLArgumentError(`Could not determine rounding \\\nmode with value ${util.inspect(rmVal)}, please check configuration \\\nproperties dbNumber.RoundingModes and dbNumber.getRoundingMode`, cfg);\n            }\n            return rm;\n        };\n    }\n\n    _initGetPrecision(cfg) {\n        let prec;\n        let precFunc;\n        if (cfg.dbNumber.getPrecision != null) {\n            switch(typeof cfg.dbNumber.getPrecision) {\n            case 'function':\n                precFunc = cfg.dbNumber.getPrecision;\n                break;\n            case 'string':\n                prec = propertyByString(this._cons,\n                    cfg.dbNumber.getPrecision);\n                if (!isPosInt32(prec)) {\n                    throw new NoSQLArgumentError(`Missing or invalid value \\\nfor dbNumber.getRoundingMode property ${cfg.dbNumber.getPrecision}`, cfg);\n                }\n                precFunc = cons => propertyByString(cons,\n                    cfg.dbNumber.getPrecision);\n                break;\n            default:\n                throw new NoSQLArgumentError(`Invalid \\\ndbNumber.getPrecision: ${util.inspect(cfg.dbNumber.getPrecision)}`);\n            }\n        }\n\n        if (precFunc == null) {\n            const cands = [ 'precision', 'PRECISION' ];\n            for(let cand of cands) {\n                prec = this._cons[cand];\n                if (isPosInt32(prec)) {\n                    precFunc = cons => cons[cand];\n                    break;\n                }\n            }\n            if (precFunc == null) {\n                return;\n            }\n        }\n\n        this._getPrecision = cons => {\n            let prec = precFunc(cons);\n            if (!isPosInt32(prec)) {\n                throw new NoSQLArgumentError(`Got invalid precision value: \\\n${util.inspect(prec)}, please check configuration property \\\ndbNumber.getPrecision`, cfg);\n            }\n            return prec;\n        };\n    }\n\n    //get rounding mode constant in Java's format via _roundingModesMap\n    _initRoundingMode(cfg) {\n        if (cfg.dbNumber.roundingMode != null) {\n            if (typeof cfg.dbNumber.roundingMode === 'string') {\n                //check if dbNumber.roundingMode could be just a name of\n                //the rounding mode enumeration constant (with or without\n                //ROUND_ prefix)\n                const rm = cfg.dbNumber.roundingMode.startsWith('ROUND_') ?\n                    cfg.dbNumber.roundingMode.substring(6) :\n                    cfg.dbNumber.roundingMode;\n                if (rm in RoundingModes) {\n                    this._roundingMode = RoundingModes[rm];\n                    return;\n                }\n            }\n            this._roundingMode = this._roundingModesMap.get(\n                cfg.dbNumber.roundingMode);\n            if (this._roundingMode == null) {\n                throw new NoSQLArgumentError(`Could not determine rounding \\\nmode set by configuration property dbNumber.roundingMode with value \\\n${util.inspect(cfg.dbNumber.roundingMode)}, please check configuration \\\nproperties dbNumber.roundingMode and dbNumber.RoundingModes`, cfg);\n            }\n            return;\n        }\n        if (this._getRoundingMode != null) {\n            this._roundingMode = this._getRoundingMode(this._cons);\n        } else {\n            //if rounding mode cannot be found, use default ROUND_HALF_UP\n            this._roundingMode = RoundingModes.HALF_UP;\n        }\n    }\n\n    _initPrecision(cfg) {\n        if (cfg.dbNumber.precision != null) {\n            if (!isPosInt32(cfg.dbNumber.precision)) {\n                throw new NoSQLArgumentError(`Invalid value of \\\ndbNumber.precision: ${cfg.dbNumber.precision}`, cfg);\n            }\n            this._precision = cfg.dbNumber.precision;\n        } else if (this._getPrecision != null) {\n            this._precision = this._getPrecision(this._cons);\n        } else {\n            this._precision = DEFAULT_PRECISION;\n        }\n    }\n\n}\n\nmodule.exports = NumberTypeHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}