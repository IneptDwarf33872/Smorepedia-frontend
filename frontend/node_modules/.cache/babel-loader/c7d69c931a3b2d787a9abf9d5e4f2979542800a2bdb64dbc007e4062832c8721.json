{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst NoSQLQueryError = require('../error').NoSQLQueryError;\nconst isPosInt32OrZero = require('../utils').isPosInt32OrZero;\nconst PlanIterator = require('./common').PlanIterator;\nconst fieldValuesEqual = require('./compare').fieldValuesEqual;\n\n/**\n * SFWIterator is used for:\n * (a) project out result columns that do not appear in the SELECT list of\n *     the query, but are included in the results fetched from the proxy,\n *     because the are order-by columns or primary-key columns used for\n *     duplicate elimination.\n * (b) For group-by and aggregation queries, regroup and reaggregate the\n *     partial gropus/aggregates received from the proxy.\n * (c) implement offset and limit.\n */\nclass SFWIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n    this._fromIter = qpExec.makeIterator(step.fromStep);\n    this._colIters = new Array(step.colSteps.length);\n    for (let i = 0; i < this._colIters.length; i++) {\n      const it = qpExec.makeIterator(step.colSteps[i]);\n      assert(!it.isAsync());\n      this._colIters[i] = it;\n    }\n    this._offsetIter = qpExec.makeIterator(step.offsetStep);\n    assert(!this._offsetIter || !this._offsetIter.isAsync());\n    this._limitIter = qpExec.makeIterator(step.limitStep);\n    assert(!this._limitIter || !this._limitIter.isAsync());\n    this._offset = this._offsetIter ? this._getOffset() : 0;\n    this._limit = this._limitIter ? this._getLimit() : -1;\n    this._resCnt = 0;\n  }\n  static validateStep(step) {\n    if (!step.fromStep) {\n      throw NoSQLQueryError.illegalState('Missing fromIterator in SFW');\n    }\n    if (!step.colSteps || !step.colSteps.length) {\n      throw NoSQLQueryError.illegalState('Missing column iterators in \\\nSFW');\n    }\n    if (step.isSelectStar && step.colSteps.length !== 1) {\n      throw NoSQLQueryError.illegalState('Multiple column iterators for \\\nselectStar in SFW');\n    }\n    for (let s of step.colSteps) {\n      assert(s.itCls);\n      if (s.itCls._isAsync) {\n        throw this.illegalState(`Unexpected async column iterator \\\n${s.displayName} for SFW`);\n      }\n    }\n    if (step.offsetStep != null) {\n      assert(step.offsetStep.itCls);\n      if (step.offsetStep.itCls._isAsync) {\n        throw this.illegalState(`Unexpected async offset iterator \\\n${step.offsetStep.displayName} for SFW`);\n      }\n    }\n    if (step.limitStep != null) {\n      assert(step.limitStep.itCls);\n      if (step.limitStep && step.limitStep.itCls._isAsync) {\n        throw this.illegalState(`Unexpected async offset iterator \\\n${step.limitStep.displayName} for SFW`);\n      }\n    }\n  }\n  _getOffset() {\n    if (!this._offsetIter.next()) {\n      throw this.illegalState('Offset iterator has no results');\n    }\n    const off = this._offsetIter.result;\n    if (!isPosInt32OrZero(off)) {\n      throw this.illegalArg(`Invalid offset: ${off}`, this._offsetIter._step.exprLoc);\n    }\n    return off;\n  }\n  _getLimit() {\n    if (!this._limitIter.next()) {\n      throw this.illegalState('Limit iterator has not results');\n    }\n    const lim = this._limitIter.result;\n    if (!isPosInt32OrZero(lim)) {\n      throw this.illegalArg(`Invalid limit: ${lim}`, this._limitIter._step.exprLoc);\n    }\n    return lim;\n  }\n  _aggregateCol(it) {\n    if (!it.next()) {\n      throw this.illegalState('Aggregate iterator reached end', it._step.exprLoc);\n    }\n    it.reset();\n  }\n  _aggregateRow() {\n    for (let i = this._step.gbColCnt; i < this._colIters.length; i++) {\n      this._aggregateCol(this._colIters[i]);\n    }\n  }\n\n  /*\n   * This method checks whether the current input tuple (a) starts the\n   * first group, i.e. it is the very 1st tuple in the input stream, or\n   * (b) belongs to the current group, or (c) starts a new group otherwise.\n   * The method returns true in case (c), indicating that an output tuple\n   * is ready to be returned to the consumer of this SFW. Otherwise, false\n   * is returned.\n   */\n  _groupInputRow() {\n    let i;\n    /*\n     * If this is the very first input row, start the first group and\n     * go back to compute next input row.\n     */\n    if (!this._gbRow) {\n      this._gbRow = new Array(this._step.gbColCnt);\n      for (i = 0; i < this._gbRow.length; i++) {\n        this._gbRow[i] = this._colIters[i].result;\n      }\n      this._aggregateRow();\n      return false;\n    }\n    //Compare the current input row with the current group row\n    for (i = 0; i < this._gbRow.length; i++) {\n      if (!fieldValuesEqual(this, this._colIters[i].result, this._gbRow[i])) {\n        break;\n      }\n    }\n    /*\n     * If the input row is in current group, update the aggregate\n     * functions and go back to compute the next input row.\n     */\n    if (i === this._gbRow.length) {\n      this._aggregateRow();\n      return false;\n    }\n\n    /*\n     * Input row starts new group. We must finish up the current group,\n     * produce result, and init the new group.\n     */\n    const res = {};\n    for (i = 0; i < this._gbRow.length; i++) {\n      res[this._step.colNames[i]] = this._gbRow[i];\n      //init new group by column values\n      this._gbRow[i] = this._colIters[i].result;\n    }\n    for (i = this._gbRow.length; i < this._colIters.length; i++) {\n      const it = this._colIters[i];\n      res[this._step.colNames[i]] = it.result;\n      it.reset(true);\n      //aggregate column values for new row\n      this._aggregateCol(it);\n    }\n    this.result = res;\n    return true;\n  }\n  _produceLastGroup() {\n    //Ignore last group if we haven't started grouping yet, execution\n    //needs user continuation (group not ready yet) or if we haven't\n    //skipped the offset yet\n    if (!this._gbRow || this._qpExec._needUserCont || this._offset) {\n      return false;\n    }\n    const res = {};\n    let i;\n    for (i = 0; i < this._gbRow.length; i++) {\n      res[this._step.colNames[i]] = this._gbRow[i];\n    }\n    for (i = this._gbRow.length; i < this._colIters.length; i++) {\n      res[this._step.colNames[i]] = this._colIters[i].result;\n    }\n    this.result = res;\n    this._lastGroupDone = true;\n    return true;\n  }\n\n  //non-grouping next\n  async _simpleNext() {\n    if (!(await this._fromIter.next())) {\n      return false;\n    }\n    //Skip if offset has not been reached yet\n    if (this._offset > 0) {\n      return true;\n    }\n    //In case of selectStar this iterator shares result registry with\n    //the 1st column iterator which will contain the result.\n    if (this._step.isSelectStar) {\n      if (!this._colIters[0].next()) {\n        throw this.illegalState('Column iterator has no results in \\\nSFWIterator for selectStar');\n      }\n      this._colIters[0].reset();\n      return true;\n    }\n    //Create result record from colIters results.\n    const res = {};\n    for (let i = 0; i < this._colIters.length; i++) {\n      const it = this._colIters[i];\n      //it.next() may return false if this is for JSON field and\n      //that field doesn't exist in the current record\n      const hasRes = it.next();\n      res[this._step.colNames[i]] = hasRes ? it.result : undefined;\n      it.reset();\n    }\n    this.result = res;\n    return true;\n  }\n  async _groupingNext() {\n    if (this._lastGroupDone) {\n      return false;\n    }\n    for (;;) {\n      if (!(await this._fromIter.next())) {\n        return this._produceLastGroup();\n      }\n      //Compute the exprs of group by columns\n      let i;\n      for (i = 0; i < this._step.gbColCnt; i++) {\n        const it = this._colIters[i];\n        //it.next() may return false if this is for JSON field and\n        //that field doesn't exist in the current record\n        if (!(await it.next())) {\n          it.reset();\n          break;\n        }\n        it.reset();\n      }\n      //skip records with non-existing JSON fields in the group by\n      //columns\n      if (i < this._step.gbColCnt) {\n        continue;\n      }\n      if (this._groupInputRow()) {\n        return true;\n      }\n    }\n  }\n  async next() {\n    if (this._limit >= 0 && this._resCnt >= this._limit) {\n      return false;\n    }\n    //loop to skip offset results\n    for (;;) {\n      const hasRes = await (this._step.gbColCnt < 0 ? this._simpleNext() : this._groupingNext());\n      if (!hasRes) {\n        return false;\n      }\n      if (!this._offset) {\n        this._resCnt++;\n        return true;\n      }\n      this._offset--;\n    }\n  }\n\n  //should not be called\n  reset() {\n    throw this.illegalState('Reset should not be called for SFWIterator');\n  }\n}\nSFWIterator._isAsync = true;\nmodule.exports = SFWIterator;","map":{"version":3,"names":["assert","require","NoSQLQueryError","isPosInt32OrZero","PlanIterator","fieldValuesEqual","SFWIterator","constructor","qpExec","step","_fromIter","makeIterator","fromStep","_colIters","Array","colSteps","length","i","it","isAsync","_offsetIter","offsetStep","_limitIter","limitStep","_offset","_getOffset","_limit","_getLimit","_resCnt","validateStep","illegalState","isSelectStar","s","itCls","_isAsync","displayName","next","off","result","illegalArg","_step","exprLoc","lim","_aggregateCol","reset","_aggregateRow","gbColCnt","_groupInputRow","_gbRow","res","colNames","_produceLastGroup","_qpExec","_needUserCont","_lastGroupDone","_simpleNext","hasRes","undefined","_groupingNext","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/query/sfw.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst NoSQLQueryError = require('../error').NoSQLQueryError;\nconst isPosInt32OrZero = require('../utils').isPosInt32OrZero;\nconst PlanIterator = require('./common').PlanIterator;\nconst fieldValuesEqual = require('./compare').fieldValuesEqual;\n\n/**\n * SFWIterator is used for:\n * (a) project out result columns that do not appear in the SELECT list of\n *     the query, but are included in the results fetched from the proxy,\n *     because the are order-by columns or primary-key columns used for\n *     duplicate elimination.\n * (b) For group-by and aggregation queries, regroup and reaggregate the\n *     partial gropus/aggregates received from the proxy.\n * (c) implement offset and limit.\n */\nclass SFWIterator extends PlanIterator {\n\n    constructor(qpExec, step) {\n        super(qpExec, step);\n        this._fromIter = qpExec.makeIterator(step.fromStep);\n        this._colIters = new Array(step.colSteps.length);\n        for(let i = 0; i < this._colIters.length; i++) {\n            const it =  qpExec.makeIterator(step.colSteps[i]);\n            assert(!it.isAsync());\n            this._colIters[i] = it;\n        }\n\n        this._offsetIter = qpExec.makeIterator(step.offsetStep);\n        assert(!this._offsetIter || !this._offsetIter.isAsync());\n        this._limitIter = qpExec.makeIterator(step.limitStep);\n        assert(!this._limitIter || !this._limitIter.isAsync());\n        \n        this._offset = this._offsetIter ? this._getOffset() : 0;\n        this._limit = this._limitIter ? this._getLimit() : -1;\n        this._resCnt = 0;\n    }\n\n    static validateStep(step) {\n        if (!step.fromStep) {\n            throw NoSQLQueryError.illegalState('Missing fromIterator in SFW');\n        }\n        if (!step.colSteps || !step.colSteps.length) {\n            throw NoSQLQueryError.illegalState('Missing column iterators in \\\nSFW');\n        }\n        if (step.isSelectStar && step.colSteps.length !== 1) {\n            throw NoSQLQueryError.illegalState('Multiple column iterators for \\\nselectStar in SFW');\n        }\n        for(let s of step.colSteps) {\n            assert(s.itCls);\n            if (s.itCls._isAsync) {\n                throw this.illegalState(`Unexpected async column iterator \\\n${s.displayName} for SFW`);\n            }\n        }\n        if (step.offsetStep != null) {\n            assert(step.offsetStep.itCls);\n            if (step.offsetStep.itCls._isAsync) {\n                throw this.illegalState(`Unexpected async offset iterator \\\n${step.offsetStep.displayName} for SFW`);\n            }\n        }\n        if (step.limitStep !=  null) {\n            assert(step.limitStep.itCls);\n            if (step.limitStep && step.limitStep.itCls._isAsync) {\n                throw this.illegalState(`Unexpected async offset iterator \\\n${step.limitStep.displayName} for SFW`);\n            }\n        }\n    }\n\n    _getOffset() {\n        if (!this._offsetIter.next()) {\n            throw this.illegalState('Offset iterator has no results');\n        }\n        const off = this._offsetIter.result;\n        if (!isPosInt32OrZero(off)) {\n            throw this.illegalArg(`Invalid offset: ${off}`,\n                this._offsetIter._step.exprLoc);\n        }\n        return off;\n    }\n\n    _getLimit() {\n        if (!this._limitIter.next()) {\n            throw this.illegalState('Limit iterator has not results');\n        }\n        const lim = this._limitIter.result;\n        if (!isPosInt32OrZero(lim)) {\n            throw this.illegalArg(`Invalid limit: ${lim}`,\n                this._limitIter._step.exprLoc);\n        }\n        return lim;\n    }\n\n    _aggregateCol(it) {\n        if (!it.next()) {\n            throw this.illegalState('Aggregate iterator reached end',\n                it._step.exprLoc);\n        }\n        it.reset();\n    }\n\n    _aggregateRow() {\n        for(let i = this._step.gbColCnt; i < this._colIters.length; i++) {\n            this._aggregateCol(this._colIters[i]);\n        }\n    }\n\n    /*\n     * This method checks whether the current input tuple (a) starts the\n     * first group, i.e. it is the very 1st tuple in the input stream, or\n     * (b) belongs to the current group, or (c) starts a new group otherwise.\n     * The method returns true in case (c), indicating that an output tuple\n     * is ready to be returned to the consumer of this SFW. Otherwise, false\n     * is returned.\n     */\n    _groupInputRow() {\n        let i;\n        /*\n         * If this is the very first input row, start the first group and\n         * go back to compute next input row.\n         */\n        if (!this._gbRow) {\n            this._gbRow = new Array(this._step.gbColCnt);\n            for(i = 0; i < this._gbRow.length; i++) {\n                this._gbRow[i] = this._colIters[i].result;\n            }\n            this._aggregateRow();\n            return false;\n        }\n        //Compare the current input row with the current group row\n        for(i = 0; i < this._gbRow.length; i++) {\n            if (!fieldValuesEqual(this, this._colIters[i].result,\n                this._gbRow[i])) {\n                break;\n            }\n        }\n        /*\n         * If the input row is in current group, update the aggregate\n         * functions and go back to compute the next input row.\n         */\n        if (i === this._gbRow.length) {\n            this._aggregateRow();\n            return false;\n        }\n\n        /*\n         * Input row starts new group. We must finish up the current group,\n         * produce result, and init the new group.\n         */\n        const res = {};\n        for(i = 0; i < this._gbRow.length; i++) {\n            res[this._step.colNames[i]] = this._gbRow[i];\n            //init new group by column values\n            this._gbRow[i] = this._colIters[i].result;\n        }\n        for(i = this._gbRow.length; i < this._colIters.length; i++) {\n            const it = this._colIters[i];\n            res[this._step.colNames[i]] = it.result;\n            it.reset(true);\n            //aggregate column values for new row\n            this._aggregateCol(it);\n        }\n        this.result = res;\n        return true;\n    }\n\n    _produceLastGroup() {\n        //Ignore last group if we haven't started grouping yet, execution\n        //needs user continuation (group not ready yet) or if we haven't\n        //skipped the offset yet\n        if (!this._gbRow || this._qpExec._needUserCont || this._offset) {\n            return false;\n        }\n        const res = {};\n        let i;\n        for(i = 0; i < this._gbRow.length; i++) {\n            res[this._step.colNames[i]] = this._gbRow[i];\n        }\n        for(i = this._gbRow.length; i < this._colIters.length; i++) {\n            res[this._step.colNames[i]] = this._colIters[i].result;\n        }\n        this.result = res;\n        this._lastGroupDone = true;\n        return true;\n    }\n\n    //non-grouping next\n    async _simpleNext() {\n        if (!(await this._fromIter.next())) {\n            return false;\n        }\n        //Skip if offset has not been reached yet\n        if (this._offset > 0) {\n            return true;\n        }\n        //In case of selectStar this iterator shares result registry with\n        //the 1st column iterator which will contain the result.\n        if (this._step.isSelectStar) {\n            if (!this._colIters[0].next()) {\n                throw this.illegalState('Column iterator has no results in \\\nSFWIterator for selectStar');\n            }\n            this._colIters[0].reset();\n            return true;\n        }\n        //Create result record from colIters results.\n        const res = {};\n        for(let i = 0; i < this._colIters.length; i++) {\n            const it = this._colIters[i];\n            //it.next() may return false if this is for JSON field and\n            //that field doesn't exist in the current record\n            const hasRes = it.next();\n            res[this._step.colNames[i]] = hasRes ? it.result : undefined;\n            it.reset();\n        }\n        this.result = res;\n        return true;\n    }\n\n    async _groupingNext() {\n        if (this._lastGroupDone) {\n            return false;\n        }\n        for(;;) {\n            if (!(await this._fromIter.next())) {\n                return this._produceLastGroup();\n            }\n            //Compute the exprs of group by columns\n            let i;\n            for(i = 0; i < this._step.gbColCnt; i++) {\n                const it = this._colIters[i];\n                //it.next() may return false if this is for JSON field and\n                //that field doesn't exist in the current record\n                if (!(await it.next())) {\n                    it.reset();\n                    break;\n                }\n                it.reset();\n            }\n            //skip records with non-existing JSON fields in the group by\n            //columns\n            if (i < this._step.gbColCnt) {\n                continue;\n            }\n            if (this._groupInputRow()) {\n                return true;\n            }\n        }\n    }\n\n    async next() {\n        if (this._limit >= 0 && this._resCnt >= this._limit) {\n            return false;\n        }\n        //loop to skip offset results\n        for(;;) {\n            const hasRes = await (this._step.gbColCnt < 0 ?\n                this._simpleNext() :\n                this._groupingNext());\n            if (!hasRes) {\n                return false;\n            }\n            if (!this._offset) {\n                this._resCnt++;\n                return true;\n            }\n            this._offset--;\n        }\n    }\n\n    //should not be called\n    reset() {\n        throw this.illegalState(\n            'Reset should not be called for SFWIterator');\n    }\n\n}\n\nSFWIterator._isAsync = true;\n\nmodule.exports = SFWIterator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}