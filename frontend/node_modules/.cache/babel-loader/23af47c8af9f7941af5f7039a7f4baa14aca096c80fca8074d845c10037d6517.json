{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst isPosInt = require('./utils').isPosInt;\n\n/**\n * @classdesc  TTLUtil is a utility class that may be used to create and\n * manage {@link TimeToLive} objects and convert between TTL and record\n * expiration time.  TTL behavior and relation to record expiration time\n * is described in {@link TimeToLive}.  Note that on input durations, TTL\n * objects and expiration times are validated for correctness and\n * {@link NoSQLArgumentError} is thrown if the representation is invalid.\n * \n * @hideconstructor\n * \n * @see {@link TimeToLive}\n */\nclass TTLUtil {\n  //Validates and converts to canonical format: {days:numberOrInfinity} or\n  //{hours:number}\n  static _validate(ttl, op) {\n    if (typeof ttl === 'number') {\n      if (!isPosInt(ttl) && ttl !== Infinity) {\n        throw new NoSQLArgumentError('Invalid TTL value', op);\n      }\n      return {\n        days: ttl\n      };\n    }\n    if (typeof ttl !== 'object') {\n      throw new NoSQLArgumentError('Invalid TTL value', op);\n    }\n    if (ttl.days == null && ttl.hours == null || ttl.days != null && ttl.hours != null) {\n      throw new NoSQLArgumentError('TTL must exactly one of ' + 'the fields \"days\" or \"hours\"', op);\n    }\n    if (ttl.days != null) {\n      if (!isPosInt(ttl.days) && ttl.days !== Infinity) {\n        throw new NoSQLArgumentError('Invalid TTL days', op);\n      }\n      return ttl;\n    }\n    if (ttl.hours === Infinity) {\n      return this.DO_NOT_EXPIRE;\n    }\n    if (!isPosInt(ttl.hours)) {\n      throw new NoSQLArgumentError('Invalid TTL hours', op);\n    }\n    return ttl;\n  }\n\n  /**\n   * Convenience constant to indicate that the row should not expire.  It\n   * can be passed as TTL to a put operation to remove expiration from\n   * existing row.\n   */\n  static get DO_NOT_EXPIRE() {\n    return {\n      days: Infinity\n    };\n  }\n\n  /**\n   * Creates TTL with duration of hours\n   * @param {number} hours Number of hours as positive integer or Infinity\n   * @returns {TimeToLive} TTL object\n   * @throws {NoSQLArgumentError} if 'hours' parameter is invalid\n   */\n  static ofHours(hours) {\n    if (hours === Infinity) {\n      return this.DO_NOT_EXPIRE;\n    }\n    if (!isPosInt(hours)) {\n      throw new NoSQLArgumentError('Invalid hours parameter');\n    }\n    return {\n      hours\n    };\n  }\n\n  /**\n   * Creates TTL with duration of days\n   * @param {number} days Number of days as positive integer or Infinity\n   * @returns {TimeToLive} TTL object\n   * @throws {NoSQLArgumentError} if 'days' parameter is invalid\n   */\n  static ofDays(days) {\n    if (!isPosInt(days) && days !== Infinity) {\n      throw new NoSQLArgumentError('Invalid days parameter');\n    }\n    return {\n      days\n    };\n  }\n\n  /**\n   * Returns the number of days in the TTL.  If the TTL is specified in\n   * hours, the resulting days value is rounded down, which will result in 0\n   * if TTL.hours < 24.\n   * @param {TimeToLive} ttl TTL object\n   * @returns {number} Number of days in the TTL object or Infinity\n   * @throws {NoSQLArgumentError} if TTL object is invalid\n   */\n  static toDays(ttl) {\n    ttl = this._validate(ttl);\n    return ttl.hours ? ttl.hours / 24 : ttl.days;\n  }\n\n  /**\n   * Returns the number of hours in the TTL.  If the TTL is specified in\n   * days, the return value is TTL.days * 24.\n   * @param {TimeToLive} ttl TTL object\n   * @returns {number} Number of hours in the TTL object or Infinity\n   * @throws {NoSQLArgumentError} if TTL object is invalid\n   */\n  static toHours(ttl) {\n    ttl = this._validate(ttl);\n    return ttl.hours ? ttl.hours : ttl.days * 24;\n  }\n\n  /**\n   * Convenience constant representing number of milliseconds in 1 hour.\n   */\n  static get MILLIS_IN_HOUR() {\n    return 60 * 60 * 1000;\n  }\n\n  /**\n   * Convenience constant representing number of milliseconds in 1 day.\n   */\n  static get MILLIS_IN_DAY() {\n    return 24 * this.MILLIS_IN_HOUR;\n  }\n\n  /**\n   * Returns number of milliseconds in the TTL.  This is equivalent to\n   * {@link TTLUtil.toHours} multiplied by {@link TTLUtil.MILLIS_IN_HOUR}.\n   * @param {TimeToLive} ttl TTL object \n   * @returns {number} Number of milliseconds in the TTL object or Infinity\n   * @throws {NoSQLArgumentError} if TTL object is invalid\n   * @see {@link TTLUtil#toHours}\n   */\n  static toMillis(ttl) {\n    return this.toHours(ttl) * this.MILLIS_IN_HOUR;\n  }\n\n  /**\n   * Converts TTL to absolute expiration time in milliseconds since Unix\n   * epoch (January 1, 1970, 00:00:00 UTC).  This method is the same as\n   * {@link TTLUtil.toExpirationTime} returning time in milliseconds\n   * instead of as Date object.\n   * @param {TimeToLive} ttl TTL object \n   * @param {Date|number} referenceTime Reference time represented\n   * as [Date]{@link Date} or number of milliseconds since Unix\n   * epoch\n   * @returns {number} Expiration time in milliseconds since Unix epoch or\n   * Infinity\n   * @throws {NoSQLArgumentError} if TTL object or referenceTime is invalid\n   * @see {@link TTLUtil#toExpirationTime}\n   */\n  static toExpirationTimeMillis(ttl, referenceTime) {\n    ttl = this._validate(ttl);\n    if (ttl.days === Infinity) {\n      return Infinity;\n    }\n    if (referenceTime instanceof Date) {\n      referenceTime = referenceTime.getTime();\n    }\n    if (!isPosInt(referenceTime)) {\n      throw new NoSQLArgumentError(`Invalid reference time value ${referenceTime}`);\n    }\n    if (ttl.days) {\n      const expTime = referenceTime + ttl.days * this.MILLIS_IN_DAY;\n      return Math.ceil(expTime / this.MILLIS_IN_DAY) * this.MILLIS_IN_DAY;\n    }\n    const expTime = referenceTime + ttl.hours * this.MILLIS_IN_HOUR;\n    return Math.ceil(expTime / this.MILLIS_IN_HOUR) * this.MILLIS_IN_HOUR;\n  }\n\n  /**\n   * Converts TTL to absolute expration time given the reference time from\n   * which to measure the expiration.  The semantics follows the rounding\n   * behavior described in {@link TimeToLive} so that the returned value\n   * will be rounded up to the nearest hour or day boundary.\n   * @param {TimeToLive} ttl TTL object \n   * @param {Date|number} referenceTime Reference time represented\n   * as [Date]{@link Date} or number of milliseconds since Unix\n   * epoch\n   * @returns {Date} Expiration time as <em>Date</em>\n   * instance, may be invalid if ttl represents no expiration (Infinity)\n   * @throws {NoSQLArgumentError} if TTL object or referenceTime is invalid\n   */\n  static toExpirationTime(ttl, referenceTime) {\n    return new Date(this.toExpirationTimeMillis(ttl, referenceTime));\n  }\n\n  /**\n   * Constructs TTL from absolute expiration time given reference time from\n   * which to measure record expration.  TTL is computed as follows.  First,\n   * expirationTime is rounded up to the nearest hour boundary.  If\n   * <em>inHours</em> argument is specified, then the returned TTL will be\n   * in hours or days depending on whether <em>inHours</em> is true or\n   * false.  If <em>inHours</em> is not specified, we check if the adjusted\n   * expiration time indicates midnight in UTC time zone, in which case\n   * the retured TTL will be in days, otherwise it will be in hours.  Then,\n   * the duration is computed as the difference between the adjusted\n   * expiration time and the reference time rounded up to the nearest hour\n   * or day (depending on which is used in the returned TTL as described\n   * above) and TTL with that duration is returned.  Note that if\n   * expiration time is before or equal to the reference time, it is\n   * possible that the returned value will contain 0 or negative duration,\n   * which indicates that the record has already expired.\n   * @param {Date|number} expirationTime Expiration time\n   * represented as <em>Date</em> or number of milliseconds\n   * since Unix epoch\n   * @param {Date|number} referenceTime Reference time represented\n   * as <em>Date</em> or number of milliseconds since Unix\n   * epoch\n   * @param {boolean} [inHours] Whether to return TTL in hours or days.  If\n   * not specified, the unit of hours or days is determined as described\n   * above\n   * @returns {TimeToLive} TTL object\n   * @throws {NoSQLArgumentError} if expirationTime or referenceTime is\n   * invalid\n   */\n  static fromExpirationTime(expirationTime, referenceTime, inHours) {\n    if (expirationTime instanceof Date) {\n      expirationTime = expirationTime.getTime();\n    }\n    if (!isPosInt(expirationTime)) {\n      throw new NoSQLArgumentError(`Invalid expiration time value ${expirationTime}`);\n    }\n    if (referenceTime instanceof Date) {\n      referenceTime = referenceTime.getTime();\n    }\n    if (!isPosInt(referenceTime)) {\n      throw new NoSQLArgumentError(`Invalid reference time value ${referenceTime}`);\n    }\n    const hours = Math.ceil(expirationTime / this.MILLIS_IN_HOUR);\n    if (inHours == null) {\n      inHours = hours % 24 !== 0;\n    }\n    //adjust up to the hour boundary\n    expirationTime = hours * this.MILLIS_IN_HOUR;\n    const duration = expirationTime - referenceTime;\n    const unitMillis = inHours ? this.MILLIS_IN_HOUR : this.MILLIS_IN_DAY;\n    const val = Math.ceil(duration / unitMillis);\n    return inHours ? this.ofHours(val) : this.ofDays(val);\n  }\n}\nmodule.exports = TTLUtil;","map":{"version":3,"names":["NoSQLArgumentError","require","isPosInt","TTLUtil","_validate","ttl","op","Infinity","days","hours","DO_NOT_EXPIRE","ofHours","ofDays","toDays","toHours","MILLIS_IN_HOUR","MILLIS_IN_DAY","toMillis","toExpirationTimeMillis","referenceTime","Date","getTime","expTime","Math","ceil","toExpirationTime","fromExpirationTime","expirationTime","inHours","duration","unitMillis","val","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/ttl_util.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst isPosInt = require('./utils').isPosInt;\n\n/**\n * @classdesc  TTLUtil is a utility class that may be used to create and\n * manage {@link TimeToLive} objects and convert between TTL and record\n * expiration time.  TTL behavior and relation to record expiration time\n * is described in {@link TimeToLive}.  Note that on input durations, TTL\n * objects and expiration times are validated for correctness and\n * {@link NoSQLArgumentError} is thrown if the representation is invalid.\n * \n * @hideconstructor\n * \n * @see {@link TimeToLive}\n */\nclass TTLUtil {\n\n    //Validates and converts to canonical format: {days:numberOrInfinity} or\n    //{hours:number}\n    static _validate(ttl, op) {\n        if (typeof ttl === 'number') {\n            if (!isPosInt(ttl) && ttl !== Infinity) {\n                throw new NoSQLArgumentError('Invalid TTL value', op);\n            }\n            return { days: ttl };\n        }\n        if (typeof ttl !== 'object') {\n            throw new NoSQLArgumentError('Invalid TTL value', op);\n        }\n        if ((ttl.days == null && ttl.hours == null) ||\n            (ttl.days != null && ttl.hours != null)) {\n            throw new NoSQLArgumentError('TTL must exactly one of ' +\n                'the fields \"days\" or \"hours\"', op);\n        }\n        if (ttl.days != null) {\n            if (!isPosInt(ttl.days) && ttl.days !== Infinity) {\n                throw new NoSQLArgumentError('Invalid TTL days', op);\n            }\n            return ttl;\n        }\n        if (ttl.hours === Infinity) {\n            return this.DO_NOT_EXPIRE;\n        }\n        if (!isPosInt(ttl.hours)) {\n            throw new NoSQLArgumentError('Invalid TTL hours', op);\n        }\n        return ttl;\n    }\n\n    /**\n     * Convenience constant to indicate that the row should not expire.  It\n     * can be passed as TTL to a put operation to remove expiration from\n     * existing row.\n     */\n    static get DO_NOT_EXPIRE() { return { days: Infinity }; }\n\n    /**\n     * Creates TTL with duration of hours\n     * @param {number} hours Number of hours as positive integer or Infinity\n     * @returns {TimeToLive} TTL object\n     * @throws {NoSQLArgumentError} if 'hours' parameter is invalid\n     */\n    static ofHours(hours) {\n        if (hours === Infinity) {\n            return this.DO_NOT_EXPIRE;\n        }\n        if (!isPosInt(hours)) {\n            throw new NoSQLArgumentError('Invalid hours parameter');\n        }\n        return { hours };\n    }\n\n    /**\n     * Creates TTL with duration of days\n     * @param {number} days Number of days as positive integer or Infinity\n     * @returns {TimeToLive} TTL object\n     * @throws {NoSQLArgumentError} if 'days' parameter is invalid\n     */\n    static ofDays(days) {\n        if (!isPosInt(days) && days !== Infinity) {\n            throw new NoSQLArgumentError('Invalid days parameter');\n        }\n        return { days };\n    }\n\n    /**\n     * Returns the number of days in the TTL.  If the TTL is specified in\n     * hours, the resulting days value is rounded down, which will result in 0\n     * if TTL.hours < 24.\n     * @param {TimeToLive} ttl TTL object\n     * @returns {number} Number of days in the TTL object or Infinity\n     * @throws {NoSQLArgumentError} if TTL object is invalid\n     */\n    static toDays(ttl) {\n        ttl = this._validate(ttl);\n        return ttl.hours ? ttl.hours / 24 : ttl.days;\n    }\n\n    /**\n     * Returns the number of hours in the TTL.  If the TTL is specified in\n     * days, the return value is TTL.days * 24.\n     * @param {TimeToLive} ttl TTL object\n     * @returns {number} Number of hours in the TTL object or Infinity\n     * @throws {NoSQLArgumentError} if TTL object is invalid\n     */\n    static toHours(ttl) {\n        ttl = this._validate(ttl);\n        return ttl.hours ? ttl.hours : ttl.days * 24;\n    }\n\n    /**\n     * Convenience constant representing number of milliseconds in 1 hour.\n     */\n    static get MILLIS_IN_HOUR() {\n        return 60 * 60 * 1000;\n    }\n\n    /**\n     * Convenience constant representing number of milliseconds in 1 day.\n     */\n    static get MILLIS_IN_DAY() {\n        return 24 * this.MILLIS_IN_HOUR;\n    }\n\n    /**\n     * Returns number of milliseconds in the TTL.  This is equivalent to\n     * {@link TTLUtil.toHours} multiplied by {@link TTLUtil.MILLIS_IN_HOUR}.\n     * @param {TimeToLive} ttl TTL object \n     * @returns {number} Number of milliseconds in the TTL object or Infinity\n     * @throws {NoSQLArgumentError} if TTL object is invalid\n     * @see {@link TTLUtil#toHours}\n     */\n    static toMillis(ttl) {\n        return this.toHours(ttl) * this.MILLIS_IN_HOUR;\n    }\n\n    /**\n     * Converts TTL to absolute expiration time in milliseconds since Unix\n     * epoch (January 1, 1970, 00:00:00 UTC).  This method is the same as\n     * {@link TTLUtil.toExpirationTime} returning time in milliseconds\n     * instead of as Date object.\n     * @param {TimeToLive} ttl TTL object \n     * @param {Date|number} referenceTime Reference time represented\n     * as [Date]{@link Date} or number of milliseconds since Unix\n     * epoch\n     * @returns {number} Expiration time in milliseconds since Unix epoch or\n     * Infinity\n     * @throws {NoSQLArgumentError} if TTL object or referenceTime is invalid\n     * @see {@link TTLUtil#toExpirationTime}\n     */\n    static toExpirationTimeMillis(ttl, referenceTime) {\n        ttl = this._validate(ttl);\n        if (ttl.days === Infinity) {\n            return Infinity;\n        }\n        if (referenceTime instanceof Date) {\n            referenceTime = referenceTime.getTime();\n        }\n        if (!isPosInt(referenceTime)) {\n            throw new NoSQLArgumentError(\n                `Invalid reference time value ${referenceTime}`);\n        }\n        if (ttl.days) {\n            const expTime = referenceTime + ttl.days * this.MILLIS_IN_DAY;\n            return Math.ceil(expTime / this.MILLIS_IN_DAY) *\n                this.MILLIS_IN_DAY;\n        }\n        const expTime = referenceTime + ttl.hours * this.MILLIS_IN_HOUR;\n        return Math.ceil(expTime / this.MILLIS_IN_HOUR) *\n            this.MILLIS_IN_HOUR;\n    }\n\n    /**\n     * Converts TTL to absolute expration time given the reference time from\n     * which to measure the expiration.  The semantics follows the rounding\n     * behavior described in {@link TimeToLive} so that the returned value\n     * will be rounded up to the nearest hour or day boundary.\n     * @param {TimeToLive} ttl TTL object \n     * @param {Date|number} referenceTime Reference time represented\n     * as [Date]{@link Date} or number of milliseconds since Unix\n     * epoch\n     * @returns {Date} Expiration time as <em>Date</em>\n     * instance, may be invalid if ttl represents no expiration (Infinity)\n     * @throws {NoSQLArgumentError} if TTL object or referenceTime is invalid\n     */\n    static toExpirationTime(ttl, referenceTime) {\n        return new Date(this.toExpirationTimeMillis(ttl, referenceTime));\n    }\n\n    /**\n     * Constructs TTL from absolute expiration time given reference time from\n     * which to measure record expration.  TTL is computed as follows.  First,\n     * expirationTime is rounded up to the nearest hour boundary.  If\n     * <em>inHours</em> argument is specified, then the returned TTL will be\n     * in hours or days depending on whether <em>inHours</em> is true or\n     * false.  If <em>inHours</em> is not specified, we check if the adjusted\n     * expiration time indicates midnight in UTC time zone, in which case\n     * the retured TTL will be in days, otherwise it will be in hours.  Then,\n     * the duration is computed as the difference between the adjusted\n     * expiration time and the reference time rounded up to the nearest hour\n     * or day (depending on which is used in the returned TTL as described\n     * above) and TTL with that duration is returned.  Note that if\n     * expiration time is before or equal to the reference time, it is\n     * possible that the returned value will contain 0 or negative duration,\n     * which indicates that the record has already expired.\n     * @param {Date|number} expirationTime Expiration time\n     * represented as <em>Date</em> or number of milliseconds\n     * since Unix epoch\n     * @param {Date|number} referenceTime Reference time represented\n     * as <em>Date</em> or number of milliseconds since Unix\n     * epoch\n     * @param {boolean} [inHours] Whether to return TTL in hours or days.  If\n     * not specified, the unit of hours or days is determined as described\n     * above\n     * @returns {TimeToLive} TTL object\n     * @throws {NoSQLArgumentError} if expirationTime or referenceTime is\n     * invalid\n     */\n    static fromExpirationTime(expirationTime, referenceTime, inHours) {\n        if (expirationTime instanceof Date) {\n            expirationTime = expirationTime.getTime();\n        }\n        if (!isPosInt(expirationTime)) {\n            throw new NoSQLArgumentError(\n                `Invalid expiration time value ${expirationTime}`);\n        }\n        if (referenceTime instanceof Date) {\n            referenceTime = referenceTime.getTime();\n        }\n        if (!isPosInt(referenceTime)) {\n            throw new NoSQLArgumentError(\n                `Invalid reference time value ${referenceTime}`);\n        }\n        const hours = Math.ceil(expirationTime / this.MILLIS_IN_HOUR);\n        if (inHours == null) {\n            inHours = (hours % 24 !== 0);\n        }\n        //adjust up to the hour boundary\n        expirationTime = hours * this.MILLIS_IN_HOUR;\n        const duration = expirationTime - referenceTime;\n        const unitMillis = inHours ? this.MILLIS_IN_HOUR : this.MILLIS_IN_DAY;\n        const val = Math.ceil(duration / unitMillis);\n        return inHours ? this.ofHours(val) : this.ofDays(val);\n    }\n\n}\n\nmodule.exports = TTLUtil;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}