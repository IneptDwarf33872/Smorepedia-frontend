{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst PlanIterator = require('./common').PlanIterator;\n\n/**\n * ConstIter represents a reference to a constant value in the query.\n * Such a reference will need to be \"executed\" at the driver side when\n * the constant appears in the OFFSET or LIMIT clause.\n */\nclass ConstIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n  }\n  next() {\n    if (this._done) {\n      return false;\n    }\n    this.result = this._step.val;\n    this._done = true;\n    return true;\n  }\n}\n\n/**\n * VarRefIter represents a reference to a non-external variable in the query.\n * It simply returns the value that the variable is currently bound to. This\n * value is computed by the variable's \"domain iterator\" (the iterator that\n * evaluates the domain expression of the variable). The domain iterator stores\n * the value in theResultReg of this VarRefIter.\n *\n * In the context of the driver, an implicit internal variable is used\n * to represent the results arriving from the proxy. All other expressions that\n * are computed at the driver operate on these results, so all such expressions\n * reference this variable. This is analogous to the internal variable used in\n * kvstore to represent the table alias in the FROM clause.\n */\nclass VarRefIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n  }\n\n  //the value is already stored in domain iterator registry\n}\n\n/**\n * In general, ExternalVarRefIter represents a reference to an external variable\n * in the query. Such a reference will need to be \"executed\" at the driver side\n * when the variable appears in the OFFSET or LIMIT clause.\n * ExternalVarRefIter simply returns the value that the variable is currently\n * bound to. This value is set by the app via the methods of QueryRequest.\n */\nclass ExtVarRefIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n  }\n  next() {\n    if (this._done) {\n      return false;\n    }\n    let val;\n    if (this._qpExec._extVars) {\n      val = this._qpExec._extVars[this._step.pos];\n    }\n    if (val == null) {\n      throw this.illegalArg(`Variable ${this._step.name} has not been set`);\n    }\n    this.result = val;\n    this._done = true;\n    return true;\n  }\n}\n\n/**\n * FieldStepIter returns the value of a field in an input MapValue. It is\n * used by the driver to implement column references in the SELECT\n * list (see SFWIter).\n */\nclass FieldStepIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n    this._inputIter = qpExec.makeIterator(step.input);\n    assert(this._inputIter && !this._inputIter.isAsync());\n  }\n  static validateStep(step) {\n    this._validateStepInputSync(step);\n  }\n  next() {\n    if (!this._inputIter.next()) {\n      return false;\n    }\n    const res = this._inputIter.result;\n    if (typeof res !== 'object') {\n      throw this.illegalState(`Input value in field step is not \\\nobject: ${util.inspect(res)}`);\n    }\n    if (!(this._step.fldName in res)) {\n      return false;\n    }\n    const val = res[this._step.fldName];\n    if (val === EMPTY_VALUE) {\n      return false;\n    }\n    this.result = val;\n    return true;\n  }\n  reset() {\n    this._inputIter.reset();\n  }\n}\nclass FuncSizeIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n    this._inputIter = qpExec.makeIterator(step.input);\n    assert(this._inputIter && !this._inputIter.isAsync());\n  }\n  next() {\n    if (!this._inputIter.next()) {\n      return false;\n    }\n    const res = this._inputIter.result;\n    if (res == undefined) {\n      this.result = undefined;\n    } else if (Array.isArray(res)) {\n      this.result = res.length;\n    } else if (res instanceof Map) {\n      this.result = res.size;\n    } else if (typeof res === 'object') {\n      this.result = Object.keys(res).length;\n    } else {\n      throw this.illegalState(`Input value in size step is not an \\\narray, object or map: ${util.inspect(res)}`);\n    }\n    return true;\n  }\n  reset() {\n    this._inputIter.reset();\n  }\n}\nmodule.exports = {\n  ConstIterator,\n  VarRefIterator,\n  ExtVarRefIterator,\n  FieldStepIterator,\n  FuncSizeIterator\n};","map":{"version":3,"names":["assert","require","util","EMPTY_VALUE","PlanIterator","ConstIterator","constructor","qpExec","step","next","_done","result","_step","val","VarRefIterator","ExtVarRefIterator","_qpExec","_extVars","pos","illegalArg","name","FieldStepIterator","_inputIter","makeIterator","input","isAsync","validateStep","_validateStepInputSync","res","illegalState","inspect","fldName","reset","FuncSizeIterator","undefined","Array","isArray","length","Map","size","Object","keys","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/query/value.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst PlanIterator = require('./common').PlanIterator;\n\n/**\n * ConstIter represents a reference to a constant value in the query.\n * Such a reference will need to be \"executed\" at the driver side when\n * the constant appears in the OFFSET or LIMIT clause.\n */\nclass ConstIterator extends PlanIterator {\n\n    constructor(qpExec, step) {\n        super(qpExec, step);\n    }\n\n    next() {\n        if (this._done) {\n            return false;\n        }\n        this.result = this._step.val;\n        this._done = true;\n        return true;\n    }\n\n}\n\n/**\n * VarRefIter represents a reference to a non-external variable in the query.\n * It simply returns the value that the variable is currently bound to. This\n * value is computed by the variable's \"domain iterator\" (the iterator that\n * evaluates the domain expression of the variable). The domain iterator stores\n * the value in theResultReg of this VarRefIter.\n *\n * In the context of the driver, an implicit internal variable is used\n * to represent the results arriving from the proxy. All other expressions that\n * are computed at the driver operate on these results, so all such expressions\n * reference this variable. This is analogous to the internal variable used in\n * kvstore to represent the table alias in the FROM clause.\n */\nclass VarRefIterator extends PlanIterator {\n\n    constructor(qpExec, step) {\n        super(qpExec, step);\n    }\n\n    //the value is already stored in domain iterator registry\n}\n\n/**\n * In general, ExternalVarRefIter represents a reference to an external variable\n * in the query. Such a reference will need to be \"executed\" at the driver side\n * when the variable appears in the OFFSET or LIMIT clause.\n * ExternalVarRefIter simply returns the value that the variable is currently\n * bound to. This value is set by the app via the methods of QueryRequest.\n */\nclass ExtVarRefIterator extends PlanIterator {\n\n    constructor(qpExec, step) {\n        super(qpExec, step);\n    }\n\n    next() {\n        if (this._done) {\n            return false;\n        }\n        let val;\n        if (this._qpExec._extVars) {\n            val = this._qpExec._extVars[this._step.pos];\n        }\n        if (val == null) {\n            throw this.illegalArg(\n                `Variable ${this._step.name} has not been set`);\n        }\n        this.result = val;\n        this._done = true;\n        return true;\n    }\n\n}\n\n/**\n * FieldStepIter returns the value of a field in an input MapValue. It is\n * used by the driver to implement column references in the SELECT\n * list (see SFWIter).\n */\nclass FieldStepIterator extends PlanIterator {\n\n    constructor(qpExec, step) {\n        super(qpExec, step);\n        this._inputIter = qpExec.makeIterator(step.input);\n        assert(this._inputIter && !this._inputIter.isAsync());\n    }\n\n    static validateStep(step) {\n        this._validateStepInputSync(step);\n    }\n\n    next() {\n        if (!this._inputIter.next()) {\n            return false;\n        }\n        const res = this._inputIter.result;\n        if (typeof res !== 'object') {\n            throw this.illegalState(`Input value in field step is not \\\nobject: ${util.inspect(res)}`);\n        }\n        if (!(this._step.fldName in res)) {\n            return false;\n        }\n        const val = res[this._step.fldName];\n        if (val === EMPTY_VALUE) {\n            return false;\n        }\n        this.result = val;\n        return true;\n    }\n\n    reset() {\n        this._inputIter.reset();\n    }\n\n}\n\nclass FuncSizeIterator extends PlanIterator {\n    constructor(qpExec, step) {\n        super(qpExec, step);\n        this._inputIter = qpExec.makeIterator(step.input);\n        assert(this._inputIter && !this._inputIter.isAsync());\n    }\n\n    next() {\n        if (!this._inputIter.next()) {\n            return false;\n        }\n        \n        const res = this._inputIter.result;\n        if (res == undefined) {\n            this.result = undefined;\n        } else if (Array.isArray(res)) {\n            this.result = res.length;\n        } else if (res instanceof Map) {\n            this.result = res.size;\n        } else if (typeof res === 'object') {\n            this.result = Object.keys(res).length;\n        } else {\n            throw this.illegalState(`Input value in size step is not an \\\narray, object or map: ${util.inspect(res)}`);\n        }\n\n        return true;\n    }\n\n    reset() {\n        this._inputIter.reset();\n    }\n}\n\nmodule.exports = {\n    ConstIterator,\n    VarRefIterator,\n    ExtVarRefIterator,\n    FieldStepIterator,\n    FuncSizeIterator\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAME,WAAW,GAAGF,OAAO,CAAC,cAAc,CAAC,CAACE,WAAW;AACvD,MAAMC,YAAY,GAAGH,OAAO,CAAC,UAAU,CAAC,CAACG,YAAY;;AAErD;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,SAASD,YAAY,CAAC;EAErCE,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAE;IACtB,KAAK,CAACD,MAAM,EAAEC,IAAI,CAAC;EACvB;EAEAC,IAAIA,CAAA,EAAG;IACH,IAAI,IAAI,CAACC,KAAK,EAAE;MACZ,OAAO,KAAK;IAChB;IACA,IAAI,CAACC,MAAM,GAAG,IAAI,CAACC,KAAK,CAACC,GAAG;IAC5B,IAAI,CAACH,KAAK,GAAG,IAAI;IACjB,OAAO,IAAI;EACf;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,cAAc,SAASV,YAAY,CAAC;EAEtCE,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAE;IACtB,KAAK,CAACD,MAAM,EAAEC,IAAI,CAAC;EACvB;;EAEA;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMO,iBAAiB,SAASX,YAAY,CAAC;EAEzCE,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAE;IACtB,KAAK,CAACD,MAAM,EAAEC,IAAI,CAAC;EACvB;EAEAC,IAAIA,CAAA,EAAG;IACH,IAAI,IAAI,CAACC,KAAK,EAAE;MACZ,OAAO,KAAK;IAChB;IACA,IAAIG,GAAG;IACP,IAAI,IAAI,CAACG,OAAO,CAACC,QAAQ,EAAE;MACvBJ,GAAG,GAAG,IAAI,CAACG,OAAO,CAACC,QAAQ,CAAC,IAAI,CAACL,KAAK,CAACM,GAAG,CAAC;IAC/C;IACA,IAAIL,GAAG,IAAI,IAAI,EAAE;MACb,MAAM,IAAI,CAACM,UAAU,CAChB,YAAW,IAAI,CAACP,KAAK,CAACQ,IAAK,mBAAkB,CAAC;IACvD;IACA,IAAI,CAACT,MAAM,GAAGE,GAAG;IACjB,IAAI,CAACH,KAAK,GAAG,IAAI;IACjB,OAAO,IAAI;EACf;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMW,iBAAiB,SAASjB,YAAY,CAAC;EAEzCE,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAE;IACtB,KAAK,CAACD,MAAM,EAAEC,IAAI,CAAC;IACnB,IAAI,CAACc,UAAU,GAAGf,MAAM,CAACgB,YAAY,CAACf,IAAI,CAACgB,KAAK,CAAC;IACjDxB,MAAM,CAAC,IAAI,CAACsB,UAAU,IAAI,CAAC,IAAI,CAACA,UAAU,CAACG,OAAO,CAAC,CAAC,CAAC;EACzD;EAEA,OAAOC,YAAYA,CAAClB,IAAI,EAAE;IACtB,IAAI,CAACmB,sBAAsB,CAACnB,IAAI,CAAC;EACrC;EAEAC,IAAIA,CAAA,EAAG;IACH,IAAI,CAAC,IAAI,CAACa,UAAU,CAACb,IAAI,CAAC,CAAC,EAAE;MACzB,OAAO,KAAK;IAChB;IACA,MAAMmB,GAAG,GAAG,IAAI,CAACN,UAAU,CAACX,MAAM;IAClC,IAAI,OAAOiB,GAAG,KAAK,QAAQ,EAAE;MACzB,MAAM,IAAI,CAACC,YAAY,CAAE;AACrC,UAAU3B,IAAI,CAAC4B,OAAO,CAACF,GAAG,CAAE,EAAC,CAAC;IACtB;IACA,IAAI,EAAE,IAAI,CAAChB,KAAK,CAACmB,OAAO,IAAIH,GAAG,CAAC,EAAE;MAC9B,OAAO,KAAK;IAChB;IACA,MAAMf,GAAG,GAAGe,GAAG,CAAC,IAAI,CAAChB,KAAK,CAACmB,OAAO,CAAC;IACnC,IAAIlB,GAAG,KAAKV,WAAW,EAAE;MACrB,OAAO,KAAK;IAChB;IACA,IAAI,CAACQ,MAAM,GAAGE,GAAG;IACjB,OAAO,IAAI;EACf;EAEAmB,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACV,UAAU,CAACU,KAAK,CAAC,CAAC;EAC3B;AAEJ;AAEA,MAAMC,gBAAgB,SAAS7B,YAAY,CAAC;EACxCE,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAE;IACtB,KAAK,CAACD,MAAM,EAAEC,IAAI,CAAC;IACnB,IAAI,CAACc,UAAU,GAAGf,MAAM,CAACgB,YAAY,CAACf,IAAI,CAACgB,KAAK,CAAC;IACjDxB,MAAM,CAAC,IAAI,CAACsB,UAAU,IAAI,CAAC,IAAI,CAACA,UAAU,CAACG,OAAO,CAAC,CAAC,CAAC;EACzD;EAEAhB,IAAIA,CAAA,EAAG;IACH,IAAI,CAAC,IAAI,CAACa,UAAU,CAACb,IAAI,CAAC,CAAC,EAAE;MACzB,OAAO,KAAK;IAChB;IAEA,MAAMmB,GAAG,GAAG,IAAI,CAACN,UAAU,CAACX,MAAM;IAClC,IAAIiB,GAAG,IAAIM,SAAS,EAAE;MAClB,IAAI,CAACvB,MAAM,GAAGuB,SAAS;IAC3B,CAAC,MAAM,IAAIC,KAAK,CAACC,OAAO,CAACR,GAAG,CAAC,EAAE;MAC3B,IAAI,CAACjB,MAAM,GAAGiB,GAAG,CAACS,MAAM;IAC5B,CAAC,MAAM,IAAIT,GAAG,YAAYU,GAAG,EAAE;MAC3B,IAAI,CAAC3B,MAAM,GAAGiB,GAAG,CAACW,IAAI;IAC1B,CAAC,MAAM,IAAI,OAAOX,GAAG,KAAK,QAAQ,EAAE;MAChC,IAAI,CAACjB,MAAM,GAAG6B,MAAM,CAACC,IAAI,CAACb,GAAG,CAAC,CAACS,MAAM;IACzC,CAAC,MAAM;MACH,MAAM,IAAI,CAACR,YAAY,CAAE;AACrC,wBAAwB3B,IAAI,CAAC4B,OAAO,CAACF,GAAG,CAAE,EAAC,CAAC;IACpC;IAEA,OAAO,IAAI;EACf;EAEAI,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACV,UAAU,CAACU,KAAK,CAAC,CAAC;EAC3B;AACJ;AAEAU,MAAM,CAACC,OAAO,GAAG;EACbtC,aAAa;EACbS,cAAc;EACdC,iBAAiB;EACjBM,iBAAiB;EACjBY;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}