{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst QueryOp = require('../ops').QueryOp;\nconst NoSQLError = require('../error').NoSQLError;\nconst BinaryProtocol = require('../binary_protocol/protocol');\nconst DataWriter = require('../binary_protocol/writer');\nconst PlanIterator = require('./common').PlanIterator;\nconst DistributionKind = require('./common').DistributionKind;\nconst MinHeap = require('./min_heap');\nconst compareRows = require('./compare').compareRows;\nconst resBuf2MapKey = require('./utils').resBuf2MapKey;\nconst sizeof = require('./utils').sizeof;\nconst convertEmptyToNull = require('./utils').convertEmptyToNull;\nfunction hasLocalResults(res) {\n  return res.rows && res._idx != null && res._idx < res.rows.length;\n}\nfunction compPartShardIds(res1, res2) {\n  return res1._partId != null ? res1._partId < res2._partId ? -1 : 1 : res1._shardId < res2._shardId ? -1 : 1;\n}\n\n/**\n * ReceiveIterator requests and receives results from the proxy. For sorting\n * queries, it performs a merge sort of the received results. It also\n * performs duplicate elimination for queries that require it (note:\n * a query can do both sorting and dup elimination).\n */\nclass ReceiveIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n    if (step.pkFields) {\n      this._dup = new Set();\n      this._dupMem = 0;\n      this._dw = new DataWriter();\n    }\n    if (step.sortSpecs) {\n      const cmp = this._compareRes.bind(this);\n      if (step.distKind === DistributionKind.ALL_SHARDS) {\n        const topoInfo = qpExec._baseTopo;\n        if (topoInfo == null) {\n          throw this.badProto('Missing topology information for all-shard query');\n        }\n        assert(topoInfo.shardIds && topoInfo.shardIds.length);\n        //seed empty shard results for sortingNext() loop\n        this._spRes = new MinHeap(cmp, topoInfo.shardIds.map(_shardId => ({\n          _shardId\n        })));\n      } else if (step.distKind === DistributionKind.ALL_PARTITIONS) {\n        this._spRes = new MinHeap(cmp);\n        this._allPartSort = true;\n        this._allPartSortPhase1 = true;\n        this._totalRows = 0;\n        this._totalMem = 0;\n      }\n    }\n  }\n  _compareRes(res1, res2) {\n    if (!hasLocalResults(res1)) {\n      return hasLocalResults(res2) ? -1 : compPartShardIds(res1, res2);\n    }\n    if (!hasLocalResults(res2)) {\n      return 1;\n    }\n    const compRes = compareRows(this, res1.rows[res1._idx], res2.rows[res2._idx], this._step.sortSpecs);\n    return compRes ? compRes : compPartShardIds(res1, res2);\n  }\n  _getLimitFromMem() {\n    const maxMem = this._qpExec.maxMem;\n    const memPerRow = this._totalMem / this._totalRows;\n    let limit = (maxMem - this._dupMem) / memPerRow;\n    limit = Math.min(Math.floor(limit), 2048);\n    if (limit <= 0) {\n      throw this.memoryExceeded(`Cannot make another request because \\\nset memory limit of ${this._qpExec.maxMemMB} MB will be exceeded`);\n    }\n    return limit;\n  }\n  _setMemStats(res) {\n    res._mem = sizeof(this, res.rows);\n    this._totalRows += res.rows.length;\n    this._totalMem += res._mem;\n    this._qpExec.incMem(res._mem);\n  }\n  _validatePhase1Res(res) {\n    //Check that we are really in sort phase 1\n    if (res._contAllPartSortPhase1 == null) {\n      throw this.badProto('First response to ALL_PARTITIONS query is \\\nnot a phase 1 response');\n    }\n    if (res._contAllPartSortPhase1 && !res.continuationKey) {\n      throw this.badProto('ALL_PARTITIONS query: missing continuation \\\nkey needed to continue phase 1');\n    }\n    if (!res._partIds) {\n      res._partIds = [];\n    }\n    if (!res._partIds.length) {\n      //Empty result case, do validation and return\n      if (res.rows && res.rows.length) {\n        throw this.badProto('ALL_PARTITIONS query phase 1: received \\\nrows but no partition ids');\n      }\n      if (res._numResultsPerPartId && res._numResultsPerPartId.length) {\n        throw this.badProto('ALL_PARTITIONS query phase 1: received \\\nnumResultsPerPartitionId array but no partition ids');\n      }\n    } else {\n      const numResPerPartCnt = res._numResultsPerPartId ? res._numResultsPerPartId.length : 0;\n      if (numResPerPartCnt !== res._partIds.length) {\n        throw this.badProto(`ALL_PARTITIONS query phase 1: received \\\nmismatched arrays of partitionIds of length ${res._partIds.length} and \\\nnumResultsPerPartitionId of length ${numResPerPartCnt}`);\n      }\n    }\n  }\n\n  //Group results by partition id and put them into the MinHeap\n  _addPartResults(res) {\n    let rowIdx = 0;\n    for (let i = 0; i < res._partIds.length; i++) {\n      const end = rowIdx + res._numResultsPerPartId[i];\n      if (end > res.rows.length) {\n        throw this.badProto(`ALL PARTITIONS query phase 1: exceeded \\\nrow count ${res.rows.length} while getting rows for partition id \\\n${res._partId[i]}, expected index range [${rowIdx}, ${end})`);\n      }\n      const pRes = {\n        rows: res.rows.slice(rowIdx, end),\n        continuationKey: res._partContKeys[i],\n        _partId: res._partIds[i],\n        _idx: 0\n      };\n      this._spRes.add(pRes);\n      this._setMemStats(pRes);\n      rowIdx = end;\n    }\n    if (rowIdx !== res.rows.length) {\n      throw this.badProto(`ALL PARTITIONS query phase 1: received per \\\npartition row counts (total ${rowIdx}) did not match total row count \\\n${res.rows.length}`);\n    }\n  }\n\n  //We have to convert PKs to string because JS Map and Set only do value\n  //comparison for primitives, objects (etc. Buffer) are compared by\n  //reference only\n  _pk2MapKey(row) {\n    this._dw.reset();\n    for (let fldName of this._step.pkFields) {\n      BinaryProtocol.writeFieldValue(this._dw, row[fldName], this._qpExec.opt);\n    }\n    return resBuf2MapKey(this._dw.buffer);\n  }\n  _chkDup(row) {\n    let key = this._pk2MapKey(row);\n    if (this._dup.has(key)) {\n      return true;\n    }\n    this._dup.add(key);\n    const size = sizeof(this, key);\n    this._dupMem += size;\n    this._qpExec.incMem(size);\n    return false;\n  }\n  _handleVirtualScans(vScans) {\n    if (this._currVSID == null) {\n      const topoInfo = this._qpExec._baseTopo;\n      assert(topoInfo && topoInfo.shardIds && topoInfo.shardIds.length);\n      //shardIds are sorted\n      this._currVSID = topoInfo.shardIds[topoInfo.shardIds.length - 1] + 1;\n    }\n    for (const vs of vScans) {\n      this._spRes.add({\n        _shardId: this._currVSID++,\n        _vScan: vs\n      });\n    }\n  }\n  async _fetch(ck, shardId, limit, vScan) {\n    assert(this._qpExec._req);\n    const opt = this._qpExec._req.opt;\n    const req = {\n      api: this._qpExec._client.query,\n      prepStmt: this._qpExec._prepStmt,\n      opt: Object.assign({}, opt),\n      _queryInternal: true,\n      _topoInfo: this._qpExec._baseTopo,\n      _shardId: shardId\n    };\n    if (vScan != null) {\n      req._vScan = vScan;\n    }\n    if (opt.traceLevel > 0) {\n      req._batchCounter = this._qpExec._batchNum;\n    }\n    req.opt.continuationKey = ck;\n    if (limit) {\n      req.opt.limit = opt.limit ? Math.min(opt.limit, limit) : limit;\n    }\n    const res = await this._qpExec._client._execute(QueryOp, req);\n    assert(Array.isArray(res.rows));\n    //Virtual scans can only be sent for ALL_SHARDS query.\n    if (res._vScans != null && this._step.distKind !== DistributionKind.ALL_SHARDS) {\n      throw this.badProto(`Received virtual scans for non-shard query \\\ntype: ${this._step.distKind}`);\n    }\n    res._idx = 0; //initialize index to iterate\n    res._shardId = shardId; //set shard id if any\n\n    //We only make one internal request per user's query() call,\n    //so the same consumed capacity will be returned to the user\n    this._qpExec._cc = res.consumedCapacity;\n    this._qpExec._fetchDone = true;\n    assert(res._reachedLimit || !res.continuationKey || this._allPartSortPhase1);\n    if (res.queryTraces) {\n      this._qpExec.addTraces(res.queryTraces);\n    }\n    return res;\n  }\n\n  //Returns true if phase 1 is completed\n  async _doAllPartSortPhase1() {\n    //have to postpone phase 1 to the next query() call\n    if (this._qpExec._fetchDone) {\n      assert(this._qpExec._needUserCont);\n      return false;\n    }\n\n    /*\n     * Create and execute a request to get at least one result from\n     * the partition whose id is specified in theContinuationKey and\n     * from any other partition that is co-located with that partition.\n     */\n    const res = await this._fetch(this._allPartSortPhase1CK);\n    this._validatePhase1Res(res);\n    this._allPartSortPhase1 = res._contAllPartSortPhase1;\n    this._allPartSortPhase1CK = res.continuationKey;\n    this._addPartResults(res);\n    if (this._allPartSortPhase1) {\n      //need more phase 1 results\n      this._qpExec._needUserCont = true;\n      return false;\n    }\n    return true;\n  }\n  async _simpleNext() {\n    for (;;) {\n      const res = this._res;\n      if (res) {\n        assert(res.rows && res._idx != null);\n        if (res._idx < res.rows.length) {\n          const row = res.rows[res._idx++];\n          if (this._dup && this._chkDup(row)) {\n            continue;\n          }\n          this.result = row;\n          return true;\n        }\n        if (!res.continuationKey) {\n          return false;\n        }\n      }\n      if (this._qpExec._fetchDone) {\n        break;\n      }\n      this._res = await this._fetch(res ? res.continuationKey : null);\n    }\n    assert(this._res);\n    if (this._res.continuationKey) {\n      this._qpExec._needUserCont = true;\n    }\n    return false;\n  }\n  async _sortingFetch(fromRes) {\n    let limit;\n    if (this._allPartSort) {\n      //We only limit number of rows for ALL_PARTITIONS query\n      limit = this._getLimitFromMem();\n      //For ALL_PARTITIONS query, decrement memory from previous result\n      this._qpExec.decMem(fromRes._mem);\n    }\n    let res;\n    try {\n      res = await this._fetch(fromRes.continuationKey, fromRes._shardId, limit, fromRes._vScan);\n    } catch (err) {\n      if (err instanceof NoSQLError && err.retryable) {\n        //add original result to retry later\n        this._spRes.add(fromRes);\n      }\n      throw err;\n    }\n    this._spRes.add(res);\n    if (this._allPartSort) {\n      this._setMemStats(res);\n    } else {\n      if (fromRes._vScan != null) {\n        fromRes._vScan.isInfoSent = true;\n      }\n      if (res._vScans != null) {\n        this._handleVirtualScans(res._vScans);\n        res._vScans = undefined;\n      }\n    }\n  }\n  _localNext(res) {\n    const row = res.rows[res._idx];\n    res.rows[res._idx++] = null; //release memory for the row\n    //more cached results or more remote results\n    if (res._idx < res.rows.length || res.continuationKey) {\n      this._spRes.add(res);\n    }\n    if (this._dup && this._chkDup(row)) {\n      return false;\n    }\n    convertEmptyToNull(row);\n    this.result = row;\n    return true;\n  }\n  async _sortingNext() {\n    if (this._allPartSortPhase1 && !(await this._doAllPartSortPhase1())) {\n      return false;\n    }\n    let res;\n    while (res = this._spRes.pop()) {\n      if (res.rows) {\n        //we have real result\n        assert(res._idx != null);\n        if (res._idx < res.rows.length) {\n          if (this._localNext(res)) {\n            return true;\n          }\n          continue;\n        }\n        if (!res.continuationKey) {\n          //no more results for this shard or partition\n          continue;\n        }\n      }\n      //remote fetch is needed\n      if (this._qpExec._fetchDone) {\n        //We limit to 1 fetch per query() call\n        break;\n      } else {\n        await this._sortingFetch(res);\n      }\n    }\n    if (res) {\n      //another fetch needs to be performed on next query() call\n      if (res.rows) {\n        assert(res.continuationKey);\n        //optimization to release array memory before next\n        //query() call\n        res.rows = null;\n      }\n      this._spRes.add(res);\n      this._qpExec._needUserCont = true;\n    }\n    return false;\n  }\n  next() {\n    return this._spRes ? this._sortingNext() : this._simpleNext();\n  }\n\n  //should not be called\n  reset() {\n    throw this.illegalState('Reset should not be called for ReceiveIterator');\n  }\n}\nReceiveIterator._isAsync = true;\nmodule.exports = ReceiveIterator;","map":{"version":3,"names":["assert","require","QueryOp","NoSQLError","BinaryProtocol","DataWriter","PlanIterator","DistributionKind","MinHeap","compareRows","resBuf2MapKey","sizeof","convertEmptyToNull","hasLocalResults","res","rows","_idx","length","compPartShardIds","res1","res2","_partId","_shardId","ReceiveIterator","constructor","qpExec","step","pkFields","_dup","Set","_dupMem","_dw","sortSpecs","cmp","_compareRes","bind","distKind","ALL_SHARDS","topoInfo","_baseTopo","badProto","shardIds","_spRes","map","ALL_PARTITIONS","_allPartSort","_allPartSortPhase1","_totalRows","_totalMem","compRes","_step","_getLimitFromMem","maxMem","_qpExec","memPerRow","limit","Math","min","floor","memoryExceeded","maxMemMB","_setMemStats","_mem","incMem","_validatePhase1Res","_contAllPartSortPhase1","continuationKey","_partIds","_numResultsPerPartId","numResPerPartCnt","_addPartResults","rowIdx","i","end","pRes","slice","_partContKeys","add","_pk2MapKey","row","reset","fldName","writeFieldValue","opt","buffer","_chkDup","key","has","size","_handleVirtualScans","vScans","_currVSID","vs","_vScan","_fetch","ck","shardId","vScan","_req","req","api","_client","query","prepStmt","_prepStmt","Object","assign","_queryInternal","_topoInfo","traceLevel","_batchCounter","_batchNum","_execute","Array","isArray","_vScans","_cc","consumedCapacity","_fetchDone","_reachedLimit","queryTraces","addTraces","_doAllPartSortPhase1","_needUserCont","_allPartSortPhase1CK","_simpleNext","_res","result","_sortingFetch","fromRes","decMem","err","retryable","isInfoSent","undefined","_localNext","_sortingNext","pop","next","illegalState","_isAsync","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/query/receive.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst QueryOp = require('../ops').QueryOp;\nconst NoSQLError = require('../error').NoSQLError;\nconst BinaryProtocol = require('../binary_protocol/protocol');\nconst DataWriter = require('../binary_protocol/writer');\nconst PlanIterator = require('./common').PlanIterator;\nconst DistributionKind = require('./common').DistributionKind;\nconst MinHeap = require('./min_heap');\nconst compareRows = require('./compare').compareRows;\nconst resBuf2MapKey = require('./utils').resBuf2MapKey;\nconst sizeof = require('./utils').sizeof;\nconst convertEmptyToNull = require('./utils').convertEmptyToNull;\n\nfunction hasLocalResults(res) {\n    return res.rows && res._idx != null && res._idx < res.rows.length;\n}\n\nfunction compPartShardIds(res1, res2) {\n    return res1._partId != null ?\n        (res1._partId < res2._partId ? -1 : 1) :\n        (res1._shardId < res2._shardId ? -1 : 1);\n}\n\n/**\n * ReceiveIterator requests and receives results from the proxy. For sorting\n * queries, it performs a merge sort of the received results. It also\n * performs duplicate elimination for queries that require it (note:\n * a query can do both sorting and dup elimination).\n */\nclass ReceiveIterator extends PlanIterator {\n    \n    constructor(qpExec, step) {\n        super(qpExec, step);\n        if (step.pkFields) {\n            this._dup = new Set();\n            this._dupMem = 0;\n            this._dw = new DataWriter();\n        }\n        if (step.sortSpecs) {\n            const cmp = this._compareRes.bind(this);\n            if (step.distKind === DistributionKind.ALL_SHARDS) {\n                const topoInfo = qpExec._baseTopo;\n                if (topoInfo == null) {\n                    throw this.badProto(\n                        'Missing topology information for all-shard query');\n                }\n                assert(topoInfo.shardIds && topoInfo.shardIds.length);\n                //seed empty shard results for sortingNext() loop\n                this._spRes = new MinHeap(cmp, topoInfo.shardIds.map(\n                    _shardId => ({ _shardId })));\n            } else if (step.distKind === DistributionKind.ALL_PARTITIONS) {\n                this._spRes = new MinHeap(cmp);\n                this._allPartSort = true;\n                this._allPartSortPhase1 = true;\n                this._totalRows = 0;\n                this._totalMem = 0;\n            }\n        }\n    }\n\n    _compareRes(res1, res2) {\n        if (!hasLocalResults(res1)) {\n            return hasLocalResults(res2) ? -1 :\n                compPartShardIds(res1, res2);\n        }\n        if (!hasLocalResults(res2)) {\n            return 1;\n        }\n        const compRes = compareRows(this, res1.rows[res1._idx],\n            res2.rows[res2._idx], this._step.sortSpecs);\n        return compRes ? compRes : compPartShardIds(res1, res2);\n    }\n\n    _getLimitFromMem() {\n        const maxMem = this._qpExec.maxMem;\n        const memPerRow = this._totalMem / this._totalRows;\n        let limit = (maxMem - this._dupMem) / memPerRow;\n        limit = Math.min(Math.floor(limit), 2048);\n        if (limit <= 0) {\n            throw this.memoryExceeded(`Cannot make another request because \\\nset memory limit of ${this._qpExec.maxMemMB} MB will be exceeded`);\n        }\n        return limit;\n    }\n\n    _setMemStats(res) {\n        res._mem = sizeof(this, res.rows);\n        this._totalRows += res.rows.length;\n        this._totalMem += res._mem;\n        this._qpExec.incMem(res._mem);\n    }\n\n    _validatePhase1Res(res) {\n        //Check that we are really in sort phase 1\n        if (res._contAllPartSortPhase1 == null) {\n            throw this.badProto('First response to ALL_PARTITIONS query is \\\nnot a phase 1 response');\n        }\n        if (res._contAllPartSortPhase1 && !res.continuationKey) {\n            throw this.badProto('ALL_PARTITIONS query: missing continuation \\\nkey needed to continue phase 1');\n        }\n\n        if (!res._partIds) {\n            res._partIds = [];\n        }\n        if (!res._partIds.length) {\n            //Empty result case, do validation and return\n            if (res.rows && res.rows.length) {\n                throw this.badProto('ALL_PARTITIONS query phase 1: received \\\nrows but no partition ids');\n            }\n            if (res._numResultsPerPartId && res._numResultsPerPartId.length) {\n                throw this.badProto('ALL_PARTITIONS query phase 1: received \\\nnumResultsPerPartitionId array but no partition ids');\n            }\n        } else {\n            const numResPerPartCnt = res._numResultsPerPartId ?\n                res._numResultsPerPartId.length : 0;\n            if (numResPerPartCnt !== res._partIds.length) {\n                throw this.badProto(`ALL_PARTITIONS query phase 1: received \\\nmismatched arrays of partitionIds of length ${res._partIds.length} and \\\nnumResultsPerPartitionId of length ${numResPerPartCnt}`);\n            }\n        }\n    }\n\n    //Group results by partition id and put them into the MinHeap\n    _addPartResults(res) {\n        let rowIdx = 0;\n        for(let i = 0; i < res._partIds.length; i++) {\n            const end = rowIdx + res._numResultsPerPartId[i];\n            if (end > res.rows.length) {\n                throw this.badProto(`ALL PARTITIONS query phase 1: exceeded \\\nrow count ${res.rows.length} while getting rows for partition id \\\n${res._partId[i]}, expected index range [${rowIdx}, ${end})`);\n            }\n            const pRes = {\n                rows: res.rows.slice(rowIdx, end),\n                continuationKey: res._partContKeys[i],\n                _partId: res._partIds[i],\n                _idx: 0\n            };\n            this._spRes.add(pRes);\n            this._setMemStats(pRes);\n            rowIdx = end;\n        }\n        if (rowIdx !== res.rows.length) {\n            throw this.badProto(`ALL PARTITIONS query phase 1: received per \\\npartition row counts (total ${rowIdx}) did not match total row count \\\n${res.rows.length}`);\n        }\n    }\n\n    //We have to convert PKs to string because JS Map and Set only do value\n    //comparison for primitives, objects (etc. Buffer) are compared by\n    //reference only\n    _pk2MapKey(row) {\n        this._dw.reset();\n        for(let fldName of this._step.pkFields) {\n            BinaryProtocol.writeFieldValue(this._dw, row[fldName],\n                this._qpExec.opt);\n        }\n        return resBuf2MapKey(this._dw.buffer);\n    }\n    \n    _chkDup(row) {\n        let key = this._pk2MapKey(row);\n        if (this._dup.has(key)) {\n            return true;\n        }\n        this._dup.add(key);\n        const size = sizeof(this, key);\n        this._dupMem += size;\n        this._qpExec.incMem(size);\n        return false;\n    }\n\n    _handleVirtualScans(vScans) {\n        if (this._currVSID == null) {\n            const topoInfo = this._qpExec._baseTopo;\n            assert(topoInfo && topoInfo.shardIds && topoInfo.shardIds.length);\n            //shardIds are sorted\n            this._currVSID =\n                topoInfo.shardIds[topoInfo.shardIds.length - 1] + 1;\n        }\n\n        for(const vs of vScans) {\n            this._spRes.add({\n                _shardId: this._currVSID++,\n                _vScan: vs\n            });\n        }\n    }\n\n    async _fetch(ck, shardId, limit, vScan) {\n        assert(this._qpExec._req);\n        const opt = this._qpExec._req.opt;\n        \n        const req = {\n            api: this._qpExec._client.query,\n            prepStmt: this._qpExec._prepStmt,\n            opt: Object.assign({}, opt),\n            _queryInternal: true,\n            _topoInfo: this._qpExec._baseTopo,\n            _shardId: shardId\n        };\n        if (vScan != null) {\n            req._vScan = vScan;\n        }\n        if (opt.traceLevel > 0) {\n            req._batchCounter = this._qpExec._batchNum;\n        }\n\n        req.opt.continuationKey = ck;\n        if (limit) {\n            req.opt.limit = opt.limit ? Math.min(opt.limit, limit) : limit;\n        }\n\n        const res = await this._qpExec._client._execute(QueryOp, req);\n        \n        assert(Array.isArray(res.rows));\n        //Virtual scans can only be sent for ALL_SHARDS query.\n        if (res._vScans != null &&\n            this._step.distKind !== DistributionKind.ALL_SHARDS) {\n            throw this.badProto(`Received virtual scans for non-shard query \\\ntype: ${this._step.distKind}`);\n        }\n\n        res._idx = 0; //initialize index to iterate\n        res._shardId = shardId; //set shard id if any\n\n        //We only make one internal request per user's query() call,\n        //so the same consumed capacity will be returned to the user\n        this._qpExec._cc = res.consumedCapacity;\n        this._qpExec._fetchDone = true;\n\n        assert(res._reachedLimit || !res.continuationKey ||\n            this._allPartSortPhase1);\n\n        if (res.queryTraces) {\n            this._qpExec.addTraces(res.queryTraces);\n        }\n\n        return res;\n    }\n\n    //Returns true if phase 1 is completed\n    async _doAllPartSortPhase1() {\n        //have to postpone phase 1 to the next query() call\n        if (this._qpExec._fetchDone) {\n            assert(this._qpExec._needUserCont);\n            return false;\n        }\n\n        /*\n         * Create and execute a request to get at least one result from\n         * the partition whose id is specified in theContinuationKey and\n         * from any other partition that is co-located with that partition.\n         */\n        const res = await this._fetch(this._allPartSortPhase1CK);\n        this._validatePhase1Res(res);\n        this._allPartSortPhase1 = res._contAllPartSortPhase1;\n        this._allPartSortPhase1CK = res.continuationKey;\n        this._addPartResults(res);\n\n        if (this._allPartSortPhase1) { //need more phase 1 results\n            this._qpExec._needUserCont = true;\n            return false;\n        }\n\n        return true;\n    }\n\n    async _simpleNext() {\n        for(;;) {\n            const res = this._res;\n            if (res) {\n                assert(res.rows && res._idx != null);\n                if (res._idx < res.rows.length) {\n                    const row = res.rows[res._idx++];\n                    if (this._dup && this._chkDup(row)) {\n                        continue;\n                    }\n                    this.result = row;\n                    return true;\n                }\n                if (!res.continuationKey) {\n                    return false;\n                }\n            }\n            if (this._qpExec._fetchDone) {\n                break;\n            }\n            this._res = await this._fetch(res ? res.continuationKey : null);\n        }\n        assert(this._res);\n        if (this._res.continuationKey) {\n            this._qpExec._needUserCont = true;\n        }\n        return false;\n    }\n\n    async _sortingFetch(fromRes) {\n        let limit;\n        if (this._allPartSort) {\n            //We only limit number of rows for ALL_PARTITIONS query\n            limit = this._getLimitFromMem();\n            //For ALL_PARTITIONS query, decrement memory from previous result\n            this._qpExec.decMem(fromRes._mem);\n        }\n        let res;\n        try {\n            res = await this._fetch(fromRes.continuationKey, fromRes._shardId,\n                limit, fromRes._vScan);\n        } catch(err) {\n            if ((err instanceof NoSQLError) && err.retryable) {\n                //add original result to retry later\n                this._spRes.add(fromRes);\n            }\n            throw err;\n        }\n        this._spRes.add(res);\n        if (this._allPartSort) {\n            this._setMemStats(res);\n        } else {\n            if (fromRes._vScan != null) {\n                fromRes._vScan.isInfoSent = true;\n            }\n\n            if (res._vScans != null) {\n                this._handleVirtualScans(res._vScans);\n                res._vScans = undefined;\n            }\n        }\n    }\n\n    _localNext(res) {\n        const row = res.rows[res._idx];\n        res.rows[res._idx++] = null; //release memory for the row\n        //more cached results or more remote results\n        if (res._idx < res.rows.length || res.continuationKey) {\n            this._spRes.add(res);\n        }\n        if (this._dup && this._chkDup(row)) {\n            return false;\n        }\n        convertEmptyToNull(row);\n        this.result = row;\n        return true;\n    }\n\n    async _sortingNext() {\n        if (this._allPartSortPhase1 &&\n            !(await this._doAllPartSortPhase1())) {\n            return false;\n        }\n\n        let res;\n        while ((res = this._spRes.pop())) {\n            if (res.rows) { //we have real result\n                assert(res._idx != null);\n                if (res._idx < res.rows.length) {\n                    if (this._localNext(res)) {\n                        return true;\n                    }\n                    continue;\n                }\n                if (!res.continuationKey) {\n                    //no more results for this shard or partition\n                    continue;\n                }\n            }\n            //remote fetch is needed\n            if (this._qpExec._fetchDone) {\n                //We limit to 1 fetch per query() call\n                break;\n            } else {\n                await this._sortingFetch(res);\n            }\n        }\n        if (res) {\n            //another fetch needs to be performed on next query() call\n            if (res.rows) {\n                assert(res.continuationKey);\n                //optimization to release array memory before next\n                //query() call\n                res.rows = null;\n            }\n            this._spRes.add(res);\n            this._qpExec._needUserCont = true;\n        }\n        return false;\n    }\n\n    next() {\n        return this._spRes ? this._sortingNext() : this._simpleNext();\n    }\n\n    //should not be called\n    reset() {\n        throw this.illegalState(\n            'Reset should not be called for ReceiveIterator');\n    }\n\n}\n\nReceiveIterator._isAsync = true;\n\nmodule.exports = ReceiveIterator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}