{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst PackedInteger = require('./packed_integer');\nconst ResizableBuffer = require('./buffer');\n\n/**\n * Utility classes to facilitate serialization/deserialization\n *\n * The numeric methods use packed_integer module which uses a format\n * that is always sorted.\n */\n\nclass DataWriter {\n  constructor(buf) {\n    this._buf = buf instanceof ResizableBuffer ? buf : new ResizableBuffer(buf);\n  }\n  get buffer() {\n    return this._buf;\n  }\n  writeByte(value) {\n    this._buf.writeUInt8(value, this._buf.length);\n  }\n\n  /**\n   * Writes a packed integer to the buffer\n   *\n   * @param value the integer to be written\n   */\n  writeInt(value) {\n    this._buf.ensureExtraCapacity(PackedInteger.MAX_LENGTH);\n    this._buf.length = PackedInteger.writeSortedInt(this._buf.buffer, this._buf.length, value);\n  }\n\n  /**\n   * Writes a packed long to the buffer\n   *\n   * @param value the long to be written\n   */\n  writeLong(value) {\n    this._buf.ensureExtraCapacity(PackedInteger.MAX_LONG_LENGTH);\n    this._buf.length = PackedInteger.writeSortedLong(this._buf.buffer, this._buf.length, value);\n  }\n\n  /**\n   * Writes a string for reading by {@link #readString}, using standard UTF-8\n   * format. The string may be null or empty.  This code differentiates\n   * between the two, maintaining the ability to round-trip null and empty\n   * string values.\n   *\n   * The format is the standard UTF-8 format documented by <a\n   * href=\"http://www.ietf.org/rfc/rfc2279.txt\">RFC 2279</a>.\n   *\n   * <p>Format:\n   * <ol>\n   * <li> ({@link #writePackedInt packed int}) <i>string length, or -1\n   * for null</i>\n   * <li> <i>[Optional]</i> ({@code byte[]}) <i>UTF-8 bytes</i>\n   * </ol>\n   *\n   * @param value the string or null\n   */\n  writeString(value) {\n    if (value == null) {\n      //null or undefined\n      return this.writeInt(-1);\n    }\n    assert(typeof value === 'string');\n    const b = Buffer.from(value, 'utf8');\n    this.writeInt(b.length);\n    if (b.length > 0) {\n      this._buf.appendBuffer(b);\n    }\n  }\n\n  /**\n   * Writes a possibly null binary as a {@link #writePackedInt\n   * sequence length} followed by the array contents.\n   *\n   * @param array the byte array or null\n   */\n  writeBinary(value) {\n    const len = value == null ? -1 : value.length;\n    this.writeInt(len);\n    if (len > 0) {\n      this._buf.appendBuffer(value);\n    }\n  }\n\n  //Equivalent to writeByteArrayWithInt() in BinaryProtocol.java\n  writeBinary2(value) {\n    const len = value ? value.length : 0;\n    this.writeInt32BE(len);\n    if (len > 0) {\n      this._buf.appendBuffer(value);\n    }\n  }\n  writeBoolean(value) {\n    this.writeByte(value ? 1 : 0);\n  }\n  writeDouble(value) {\n    this._buf.ensureExtraCapacity(8);\n    this._buf.length = this._buf.buffer.writeDoubleBE(value, this._buf.length);\n  }\n  writeDate(value) {\n    assert(value instanceof Date);\n    let s = value.toISOString();\n    this.writeString(s);\n  }\n  writeInt16BE(value) {\n    this._buf.writeInt16BE(value, this._buf.length);\n  }\n  writeInt32BE(value) {\n    this._buf.writeInt32BE(value, this._buf.length);\n  }\n  reset() {\n    this._buf.length = 0;\n    return this;\n  }\n  toString(encoding = 'utf8') {\n    return this._buf.toString(encoding);\n  }\n}\nmodule.exports = DataWriter;","map":{"version":3,"names":["assert","require","PackedInteger","ResizableBuffer","DataWriter","constructor","buf","_buf","buffer","writeByte","value","writeUInt8","length","writeInt","ensureExtraCapacity","MAX_LENGTH","writeSortedInt","writeLong","MAX_LONG_LENGTH","writeSortedLong","writeString","b","Buffer","from","appendBuffer","writeBinary","len","writeBinary2","writeInt32BE","writeBoolean","writeDouble","writeDoubleBE","writeDate","Date","s","toISOString","writeInt16BE","reset","toString","encoding","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/binary_protocol/writer.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst PackedInteger = require('./packed_integer');\nconst ResizableBuffer = require('./buffer');\n\n/**\n * Utility classes to facilitate serialization/deserialization\n *\n * The numeric methods use packed_integer module which uses a format\n * that is always sorted.\n */\n\nclass DataWriter {\n    constructor(buf) {\n        this._buf = (buf instanceof ResizableBuffer) ? buf :\n            new ResizableBuffer(buf);\n    }\n\n    get buffer() {\n        return this._buf;\n    }\n\n    writeByte(value) {\n        this._buf.writeUInt8(value, this._buf.length);\n    }\n\n    /**\n     * Writes a packed integer to the buffer\n     *\n     * @param value the integer to be written\n     */\n    writeInt(value) {\n        this._buf.ensureExtraCapacity(PackedInteger.MAX_LENGTH);\n        this._buf.length = PackedInteger.writeSortedInt(this._buf.buffer,\n            this._buf.length, value);\n    }\n\n    /**\n     * Writes a packed long to the buffer\n     *\n     * @param value the long to be written\n     */\n    writeLong(value) {\n        this._buf.ensureExtraCapacity(PackedInteger.MAX_LONG_LENGTH);\n        this._buf.length = PackedInteger.writeSortedLong(this._buf.buffer,\n            this._buf.length, value);\n    }\n\n    /**\n     * Writes a string for reading by {@link #readString}, using standard UTF-8\n     * format. The string may be null or empty.  This code differentiates\n     * between the two, maintaining the ability to round-trip null and empty\n     * string values.\n     *\n     * The format is the standard UTF-8 format documented by <a\n     * href=\"http://www.ietf.org/rfc/rfc2279.txt\">RFC 2279</a>.\n     *\n     * <p>Format:\n     * <ol>\n     * <li> ({@link #writePackedInt packed int}) <i>string length, or -1\n     * for null</i>\n     * <li> <i>[Optional]</i> ({@code byte[]}) <i>UTF-8 bytes</i>\n     * </ol>\n     *\n     * @param value the string or null\n     */\n    writeString(value) {\n        if (value == null) { //null or undefined\n            return this.writeInt(-1);\n        }\n        assert(typeof value === 'string');\n        const b = Buffer.from(value, 'utf8');\n        this.writeInt(b.length);\n        if (b.length > 0) {\n            this._buf.appendBuffer(b);\n        }\n    }\n\n    /**\n     * Writes a possibly null binary as a {@link #writePackedInt\n     * sequence length} followed by the array contents.\n     *\n     * @param array the byte array or null\n     */\n    writeBinary(value) {\n        const len = (value == null) ? -1 : value.length;\n        this.writeInt(len);\n        if (len > 0) {\n            this._buf.appendBuffer(value);\n        }\n    }\n\n    //Equivalent to writeByteArrayWithInt() in BinaryProtocol.java\n    writeBinary2(value) {\n        const len = value ? value.length : 0;\n        this.writeInt32BE(len);\n        if (len > 0) {\n            this._buf.appendBuffer(value);\n        }\n    }\n\n    writeBoolean(value) {\n        this.writeByte(value ? 1 : 0);\n    }\n\n    writeDouble(value) {\n        this._buf.ensureExtraCapacity(8);\n        this._buf.length = this._buf.buffer.writeDoubleBE(value,\n            this._buf.length);\n    }\n\n    writeDate(value) {\n        assert(value instanceof Date);\n        let s = value.toISOString();\n        this.writeString(s);\n    }\n\n    writeInt16BE(value) {\n        this._buf.writeInt16BE(value, this._buf.length);\n    }\n\n    writeInt32BE(value) {\n        this._buf.writeInt32BE(value, this._buf.length);\n    }\n\n    reset() {\n        this._buf.length = 0;\n        return this;    \n    }\n\n    toString(encoding = 'utf8') {\n        return this._buf.toString(encoding);\n    }\n}\n\nmodule.exports = DataWriter;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}