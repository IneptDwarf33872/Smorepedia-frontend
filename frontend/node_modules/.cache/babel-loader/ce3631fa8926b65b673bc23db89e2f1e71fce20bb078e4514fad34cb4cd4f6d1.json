{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\nconst assert = require('assert');\nconst fsPromises = require('fs').promises;\nconst isPosInt32 = require('../../utils').isPosInt32;\nconst HttpConstants = require('../../constants').HttpConstants;\nconst ErrorCode = require('../../error_code');\nconst NoSQLArgumentError = require('../../error').NoSQLArgumentError;\nconst AuthError = require('../../error').NoSQLAuthorizationError;\nconst Utils = require('./utils');\nconst IAMProfileProvider = require('./profile').IAMProfileProvider;\nconst UserProfileProvider = require('./profile').UserProfileProvider;\nconst OCIConfigFileProvider = require('./profile').OCIConfigFileProvider;\nconst SessTokenProfileProvider = require('./profile').SessTokenProfileProvider;\nconst ResourcePrincipalProvider = require('./resource_principal');\nconst InstancePrincipalProvider = require('./instance_principal');\nlet Config;\n\n/* Maximum lifetime of signature 300 seconds */\nconst MAX_ENTRY_LIFE_TIME = 300;\nconst DATE_HEADER = Utils.isInBrowser ? HttpConstants.X_DATE : HttpConstants.DATE;\nconst SIGNING_HEADERS = \"(request-target) host \".concat(DATE_HEADER);\nconst OBO_TOKEN_HEADER = 'opc-obo-token';\nconst CONTENT_HEADERS = 'content-length content-type x-content-sha256';\nconst PROFILE_PROPS = ['tenantId', 'userId', 'fingerprint', 'privateKey', 'privateKeyFile', 'passphrase'];\nconst OCI_CONFIG_PROPS = ['configFile', 'profileName'];\nconst CREDS_PROVIDER_PROP = 'credentialsProvider';\nconst INST_PRINCIPAL_PROP = 'useInstancePrincipal';\nconst IP_EXTRA_PROPS = ['federationEndpoint', 'delegationToken', 'delegationTokenProvider', 'delegationTokenFile'];\nconst RES_PRINCIPAL_PROP = 'useResourcePrincipal';\nconst RP_EXTRA_PROPS = ['useResourcePrincipalCompartment'];\nconst SESS_TOKEN_PROP = 'useSessionToken';\nconst USER_IDEN_PROPS = [...PROFILE_PROPS, ...OCI_CONFIG_PROPS, CREDS_PROVIDER_PROP];\nfunction _findProps(opt, props, truthyProps) {\n  let val;\n  if (props) {\n    val = props.find(item => opt[item] != null);\n  }\n  if (!val && truthyProps) {\n    val = truthyProps.find(item => opt[item]);\n  }\n  return val;\n}\nfunction _chkExclProps(cfg, opt, prop, props, truthyProps) {\n  const val = _findProps(opt, props, truthyProps);\n  if (!val) {\n    return;\n  }\n  if (Array.isArray(prop)) {\n    prop = 'any of ' + prop.join(', ');\n  }\n  throw new NoSQLArgumentError(\"Cannot specify property \".concat(val, \" together with \").concat(prop), cfg);\n}\nclass IAMAuthorizationProvider {\n  constructor(opt, cfg) {\n    if (opt == null) {\n      //Possible if using default OCI config file with default profile.\n      opt = {};\n    } else if (typeof opt !== 'object') {\n      throw new NoSQLArgumentError('Invalid IAMConfig object', cfg);\n    }\n\n    //Needed in case this provider is created outside NoSQLClient\n    //instance. Note that this is currently sufficient, because\n    //AuthConfig.defaults.iam has no nested properties. Otherwise the code\n    //below will need to change to use Config.inheritOpt().\n    opt.__proto__ = IAMAuthorizationProvider.configDefaults;\n    if (opt.durationSeconds == null) {\n      this._duration = MAX_ENTRY_LIFE_TIME;\n    } else {\n      if (!isPosInt32(opt.durationSeconds)) {\n        throw new NoSQLArgumentError('Invalid auth.iam.durationSeconds value', cfg);\n      }\n      if (opt.durationSeconds > MAX_ENTRY_LIFE_TIME) {\n        throw new NoSQLArgumentError(\"Signature cannot be cached for more than \".concat(MAX_ENTRY_LIFE_TIME, \" seconds\"), cfg);\n      }\n      this._duration = opt.durationSeconds;\n    }\n    this._duration *= 1000;\n    if (opt.refreshAheadMs != null) {\n      if (!isPosInt32(opt.refreshAheadMs)) {\n        throw new NoSQLArgumentError('Invalid auth.iam.refreshAheadMs value', cfg);\n      }\n      if (this._duration > opt.refreshAheadMs) {\n        this._refreshInterval = this._duration - opt.refreshAheadMs;\n      }\n    }\n    let prop;\n\n    //init authentication details provider\n    if (opt.useResourcePrincipal) {\n      _chkExclProps(cfg, opt, RES_PRINCIPAL_PROP, USER_IDEN_PROPS, [INST_PRINCIPAL_PROP, SESS_TOKEN_PROP]);\n      this._provider = new ResourcePrincipalProvider(opt, cfg);\n    } else if ((prop = _findProps(opt, null, RP_EXTRA_PROPS)) != null) {\n      throw new NoSQLArgumentError(\"Cannot specify property \".concat(prop, \" without \").concat(RES_PRINCIPAL_PROP), cfg);\n    } else if (opt.useInstancePrincipal) {\n      _chkExclProps(cfg, opt, INST_PRINCIPAL_PROP, USER_IDEN_PROPS, [SESS_TOKEN_PROP]);\n      this._provider = new InstancePrincipalProvider(opt, cfg);\n    } else if ((prop = _findProps(opt, IP_EXTRA_PROPS)) != null) {\n      throw new NoSQLArgumentError(\"Cannot specify property \".concat(prop, \" without \").concat(INST_PRINCIPAL_PROP), cfg);\n    } else if (opt.useSessionToken) {\n      _chkExclProps(cfg, opt, SESS_TOKEN_PROP, [...PROFILE_PROPS, CREDS_PROVIDER_PROP]);\n      this._provider = new OCIConfigFileProvider(opt, cfg, SessTokenProfileProvider);\n    } else if (PROFILE_PROPS.some(prop => opt[prop] != null)) {\n      _chkExclProps(cfg, opt, PROFILE_PROPS, [...OCI_CONFIG_PROPS, CREDS_PROVIDER_PROP]);\n      this._provider = new IAMProfileProvider(opt, cfg);\n    } else if (opt[CREDS_PROVIDER_PROP] != null) {\n      _chkExclProps(cfg, opt, CREDS_PROVIDER_PROP, OCI_CONFIG_PROPS);\n      this._provider = new UserProfileProvider(opt, cfg);\n    } else if (opt.profileProvider != null) {\n      //profileProvider is only used internally now, so not included in\n      //exclusivity checks above\n      if (typeof opt.profileProvider !== 'object') {\n        throw new NoSQLArgumentError('Custom profile provider must be an object', cfg);\n      }\n      this._provider = opt.profileProvider;\n    } else {\n      this._provider = new OCIConfigFileProvider(opt, cfg);\n    }\n    this._initDelegationToken(opt, cfg);\n    this._signature = null;\n    this._refreshTimer = null;\n  }\n  _initDelegationToken(opt, cfg) {\n    if (opt.delegationToken != null) {\n      assert(opt.useInstancePrincipal);\n      if (opt.delegationTokenProvider != null || opt.delegationTokenFile != null) {\n        throw new NoSQLArgumentError('Cannot specify \\\nauth.iam.delegationToken together with auth.iam.delegationTokenProvider or \\\nauth.iam.delegationTokenFile', cfg);\n      }\n      if (typeof opt.delegationToken !== 'string' || !opt.delegationToken) {\n        throw new NoSQLArgumentError('Invalid value for \\\nauth.iam.delegationToken, must be non-empty string', cfg);\n      }\n      this._delegationToken = opt.delegationToken;\n    } else if (opt.delegationTokenProvider != null) {\n      assert(opt.useInstancePrincipal);\n      if (opt.delegationTokenFile != null) {\n        throw new NoSQLArgumentError('Cannot specify \\\nauth.iam.delegationTokenProvider together with auth.iam.delegationTokenFile', cfg);\n      }\n      if (typeof opt.delegationTokenProvider === 'string') {\n        if (!opt.delegationTokenProvider) {\n          throw new NoSQLArgumentError('Invalid value of \\\nauth.iam.delegationTokenProvider, cannot be empty string', cfg);\n        }\n        this._delegationTokenFile = opt.delegationTokenProvider;\n      } else if (typeof opt.delegationTokenProvider === 'object') {\n        if (typeof opt.delegationTokenProvider.loadDelegationToken !== 'function') {\n          throw new NoSQLArgumentError('Invalid value of \\\nauth.iam.delegationTokenProvider: does not contain loadDelegationToken \\\nmethod', cfg);\n        }\n        this._delegationTokenProvider = opt.delegationTokenProvider;\n      } else if (typeof opt.delegationTokenProvider === 'function') {\n        this._delegationTokenProvider = {\n          loadDelegationToken: opt.delegationTokenProvider\n        };\n      } else {\n        throw new NoSQLArgumentError(\"Invalid type of auth.iam.delegationTokenProvider: \".concat(typeof opt.delegationTokenProvider), cfg);\n      }\n    } else if (opt.delegationTokenFile != null) {\n      assert(opt.useInstancePrincipal);\n      if (typeof opt.delegationTokenFile !== 'string' || !opt.delegationTokenFile) {\n        throw new NoSQLArgumentError('Invalid value for \\\nauth.iam.delegationTokenFile, must be non-empty string', cfg);\n      }\n      this._delegationTokenFile = opt.delegationTokenFile;\n    }\n    if (this._delegationTokenFile) {\n      assert(this._delegationTokenProvider == null);\n      this._delegationTokenProvider = {\n        loadDelegationToken: async () => {\n          const data = await fsPromises.readFile(this._delegationTokenFile, 'utf8');\n          return data.replace(/\\r?\\n/g, '');\n        }\n      };\n    }\n  }\n  async _loadDelegationToken() {\n    let delegationToken;\n    try {\n      delegationToken = await this._delegationTokenProvider.loadDelegationToken();\n    } catch (err) {\n      throw AuthError.invalidArg('Error retrieving delegation token' + this._delegationTokenFile ? \" from file \".concat(this._delegationTokenFile) : '', err);\n    }\n    if (typeof delegationToken !== 'string' || !delegationToken) {\n      throw AuthError.invalidArg('Retrieved delegation token \\\nis invalid or empty');\n    }\n    return delegationToken;\n  }\n  _signingHeaders(withContent) {\n    let res = SIGNING_HEADERS;\n    if (withContent) {\n      res += ' ' + CONTENT_HEADERS;\n    }\n    if (this._delegationToken != null) {\n      res += ' ' + OBO_TOKEN_HEADER;\n    }\n    return res;\n  }\n\n  //The order of headers in _signingHeaders() and _signingContent() should\n  //match.\n  _signingContent(dateStr, reqSigning) {\n    let content = \"\".concat(HttpConstants.REQUEST_TARGET, \": post /\").concat(HttpConstants.NOSQL_DATA_PATH, \"\\n\").concat(HttpConstants.HOST, \": \").concat(this._serviceHost, \"\\n\").concat(DATE_HEADER, \": \").concat(dateStr);\n    if (reqSigning) {\n      content += \"\\n\".concat(HttpConstants.CONTENT_LENGTH_LWR, \": \").concat(reqSigning.len, \"\\n\").concat(HttpConstants.CONTENT_TYPE_LWR, \": \").concat(reqSigning.type, \"\\n\").concat(HttpConstants.CONTENT_SHA256, \": \").concat(reqSigning.digest);\n    }\n    if (this._delegationToken != null) {\n      content += \"\\n\".concat(OBO_TOKEN_HEADER, \": \").concat(this._delegationToken);\n    }\n    return content;\n  }\n  async _createSignatureDetails(needProfileRefresh, req) {\n    this._profile = await this._provider.getProfile(needProfileRefresh);\n    if (this._delegationTokenProvider != null) {\n      this._delegationToken = await this._loadDelegationToken();\n    }\n    const reqSigning = req && req._op.needsContentSigned() ? {\n      type: req._protoMgr.contentType,\n      len: req._protoMgr.getContentLength(req._buf),\n      digest: Utils.sha256digest(req._protoMgr.getContent(req._buf))\n    } : undefined;\n    const date = new Date();\n    const dateStr = date.toUTCString();\n    let signature = await Utils.sign(this._signingContent(dateStr, reqSigning), this._profile.privateKey, 'request');\n    return {\n      time: date.getTime(),\n      dateStr,\n      header: Utils.signatureHeader(this._signingHeaders(reqSigning), this._profile.keyId, signature),\n      tenantId: this._profile.tenantId,\n      compartmentId: this._profile.compartmentId,\n      digest: reqSigning ? reqSigning.digest : undefined\n    };\n  }\n  _scheduleRefresh() {\n    if (this._refreshInterval) {\n      //_createSignatureDetails may be called again before\n      //the token expiration due to INVALID_AUTHORIZATION error,\n      //so the timer may be already set\n      if (this._refreshTimer != null) {\n        clearTimeout(this._refreshTimer);\n      }\n      this._refreshTimer = setTimeout(() => this._refreshSignatureDetails(), this._refreshInterval);\n    }\n  }\n  async _refreshSignatureDetails() {\n    try {\n      this._signatureDetails = await this._createSignatureDetails();\n    } catch (err) {\n      //This promise rejection will not be handled so we don't rethrow\n      //but only log the error somehow and return without rescheduling.\n      //The user will get the error when _createSignatureDetails() is\n      //called again by getAuthorization().\n      return;\n    }\n    this._scheduleRefresh();\n  }\n  onInit(cfg) {\n    if (cfg.compartment != null && (typeof cfg.compartment !== 'string' || !cfg.compartment)) {\n      throw new NoSQLArgumentError(\"Invalid value of compartment: \".concat(cfg.compartment));\n    }\n\n    //Special case for cloud where the region may be specified in OCI\n    //config file or as part of resource principal environment.  In this\n    //case we try to get the region from the auth provider and retry\n    //getting the url from this region.\n    if (cfg.url == null) {\n      if (this._provider.getRegion != null) {\n        cfg.region = this._provider.getRegion();\n      }\n      //We have to load Config dynamicaly to avoid circular dependency.\n      if (Config == null) {\n        Config = require('../../config');\n      }\n      //If the provider above does not have getRegion() function, this\n      //will retult in NoSQLArgumentError.\n      Config.initUrl(cfg, true);\n    }\n    this._serviceHost = cfg.url.hostname;\n  }\n\n  /**\n   * Gets authorization object for given database operation.\n   * Authorization object contains required authorization properties.\n   * A local cached value will be returned most of the time.\n   * @implements {getAuthorization}\n   * @see {@link getAuthorization}\n   * @param {Operation} op Database operation\n   * needing AT\n   * @returns {Promise} Promise of authorization object\n   */\n  async getAuthorization(op) {\n    const invalidAuth = op.lastError != null && op.lastError.errorCode === ErrorCode.INVALID_AUTHORIZATION;\n    let signatureDetails;\n    assert(op._op != null);\n    const isContentSigned = op._op.needsContentSigned();\n    if (isContentSigned) {\n      //For requests that need their content signed, we cannot cache the\n      //signature (because the signature is different for every\n      //request).\n      signatureDetails = await this._createSignatureDetails(invalidAuth, op);\n    } else {\n      const invalidProfile = invalidAuth || this._profile == null || this._provider.isProfileValid != null && !this._provider.isProfileValid(this._profile);\n      //Update cached signature if needed.\n      if (invalidProfile || this._signatureDetails == null || this._signatureDetails.time < Date.now() - this._duration) {\n        this._signatureDetails = await this._createSignatureDetails(invalidAuth);\n        this._scheduleRefresh();\n      }\n      signatureDetails = this._signatureDetails;\n    }\n    const ret = {\n      [HttpConstants.AUTHORIZATION]: signatureDetails.header,\n      [DATE_HEADER]: signatureDetails.dateStr\n    };\n    if (isContentSigned) {\n      ret[HttpConstants.CONTENT_SHA256] = signatureDetails.digest;\n    }\n\n    //It is possible that if _createSignatureDetails() is called\n    //concurrently and there is a new delegation token, at some moment we\n    //could have new delegation token and old signature.  However, this\n    //would be very rare and if happens the request will fail with an auth\n    //error and be retried, at which time a new signature will be created.\n    if (this._delegationToken != null) {\n      ret[OBO_TOKEN_HEADER] = this._delegationToken;\n    }\n\n    /*\n     * If request doesn't have compartment id, first check if using\n     * resource principal and useResourcePrincipalCompartment is set to\n     * true, in which case we will use the resource compartment as default\n     * compartment. Otherwise, set the tenant id as the default\n     * compartment, which is the root compartment in IAM if using user\n     * principal.\n     */\n    let compartment = op.opt.compartment;\n    if (compartment == null) {\n      //Available when using useResourcePrincipalCompartment option.\n      compartment = signatureDetails.compartmentId;\n      //Otherwise use tenant id if available.\n      if (compartment == null) {\n        compartment = signatureDetails.tenantId;\n      }\n    }\n    if (compartment != null) {\n      if (typeof compartment !== 'string' || !compartment) {\n        throw new NoSQLArgumentError(\"Invalid value of                     opt.compartment: \\\"\".concat(compartment, \"\\\"\"));\n      }\n      ret[HttpConstants.COMPARTMENT_ID] = compartment;\n    }\n\n    //Currently proxy uses the presence of this header to identify\n    //requests from the browser and thus enable CORS (by sending back\n    //Access-Control-Allow-Origin header).  The value of this header is\n    //not currently used.  \n    if (Utils.isInBrowser) {\n      ret[HttpConstants.OPC_REQUEST_ID] = 1;\n    }\n    return ret;\n  }\n  get region() {\n    return this._region;\n  }\n  async getResourcePrincipalClaims() {\n    if (!(this._provider instanceof ResourcePrincipalProvider)) {\n      return;\n    }\n    return this._provider.getRPSTClaims();\n  }\n\n  //used in unit tests\n  clearCache() {\n    this._profile = null;\n    this._signatureDetails = null;\n  }\n\n  /**\n   * Releases resources associated with this provider.\n   * @see {@link AuthorizationProvider}\n   */\n  async close() {\n    if (this._provider.close != null) {\n      this._provider.close();\n    }\n    if (this._refreshTimer != null) {\n      clearTimeout(this._refreshTimer);\n      this._refreshTimer = null;\n    }\n  }\n  static withInstancePrincipal(federationEndpoint) {\n    return new IAMAuthorizationProvider({\n      useInstancePrincipal: true,\n      federationEndpoint\n    });\n  }\n  static withInstancePrincipalForDelegation(delegationTokenOrProvider, federationEndpoint) {\n    return new IAMAuthorizationProvider(Object.assign({\n      useInstancePrincipal: true,\n      federationEndpoint\n    }, typeof delegationTokenOrProvider === 'string' ? {\n      delegationToken: delegationTokenOrProvider\n    } : {\n      delegationTokenProvider: delegationTokenOrProvider\n    }));\n  }\n  static withInstancePrincipalForDelegationFromFile(delegationTokenFile, federationEndpoint) {\n    return new IAMAuthorizationProvider({\n      useInstancePrincipal: true,\n      delegationTokenFile,\n      federationEndpoint\n    });\n  }\n  static withResourcePrincipal(useResourcePrincipalCompartment) {\n    return new IAMAuthorizationProvider({\n      useResourcePrincipal: true,\n      useResourcePrincipalCompartment\n    });\n  }\n  static withSessionToken(configFile, profileName) {\n    //1-argument overload\n    if (configFile !== undefined && profileName === undefined) {\n      profileName = configFile;\n      configFile = undefined;\n    }\n    return new IAMAuthorizationProvider({\n      useSessionToken: true,\n      configFile,\n      profileName\n    });\n  }\n}\nIAMAuthorizationProvider.configDefaults = Object.freeze({\n  timeout: 120000,\n  durationSeconds: MAX_ENTRY_LIFE_TIME,\n  refreshAheadMs: 10000,\n  //The below properties are not exposed to the user but different\n  //values are used in tests.\n  securityTokenRefreshAheadMs: 15000,\n  securityTokenExpireBeforeMs: 10000\n});\nmodule.exports = IAMAuthorizationProvider;","map":{"version":3,"names":["assert","require","fsPromises","promises","isPosInt32","HttpConstants","ErrorCode","NoSQLArgumentError","AuthError","NoSQLAuthorizationError","Utils","IAMProfileProvider","UserProfileProvider","OCIConfigFileProvider","SessTokenProfileProvider","ResourcePrincipalProvider","InstancePrincipalProvider","Config","MAX_ENTRY_LIFE_TIME","DATE_HEADER","isInBrowser","X_DATE","DATE","SIGNING_HEADERS","concat","OBO_TOKEN_HEADER","CONTENT_HEADERS","PROFILE_PROPS","OCI_CONFIG_PROPS","CREDS_PROVIDER_PROP","INST_PRINCIPAL_PROP","IP_EXTRA_PROPS","RES_PRINCIPAL_PROP","RP_EXTRA_PROPS","SESS_TOKEN_PROP","USER_IDEN_PROPS","_findProps","opt","props","truthyProps","val","find","item","_chkExclProps","cfg","prop","Array","isArray","join","IAMAuthorizationProvider","constructor","__proto__","configDefaults","durationSeconds","_duration","refreshAheadMs","_refreshInterval","useResourcePrincipal","_provider","useInstancePrincipal","useSessionToken","some","profileProvider","_initDelegationToken","_signature","_refreshTimer","delegationToken","delegationTokenProvider","delegationTokenFile","_delegationToken","_delegationTokenFile","loadDelegationToken","_delegationTokenProvider","data","readFile","replace","_loadDelegationToken","err","invalidArg","_signingHeaders","withContent","res","_signingContent","dateStr","reqSigning","content","REQUEST_TARGET","NOSQL_DATA_PATH","HOST","_serviceHost","CONTENT_LENGTH_LWR","len","CONTENT_TYPE_LWR","type","CONTENT_SHA256","digest","_createSignatureDetails","needProfileRefresh","req","_profile","getProfile","_op","needsContentSigned","_protoMgr","contentType","getContentLength","_buf","sha256digest","getContent","undefined","date","Date","toUTCString","signature","sign","privateKey","time","getTime","header","signatureHeader","keyId","tenantId","compartmentId","_scheduleRefresh","clearTimeout","setTimeout","_refreshSignatureDetails","_signatureDetails","onInit","compartment","url","getRegion","region","initUrl","hostname","getAuthorization","op","invalidAuth","lastError","errorCode","INVALID_AUTHORIZATION","signatureDetails","isContentSigned","invalidProfile","isProfileValid","now","ret","AUTHORIZATION","COMPARTMENT_ID","OPC_REQUEST_ID","_region","getResourcePrincipalClaims","getRPSTClaims","clearCache","close","withInstancePrincipal","federationEndpoint","withInstancePrincipalForDelegation","delegationTokenOrProvider","Object","assign","withInstancePrincipalForDelegationFromFile","withResourcePrincipal","useResourcePrincipalCompartment","withSessionToken","configFile","profileName","freeze","timeout","securityTokenRefreshAheadMs","securityTokenExpireBeforeMs","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/auth/iam/auth_provider.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\nconst assert = require('assert');\nconst fsPromises = require('fs').promises;\n\nconst isPosInt32 = require('../../utils').isPosInt32;\nconst HttpConstants = require('../../constants').HttpConstants;\nconst ErrorCode = require('../../error_code');\nconst NoSQLArgumentError = require('../../error').NoSQLArgumentError;\nconst AuthError = require('../../error').NoSQLAuthorizationError;\nconst Utils = require('./utils');\nconst IAMProfileProvider = require('./profile').IAMProfileProvider;\nconst UserProfileProvider = require('./profile').UserProfileProvider;\nconst OCIConfigFileProvider = require('./profile').OCIConfigFileProvider;\nconst SessTokenProfileProvider = require('./profile')\n    .SessTokenProfileProvider;\nconst ResourcePrincipalProvider = require('./resource_principal');\nconst InstancePrincipalProvider = require('./instance_principal');\n\nlet Config;\n\n/* Maximum lifetime of signature 300 seconds */\nconst MAX_ENTRY_LIFE_TIME = 300;\n\nconst DATE_HEADER = Utils.isInBrowser ?\n    HttpConstants.X_DATE : HttpConstants.DATE;\n\nconst SIGNING_HEADERS = `(request-target) host ${DATE_HEADER}`;\n\nconst OBO_TOKEN_HEADER = 'opc-obo-token';\n\nconst CONTENT_HEADERS = 'content-length content-type x-content-sha256';\n\nconst PROFILE_PROPS = [ 'tenantId', 'userId', 'fingerprint', 'privateKey',\n    'privateKeyFile', 'passphrase' ];\n\nconst OCI_CONFIG_PROPS = [ 'configFile', 'profileName' ];\n\nconst CREDS_PROVIDER_PROP = 'credentialsProvider';\n\nconst INST_PRINCIPAL_PROP = 'useInstancePrincipal';\n\nconst IP_EXTRA_PROPS = [ 'federationEndpoint', 'delegationToken',\n    'delegationTokenProvider', 'delegationTokenFile' ];\n\nconst RES_PRINCIPAL_PROP = 'useResourcePrincipal';\n\nconst RP_EXTRA_PROPS = [ 'useResourcePrincipalCompartment' ];\n\nconst SESS_TOKEN_PROP = 'useSessionToken';\n\nconst USER_IDEN_PROPS = [ ...PROFILE_PROPS, ...OCI_CONFIG_PROPS,\n    CREDS_PROVIDER_PROP ];\n\nfunction _findProps(opt, props, truthyProps) {\n    let val;\n    if (props) {\n        val = props.find(item => opt[item] != null);\n    }\n    if (!val && truthyProps) {\n        val = truthyProps.find(item => opt[item]);\n    }\n    return val;\n}\n\nfunction _chkExclProps(cfg, opt, prop, props, truthyProps) {\n    const val = _findProps(opt, props, truthyProps);\n    if (!val) {\n        return;\n    }\n    if (Array.isArray(prop)) {\n        prop = 'any of ' + prop.join(', ');\n    }\n    throw new NoSQLArgumentError(\n        `Cannot specify property ${val} together with ${prop}`, cfg);\n}\n\nclass IAMAuthorizationProvider {\n\n    constructor(opt, cfg) {\n        if (opt == null) {\n            //Possible if using default OCI config file with default profile.\n            opt = {};\n        } else if (typeof opt !== 'object') {\n            throw new NoSQLArgumentError('Invalid IAMConfig object', cfg);\n        }\n\n        //Needed in case this provider is created outside NoSQLClient\n        //instance. Note that this is currently sufficient, because\n        //AuthConfig.defaults.iam has no nested properties. Otherwise the code\n        //below will need to change to use Config.inheritOpt().\n        opt.__proto__ = IAMAuthorizationProvider.configDefaults;\n\n        if (opt.durationSeconds == null) {\n            this._duration = MAX_ENTRY_LIFE_TIME;\n        } else {\n            if (!isPosInt32(opt.durationSeconds)) {\n                throw new NoSQLArgumentError(\n                    'Invalid auth.iam.durationSeconds value', cfg);\n            }\n            if (opt.durationSeconds > MAX_ENTRY_LIFE_TIME) {\n                throw new NoSQLArgumentError(`Signature cannot be cached for \\\nmore than ${MAX_ENTRY_LIFE_TIME} seconds`, cfg);\n            }\n            this._duration = opt.durationSeconds;\n        }\n        this._duration *= 1000;\n\n        if (opt.refreshAheadMs != null) {\n            if (!isPosInt32(opt.refreshAheadMs)) {\n                throw new NoSQLArgumentError(\n                    'Invalid auth.iam.refreshAheadMs value', cfg);\n            }\n            if (this._duration > opt.refreshAheadMs) {\n                this._refreshInterval = this._duration - opt.refreshAheadMs;\n            }\n        }\n\n        let prop;\n\n        //init authentication details provider\n        if (opt.useResourcePrincipal) {\n            _chkExclProps(cfg, opt, RES_PRINCIPAL_PROP, USER_IDEN_PROPS,\n                [ INST_PRINCIPAL_PROP, SESS_TOKEN_PROP ]);\n            this._provider = new ResourcePrincipalProvider(opt, cfg);\n        } else if ((prop = _findProps(opt, null, RP_EXTRA_PROPS)) != null) {\n            throw new NoSQLArgumentError(`Cannot specify property ${prop} \\\nwithout ${RES_PRINCIPAL_PROP}`, cfg);\n        } else if (opt.useInstancePrincipal) {\n            _chkExclProps(cfg, opt, INST_PRINCIPAL_PROP, USER_IDEN_PROPS,\n                [ SESS_TOKEN_PROP ]);\n            this._provider = new InstancePrincipalProvider(opt, cfg);\n        } else if ((prop = _findProps(opt, IP_EXTRA_PROPS)) != null) {\n            throw new NoSQLArgumentError(`Cannot specify property ${prop} \\\nwithout ${INST_PRINCIPAL_PROP}`, cfg);\n        } else if (opt.useSessionToken) {\n            _chkExclProps(cfg, opt, SESS_TOKEN_PROP,\n                [ ...PROFILE_PROPS, CREDS_PROVIDER_PROP ]);\n            this._provider = new OCIConfigFileProvider(opt, cfg,\n                SessTokenProfileProvider);\n        } else if (PROFILE_PROPS.some(prop => opt[prop] != null)) {\n            _chkExclProps(cfg, opt, PROFILE_PROPS,\n                [ ...OCI_CONFIG_PROPS, CREDS_PROVIDER_PROP ]);\n            this._provider = new IAMProfileProvider(opt, cfg);\n        } else if (opt[CREDS_PROVIDER_PROP] != null) {\n            _chkExclProps(cfg, opt, CREDS_PROVIDER_PROP, OCI_CONFIG_PROPS);\n            this._provider = new UserProfileProvider(opt, cfg);\n        } else if (opt.profileProvider != null) {\n            //profileProvider is only used internally now, so not included in\n            //exclusivity checks above\n            if (typeof opt.profileProvider !== 'object') {\n                throw new NoSQLArgumentError(\n                    'Custom profile provider must be an object', cfg);\n            }\n            this._provider = opt.profileProvider;\n        } else {\n            this._provider = new OCIConfigFileProvider(opt, cfg);\n        }\n\n        this._initDelegationToken(opt, cfg);\n\n        this._signature = null;\n        this._refreshTimer = null;\n    }\n\n    _initDelegationToken(opt, cfg) {\n        if (opt.delegationToken != null) {\n            assert(opt.useInstancePrincipal);\n            if (opt.delegationTokenProvider != null ||\n                opt.delegationTokenFile != null) {\n                throw new NoSQLArgumentError('Cannot specify \\\nauth.iam.delegationToken together with auth.iam.delegationTokenProvider or \\\nauth.iam.delegationTokenFile', cfg);\n            }\n            if (typeof opt.delegationToken !== 'string' ||\n                !opt.delegationToken) {\n                throw new NoSQLArgumentError('Invalid value for \\\nauth.iam.delegationToken, must be non-empty string', cfg);\n            }\n            this._delegationToken = opt.delegationToken;\n        } else if (opt.delegationTokenProvider != null) {\n            assert(opt.useInstancePrincipal);\n            if (opt.delegationTokenFile != null) {\n                throw new NoSQLArgumentError('Cannot specify \\\nauth.iam.delegationTokenProvider together with auth.iam.delegationTokenFile',\n                cfg);\n            }\n            if (typeof opt.delegationTokenProvider === 'string') {\n                if (!opt.delegationTokenProvider) {\n                    throw new NoSQLArgumentError('Invalid value of \\\nauth.iam.delegationTokenProvider, cannot be empty string', cfg);\n                }\n                this._delegationTokenFile = opt.delegationTokenProvider;\n            } else if (typeof opt.delegationTokenProvider === 'object') {\n                if (typeof opt.delegationTokenProvider.loadDelegationToken !==\n                    'function') {\n                    throw new NoSQLArgumentError('Invalid value of \\\nauth.iam.delegationTokenProvider: does not contain loadDelegationToken \\\nmethod', cfg);\n                }\n                this._delegationTokenProvider = opt.delegationTokenProvider;\n            } else if (typeof opt.delegationTokenProvider === 'function') {\n                this._delegationTokenProvider = {\n                    loadDelegationToken: opt.delegationTokenProvider\n                };\n            } else {\n                throw new NoSQLArgumentError(`Invalid type of \\\nauth.iam.delegationTokenProvider: ${typeof opt.delegationTokenProvider}`,\n                cfg);\n            }\n        } else if (opt.delegationTokenFile != null) {\n            assert(opt.useInstancePrincipal);\n            if (typeof opt.delegationTokenFile !== 'string' ||\n                !opt.delegationTokenFile) {\n                throw new NoSQLArgumentError('Invalid value for \\\nauth.iam.delegationTokenFile, must be non-empty string', cfg);\n            }\n            this._delegationTokenFile = opt.delegationTokenFile;\n        }\n        if (this._delegationTokenFile) {\n            assert(this._delegationTokenProvider == null);\n            this._delegationTokenProvider = {\n                loadDelegationToken: async () => {\n                    const data = await fsPromises.readFile(\n                        this._delegationTokenFile, 'utf8');\n                    return data.replace(/\\r?\\n/g, '');\n                }\n            };\n        }\n    }\n\n    async _loadDelegationToken()\n    {\n        let delegationToken;\n        try {\n            delegationToken = await this._delegationTokenProvider\n                .loadDelegationToken();\n        } catch(err) {\n            throw AuthError.invalidArg('Error retrieving delegation token' +\n                this._delegationTokenFile ?\n                ` from file ${this._delegationTokenFile}` : '', err);\n        }\n        if (typeof delegationToken !== 'string' || !delegationToken) {\n            throw AuthError.invalidArg('Retrieved delegation token \\\nis invalid or empty');\n        }\n        return delegationToken;\n    }\n\n    _signingHeaders(withContent) {\n        let res = SIGNING_HEADERS;\n        if (withContent) {\n            res += ' ' + CONTENT_HEADERS;\n        }\n        if (this._delegationToken != null) {\n            res += ' ' + OBO_TOKEN_HEADER;\n        }\n        return res;\n    }\n\n    //The order of headers in _signingHeaders() and _signingContent() should\n    //match.\n    _signingContent(dateStr, reqSigning) {\n        let content = `${HttpConstants.REQUEST_TARGET}: post /\\\n${HttpConstants.NOSQL_DATA_PATH}\\n\\\n${HttpConstants.HOST}: ${this._serviceHost}\\n\\\n${DATE_HEADER}: ${dateStr}`;\n\n        if (reqSigning) {\n            content +=\n                `\\n${HttpConstants.CONTENT_LENGTH_LWR}: ${reqSigning.len}\\n\\\n${HttpConstants.CONTENT_TYPE_LWR}: ${reqSigning.type}\\n\\\n${HttpConstants.CONTENT_SHA256}: ${reqSigning.digest}`;\n        }\n\n        if (this._delegationToken != null) {\n            content += `\\n${OBO_TOKEN_HEADER}: ${this._delegationToken}`;\n        }\n        return content;\n    }\n\n    async _createSignatureDetails(needProfileRefresh, req) {\n        this._profile = await this._provider.getProfile(needProfileRefresh);\n        if (this._delegationTokenProvider != null) {\n            this._delegationToken = await this._loadDelegationToken();\n        }\n        \n        const reqSigning = (req && req._op.needsContentSigned()) ? {\n            type: req._protoMgr.contentType,\n            len: req._protoMgr.getContentLength(req._buf),\n            digest: Utils.sha256digest(req._protoMgr.getContent(req._buf))\n        } : undefined;\n\n        const date = new Date();\n        const dateStr = date.toUTCString();\n        let signature = await Utils.sign(\n            this._signingContent(dateStr, reqSigning),\n            this._profile.privateKey, 'request');\n\n        return {\n            time: date.getTime(),\n            dateStr,\n            header: Utils.signatureHeader(this._signingHeaders(reqSigning),\n                this._profile.keyId, signature),\n            tenantId: this._profile.tenantId,\n            compartmentId: this._profile.compartmentId,\n            digest: reqSigning ? reqSigning.digest : undefined\n        };\n    }\n\n    _scheduleRefresh() {\n        if (this._refreshInterval) {\n            //_createSignatureDetails may be called again before\n            //the token expiration due to INVALID_AUTHORIZATION error,\n            //so the timer may be already set\n            if (this._refreshTimer != null) {\n                clearTimeout(this._refreshTimer);\n            }\n            this._refreshTimer = setTimeout(\n                () => this._refreshSignatureDetails(),\n                this._refreshInterval);\n        }\n    }\n\n    async _refreshSignatureDetails() {\n        try {\n            this._signatureDetails = await this._createSignatureDetails();\n        } catch(err) {\n            //This promise rejection will not be handled so we don't rethrow\n            //but only log the error somehow and return without rescheduling.\n            //The user will get the error when _createSignatureDetails() is\n            //called again by getAuthorization().\n            return;\n        }\n        this._scheduleRefresh();\n    }\n\n    onInit(cfg) {\n        if (cfg.compartment != null &&\n            (typeof cfg.compartment !== 'string' || !cfg.compartment)) {\n            throw new NoSQLArgumentError(\n                `Invalid value of compartment: ${cfg.compartment}`);\n        }\n\n        //Special case for cloud where the region may be specified in OCI\n        //config file or as part of resource principal environment.  In this\n        //case we try to get the region from the auth provider and retry\n        //getting the url from this region.\n        if (cfg.url == null) {\n            if (this._provider.getRegion != null) {\n                cfg.region = this._provider.getRegion();\n            }\n            //We have to load Config dynamicaly to avoid circular dependency.\n            if (Config == null) {\n                Config = require('../../config');\n            }\n            //If the provider above does not have getRegion() function, this\n            //will retult in NoSQLArgumentError.\n            Config.initUrl(cfg, true);\n        }\n        \n        this._serviceHost = cfg.url.hostname;\n    }\n\n    /**\n     * Gets authorization object for given database operation.\n     * Authorization object contains required authorization properties.\n     * A local cached value will be returned most of the time.\n     * @implements {getAuthorization}\n     * @see {@link getAuthorization}\n     * @param {Operation} op Database operation\n     * needing AT\n     * @returns {Promise} Promise of authorization object\n     */\n    async getAuthorization(op) {\n        const invalidAuth = op.lastError != null &&\n            op.lastError.errorCode === ErrorCode.INVALID_AUTHORIZATION;\n\n        let signatureDetails;\n        assert(op._op != null);\n        const isContentSigned = op._op.needsContentSigned();\n\n        if (isContentSigned) {\n            //For requests that need their content signed, we cannot cache the\n            //signature (because the signature is different for every\n            //request).\n            signatureDetails = await this._createSignatureDetails(\n                invalidAuth, op);\n        } else {\n            const invalidProfile = invalidAuth || this._profile == null ||\n                (this._provider.isProfileValid != null &&\n                !this._provider.isProfileValid(this._profile));\n            //Update cached signature if needed.\n            if (invalidProfile || this._signatureDetails == null ||\n                this._signatureDetails.time < Date.now() - this._duration) {\n                this._signatureDetails =\n                    await this._createSignatureDetails(invalidAuth);\n                this._scheduleRefresh();\n            }\n            signatureDetails = this._signatureDetails;\n        }\n\n        const ret = {\n            [HttpConstants.AUTHORIZATION]: signatureDetails.header,\n            [DATE_HEADER]: signatureDetails.dateStr,\n        };\n\n        if (isContentSigned) {\n            ret[HttpConstants.CONTENT_SHA256] = signatureDetails.digest;\n        }\n\n        //It is possible that if _createSignatureDetails() is called\n        //concurrently and there is a new delegation token, at some moment we\n        //could have new delegation token and old signature.  However, this\n        //would be very rare and if happens the request will fail with an auth\n        //error and be retried, at which time a new signature will be created.\n        if (this._delegationToken != null) {\n            ret[OBO_TOKEN_HEADER] = this._delegationToken;\n        }\n\n        /*\n         * If request doesn't have compartment id, first check if using\n         * resource principal and useResourcePrincipalCompartment is set to\n         * true, in which case we will use the resource compartment as default\n         * compartment. Otherwise, set the tenant id as the default\n         * compartment, which is the root compartment in IAM if using user\n         * principal.\n         */\n        let compartment = op.opt.compartment;\n        if (compartment == null) {\n            //Available when using useResourcePrincipalCompartment option.\n            compartment = signatureDetails.compartmentId;\n            //Otherwise use tenant id if available.\n            if (compartment == null) {\n                compartment = signatureDetails.tenantId;\n            }\n        }\n        if (compartment != null) {\n            if (typeof compartment !== 'string' || !compartment) {\n                throw new NoSQLArgumentError(`Invalid value of \\\n                    opt.compartment: \"${compartment}\"`);\n            }\n            ret[HttpConstants.COMPARTMENT_ID] = compartment;\n        }\n\n        //Currently proxy uses the presence of this header to identify\n        //requests from the browser and thus enable CORS (by sending back\n        //Access-Control-Allow-Origin header).  The value of this header is\n        //not currently used.  \n        if (Utils.isInBrowser) {\n            ret[HttpConstants.OPC_REQUEST_ID] = 1;\n        }\n\n        return ret;\n    }\n\n    get region() {\n        return this._region;\n    }\n\n    async getResourcePrincipalClaims() {\n        if (!(this._provider instanceof ResourcePrincipalProvider)) {\n            return;\n        }\n        return this._provider.getRPSTClaims();\n    }\n\n    //used in unit tests\n    clearCache() {\n        this._profile = null;\n        this._signatureDetails = null;\n    }\n\n    /**\n     * Releases resources associated with this provider.\n     * @see {@link AuthorizationProvider}\n     */\n    async close() {\n        if (this._provider.close != null) {\n            this._provider.close();\n        }\n        if (this._refreshTimer != null) {\n            clearTimeout(this._refreshTimer);\n            this._refreshTimer = null;\n        }\n    }\n\n    static withInstancePrincipal(federationEndpoint) {\n        return new IAMAuthorizationProvider({\n            useInstancePrincipal: true,\n            federationEndpoint\n        });\n    }\n\n    static withInstancePrincipalForDelegation(delegationTokenOrProvider,\n        federationEndpoint) {\n        return new IAMAuthorizationProvider(Object.assign({\n            useInstancePrincipal: true,\n            federationEndpoint\n        }, typeof delegationTokenOrProvider === 'string' ?\n            { delegationToken: delegationTokenOrProvider } : \n            { delegationTokenProvider: delegationTokenOrProvider }));\n    }\n\n    static withInstancePrincipalForDelegationFromFile(delegationTokenFile,\n        federationEndpoint) {\n        return new IAMAuthorizationProvider({\n            useInstancePrincipal: true,\n            delegationTokenFile,\n            federationEndpoint\n        });\n    }\n\n    static withResourcePrincipal(useResourcePrincipalCompartment) {\n        return new IAMAuthorizationProvider({\n            useResourcePrincipal: true,\n            useResourcePrincipalCompartment\n        });\n    }\n\n    static withSessionToken(configFile, profileName) {\n        //1-argument overload\n        if (configFile !== undefined && profileName === undefined) {\n            profileName = configFile;\n            configFile = undefined;\n        }\n        return new IAMAuthorizationProvider({\n            useSessionToken: true,\n            configFile,\n            profileName\n        });\n    }\n\n}\n\nIAMAuthorizationProvider.configDefaults = Object.freeze({\n    timeout: 120000,\n    durationSeconds: MAX_ENTRY_LIFE_TIME,\n    refreshAheadMs: 10000,\n    //The below properties are not exposed to the user but different\n    //values are used in tests.\n    securityTokenRefreshAheadMs: 15000,\n    securityTokenExpireBeforeMs: 10000\n});\n\nmodule.exports = IAMAuthorizationProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}