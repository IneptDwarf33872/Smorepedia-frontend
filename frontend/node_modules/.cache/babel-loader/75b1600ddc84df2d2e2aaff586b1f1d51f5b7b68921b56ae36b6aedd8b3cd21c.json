{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\nconst util = require('util');\nconst fs = require('fs');\nconst crypto = require('crypto');\nconst tls = require('tls');\nconst net = require('net');\nconst NoSQLAuthorizationError = require('../../error').NoSQLAuthorizationError;\nconst promisified = require('../../utils').promisified;\nconst clearData = require('../../utils').clearData;\n\n/* Signing algorithm only rsa-sha256 is allowed */\nconst ALG_RSA = 'rsa-sha256';\n\n/* Signature algorithm */\nconst ALG_SIGN = 'sha256WithRSAEncryption';\n\n/* OCI signature version only version 1 is allowed*/\nconst SIGNATURE_VERSION = 1;\n\n/*\n * <ocid>.<resource-type>.<realm>. <region>(.future-extensibility)\n * .<resource-type-specific-id>\n * pattern is relaxed other than the required <ocid> and\n * <resource-type-specific-id>\n */\nconst OCID_PATTERN = /^([0-9a-zA-Z-_]+[.:])([0-9a-zA-Z-_]*[.:]){3,}([0-9a-zA-Z-_]+)$/;\nclass Utils {\n  static get isInBrowser() {\n    return false;\n  }\n  static async _sign(signingContent, privateKey) {\n    const sign = crypto.createSign(ALG_SIGN);\n    sign.update(signingContent);\n    return sign.sign(privateKey, 'base64');\n  }\n  static signatureHeader(signingHeaders, keyId, signature) {\n    return \"Signature headers=\\\"\".concat(signingHeaders, \"\\\",keyId=\\\"\").concat(keyId, \"\\\",algorithm=\\\"\").concat(ALG_RSA, \"\\\",signature=\\\"\").concat(signature, \"\\\",version=\\\"\").concat(SIGNATURE_VERSION, \"\\\"\");\n  }\n  static async sign(signingContent, privateKey, desc) {\n    try {\n      return this._sign(signingContent, privateKey);\n    } catch (err) {\n      throw NoSQLAuthorizationError.illegalState(\"Error signing \".concat(desc, \": \").concat(err.message), err);\n    }\n  }\n  static isValidOcid(ocid) {\n    return typeof ocid === 'string' && ocid.match(OCID_PATTERN);\n  }\n  static privateKeyFromPEM(key, passphrase, fileName) {\n    try {\n      return crypto.createPrivateKey({\n        key,\n        format: 'pem',\n        passphrase: passphrase ? passphrase : undefined\n      });\n    } catch (err) {\n      throw NoSQLAuthorizationError.invalidArg('Error creating \\\nprivate key' + (fileName ? \" from file \".concat(fileName) : ''), err);\n    }\n  }\n  static async privateKeyFromPEMFile(keyFile, pass, passIsFile) {\n    let key;\n    try {\n      key = await promisified(null, fs.readFile, keyFile);\n    } catch (err) {\n      throw NoSQLAuthorizationError.invalidArg(\"Error reading private key from file \".concat(keyFile, \": \").concat(err.message), err);\n    }\n    let pkPass;\n    if (pass != null) {\n      if (passIsFile) {\n        try {\n          pkPass = await promisified(null, fs.readFile, pass);\n        } catch (err) {\n          clearData(key);\n          throw NoSQLAuthorizationError.invalidArg(\"Error reading     private key passphrase from file \".concat(pass, \": \").concat(err.message), err);\n        }\n      } else {\n        pkPass = pass;\n      }\n    }\n    try {\n      return Utils.privateKeyFromPEM(key, pkPass, keyFile);\n    } finally {\n      clearData(key);\n      if (pkPass != null && passIsFile) {\n        clearData(pass);\n      }\n    }\n  }\n  static parseSecurityToken(value, fileName) {\n    const token = {\n      value\n    };\n    const parts = value.split('.');\n    if (parts.length < 3) {\n      throw NoSQLAuthorizationError.invalidArg('Invalid security token \\\nvalue' + (fileName ? \" from file \".concat(fileName) : '') + \", number of parts: \".concat(parts.length, \" (should be >= 3)\"));\n    }\n    try {\n      const claimsStr = Buffer.from(parts[1], 'base64').toString();\n      token.claims = JSON.parse(claimsStr);\n      return token;\n    } catch (err) {\n      throw NoSQLAuthorizationError.invalidArg('Error parsing security \\\ntoken' + (fileName ? \" from file \".concat(fileName) : ''), err);\n    }\n  }\n\n  //expireBeforeMs is to account for token acquisition time and possibly\n  //clock difference between client and server.\n  static getSecurityTokenExpiration(token, expireBeforeMs) {\n    return Number(token.claims.exp) * 1000 - expireBeforeMs;\n  }\n\n  //We don't currently do the check done in OCI SDK SecurityTokenAdapter\n  //that compares public key in jwt's jwk with current public key because\n  //no easy way to create public key from jwk in Node.js currently.  If\n  //such mismatch occurs, the driver request will fail with\n  //INVALID_AUTHORIZATION and we will retry it after refreshing the token.\n  static isSecurityTokenValid(token, expireBeforeMs) {\n    const exp = this.getSecurityTokenExpiration(token, expireBeforeMs);\n    const now = Date.now();\n    return Number.isFinite(exp) && now < exp;\n  }\n  static parseCert(pemCert) {\n    const secureContext = tls.createSecureContext({\n      cert: pemCert\n    });\n    const sock = new tls.TLSSocket(new net.Socket(), {\n      secureContext\n    });\n    const cert = sock.getCertificate();\n    sock.destroy();\n    return cert;\n  }\n  static getSubjRDNValue(rdn, key) {\n    if (rdn == null) {\n      return null;\n    }\n    const prefix = key + ':';\n    if (!Array.isArray(rdn)) {\n      rdn = [rdn];\n    }\n    for (let kv of rdn) {\n      if (typeof kv !== 'string') {\n        throw NoSQLAuthorizationError.illegalState('Invalid RDN \\\nvalue in instance certificate subject name: ' + util.inspect(kv));\n      }\n      if (kv.startsWith(prefix)) {\n        return kv.substring(prefix.length);\n      }\n    }\n    return null;\n  }\n  static getTenantIdFromInstanceCert(cert) {\n    if (cert.subject == null) {\n      throw NoSQLAuthorizationError.illegalState('Invalid instance \\\ncertificate, missing subject');\n    }\n    let tenantId = this.getSubjRDNValue(cert.subject.OU, 'opc-tenant');\n    if (tenantId == null) {\n      tenantId = this.getSubjRDNValue(cert.subject.O, 'opc-identity');\n    }\n    if (tenantId == null) {\n      throw NoSQLAuthorizationError.illegalState('Instance certificate \\\ndoes not contain tenant id');\n    }\n    return tenantId;\n  }\n  static generateRSAKeyPair() {\n    return new Promise((resolve, reject) => {\n      crypto.generateKeyPair('rsa', {\n        modulusLength: 2048\n      }, (err, publicKey, privateKey) => {\n        if (err) {\n          return reject(err);\n        }\n        return resolve({\n          publicKey,\n          privateKey\n        });\n      });\n    });\n  }\n  static pemCert2derB64(pem) {\n    //remove header and footer\n    return pem.replace('-----BEGIN CERTIFICATE-----', '').replace('-----END CERTIFICATE-----', '');\n  }\n  static pemCert2der(pem) {\n    return Buffer.from(Utils.pemCert2derB64(pem), 'base64');\n  }\n  static sha256digest(data) {\n    const hash = crypto.createHash('sha256');\n    hash.update(data);\n    return hash.digest('base64');\n  }\n  static fingerprintFromPemCert(pemCert) {\n    const derCert = Utils.pemCert2der(pemCert);\n    const hash = crypto.createHash('sha1');\n    hash.update(derCert);\n    const raw = hash.digest('hex');\n    return raw.match(/.{2}/g).join(':');\n  }\n}\nmodule.exports = Utils;","map":{"version":3,"names":["util","require","fs","crypto","tls","net","NoSQLAuthorizationError","promisified","clearData","ALG_RSA","ALG_SIGN","SIGNATURE_VERSION","OCID_PATTERN","Utils","isInBrowser","_sign","signingContent","privateKey","sign","createSign","update","signatureHeader","signingHeaders","keyId","signature","concat","desc","err","illegalState","message","isValidOcid","ocid","match","privateKeyFromPEM","key","passphrase","fileName","createPrivateKey","format","undefined","invalidArg","privateKeyFromPEMFile","keyFile","pass","passIsFile","readFile","pkPass","parseSecurityToken","value","token","parts","split","length","claimsStr","Buffer","from","toString","claims","JSON","parse","getSecurityTokenExpiration","expireBeforeMs","Number","exp","isSecurityTokenValid","now","Date","isFinite","parseCert","pemCert","secureContext","createSecureContext","cert","sock","TLSSocket","Socket","getCertificate","destroy","getSubjRDNValue","rdn","prefix","Array","isArray","kv","inspect","startsWith","substring","getTenantIdFromInstanceCert","subject","tenantId","OU","O","generateRSAKeyPair","Promise","resolve","reject","generateKeyPair","modulusLength","publicKey","pemCert2derB64","pem","replace","pemCert2der","sha256digest","data","hash","createHash","digest","fingerprintFromPemCert","derCert","raw","join","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/auth/iam/utils_node.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\nconst util = require('util');\nconst fs = require('fs');\nconst crypto = require('crypto');\nconst tls = require('tls');\nconst net = require('net');\n\nconst NoSQLAuthorizationError =\n    require('../../error').NoSQLAuthorizationError;\nconst promisified = require('../../utils').promisified;\nconst clearData = require('../../utils').clearData;\n\n/* Signing algorithm only rsa-sha256 is allowed */\nconst ALG_RSA = 'rsa-sha256';\n\n/* Signature algorithm */\nconst ALG_SIGN = 'sha256WithRSAEncryption';\n\n/* OCI signature version only version 1 is allowed*/\nconst SIGNATURE_VERSION = 1;\n\n/*\n * <ocid>.<resource-type>.<realm>. <region>(.future-extensibility)\n * .<resource-type-specific-id>\n * pattern is relaxed other than the required <ocid> and\n * <resource-type-specific-id>\n */\nconst OCID_PATTERN =\n    /^([0-9a-zA-Z-_]+[.:])([0-9a-zA-Z-_]*[.:]){3,}([0-9a-zA-Z-_]+)$/;\n\nclass Utils {\n\n    static get isInBrowser() { return false; }\n\n    static async _sign(signingContent, privateKey) {\n        const sign = crypto.createSign(ALG_SIGN);\n        sign.update(signingContent);\n        return sign.sign(privateKey, 'base64');\n    }\n\n    static signatureHeader(signingHeaders, keyId, signature) {\n        return `Signature headers=\"${signingHeaders}\",keyId=\"${keyId}\",\\\nalgorithm=\"${ALG_RSA}\",signature=\"${signature}\",\\\nversion=\"${SIGNATURE_VERSION}\"`;\n    }\n\n    static async sign(signingContent, privateKey, desc) {\n        try {\n            return this._sign(signingContent, privateKey);\n        } catch(err) {\n            throw NoSQLAuthorizationError.illegalState(\n                `Error signing ${desc}: ${err.message}`, err);\n        }\n    }\n\n    static isValidOcid(ocid) {\n        return typeof ocid === 'string' && ocid.match(OCID_PATTERN);\n    }\n\n    static privateKeyFromPEM(key, passphrase, fileName) {\n        try {\n            return crypto.createPrivateKey({\n                key,\n                format: 'pem',\n                passphrase: passphrase ? passphrase : undefined\n            });\n        } catch(err) {\n            throw NoSQLAuthorizationError.invalidArg('Error creating \\\nprivate key' + (fileName ? ` from file ${fileName}` : ''), err);\n        }\n    }\n\n    static async privateKeyFromPEMFile(keyFile, pass, passIsFile) {\n        let key;\n        try {\n            key = await promisified(null, fs.readFile, keyFile);\n        } catch(err) {\n            throw NoSQLAuthorizationError.invalidArg(`Error reading private \\\nkey from file ${keyFile}: ${err.message}`, err);\n        }\n        let pkPass;\n        if (pass != null) {\n            if (passIsFile) {\n                try {\n                    pkPass = await promisified(null, fs.readFile, pass);\n                } catch(err) {\n                    clearData(key);\n                    throw NoSQLAuthorizationError.invalidArg(`Error reading \\\n    private key passphrase from file ${pass}: ${err.message}`, err);\n                }\n            } else {\n                pkPass = pass;\n            }\n        }\n        try {\n            return Utils.privateKeyFromPEM(key, pkPass, keyFile);\n        } finally {\n            clearData(key);\n            if (pkPass != null && passIsFile) {\n                clearData(pass);\n            }\n        }\n    }\n\n    static parseSecurityToken(value, fileName) {\n        const token = { value };\n        const parts = value.split('.');\n        if (parts.length < 3) {\n            throw NoSQLAuthorizationError.invalidArg('Invalid security token \\\nvalue' + (fileName ? ` from file ${fileName}` : '') + `, number of parts: \\\n${parts.length} (should be >= 3)`);\n        }\n        try {\n            const claimsStr = Buffer.from(parts[1], 'base64').toString();\n            token.claims = JSON.parse(claimsStr);\n            return token;\n        } catch(err) {\n            throw NoSQLAuthorizationError.invalidArg('Error parsing security \\\ntoken' + (fileName ? ` from file ${fileName}` : ''), err);\n        }\n    }\n\n    //expireBeforeMs is to account for token acquisition time and possibly\n    //clock difference between client and server.\n    static getSecurityTokenExpiration(token, expireBeforeMs) {\n        return Number(token.claims.exp) * 1000 - expireBeforeMs;\n    }\n\n    //We don't currently do the check done in OCI SDK SecurityTokenAdapter\n    //that compares public key in jwt's jwk with current public key because\n    //no easy way to create public key from jwk in Node.js currently.  If\n    //such mismatch occurs, the driver request will fail with\n    //INVALID_AUTHORIZATION and we will retry it after refreshing the token.\n    static isSecurityTokenValid(token, expireBeforeMs) {\n        const exp = this.getSecurityTokenExpiration(token, expireBeforeMs);\n        const now = Date.now();\n        return Number.isFinite(exp) && now < exp;\n    }\n\n    static parseCert(pemCert) {\n        const secureContext = tls.createSecureContext({\n            cert: pemCert\n        });\n        const sock = new tls.TLSSocket(new net.Socket(), { secureContext });\n        const cert = sock.getCertificate();\n        sock.destroy();\n        return cert;\n    }\n\n    static getSubjRDNValue(rdn, key) {\n        if (rdn == null) {\n            return null;\n        }\n        const prefix = key + ':';\n        if (!Array.isArray(rdn)) {\n            rdn = [ rdn ];\n        }\n        for(let kv of rdn) {\n            if (typeof kv !== 'string') {\n                throw NoSQLAuthorizationError.illegalState('Invalid RDN \\\nvalue in instance certificate subject name: ' + util.inspect(kv));\n            }\n            if (kv.startsWith(prefix)) {\n                return kv.substring(prefix.length);\n            }\n        }\n        return null;\n    }\n\n    static getTenantIdFromInstanceCert(cert) {\n        if (cert.subject == null) {\n            throw NoSQLAuthorizationError.illegalState('Invalid instance \\\ncertificate, missing subject');\n        }\n        let tenantId = this.getSubjRDNValue(cert.subject.OU, 'opc-tenant');\n        if (tenantId == null) {\n            tenantId = this.getSubjRDNValue(cert.subject.O, 'opc-identity');\n        }\n        if (tenantId == null) {\n            throw NoSQLAuthorizationError.illegalState('Instance certificate \\\ndoes not contain tenant id');\n        }\n        return tenantId;\n    }\n\n    static generateRSAKeyPair() {\n        return new Promise((resolve, reject) => {\n            crypto.generateKeyPair('rsa', { modulusLength: 2048 },\n                (err, publicKey, privateKey) => {\n                    if (err) {\n                        return reject(err);\n                    }\n                    return resolve({ publicKey, privateKey });\n                });\n        });\n    }\n\n    static pemCert2derB64(pem) {\n        //remove header and footer\n        return pem.replace('-----BEGIN CERTIFICATE-----', '')\n            .replace('-----END CERTIFICATE-----', '');\n    }\n\n    static pemCert2der(pem) {\n        return Buffer.from(Utils.pemCert2derB64(pem), 'base64');\n    }\n\n    static sha256digest(data) {\n        const hash = crypto.createHash('sha256');\n        hash.update(data);\n        return hash.digest('base64');\n    }\n\n    static fingerprintFromPemCert(pemCert) {\n        const derCert = Utils.pemCert2der(pemCert);\n        const hash = crypto.createHash('sha1');\n        hash.update(derCert);\n        const raw = hash.digest('hex');\n        return raw.match(/.{2}/g).join(':');\n    }\n}\n\nmodule.exports = Utils;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}