{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst assert = require('assert');\nconst HttpClient = require('./http_client');\nconst ops = require('./ops');\nconst TableState = require('./constants').TableState;\nconst AdminState = require('./constants').AdminState;\nconst ServiceType = require('./constants').ServiceType;\nconst ErrorCode = require('./error_code');\nconst NoSQLTimeoutError = require('./error').NoSQLTimeoutError;\nconst NoSQLProtocolError = require('./error').NoSQLProtocolError;\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst Config = require('./config');\nconst sleep = require('./utils').sleep;\nconst replaceObject = require('./utils').replaceObject;\nconst PreparedStatement = require('./stmt').PreparedStatement;\nconst QueryPlanExecutor = require('./query/common').QueryPlanExecutor;\nconst NoSQLError = require('./error').NoSQLError;\n\n//Default timeout for admin list operations such as listNamespaces, listUsers,\n//listRoles.\nconst DEF_ADMIN_LIST_TIMEOUT = 30000;\n\n//Default limit for table usage iterable. The value is set to 24 hours of\n//1-minute usage records.\nconst DEF_TABLE_USAGE_LIMIT = 1440;\nclass NoSQLClientImpl extends EventEmitter {\n  constructor(config) {\n    super();\n    this._config = Config.create(config);\n    this._client = new HttpClient(this._config);\n    //Forward all events from the _client.\n    this.on('newListener', (event, listener) => {\n      this._client.on(event, listener);\n    });\n    this.on('removeListener', (event, listener) => {\n      this._client.removeListener(event, listener);\n    });\n    //To prevent throwing if no error events are registered.\n    //We should log the error in this listener.\n    this.on('error', () => {});\n  }\n  _assignOpt(opt, addOpt) {\n    if (opt == null) {\n      return addOpt;\n    }\n    //We don't throw here because we want the error to be handled\n    //asynchronously.  If a user passes invalid opt which is not\n    //an object, we just return it and pass it to asynchronous code\n    //for validation.\n    if (typeof opt !== 'object') {\n      return opt;\n    }\n    return Object.assign({}, opt, addOpt);\n  }\n\n  //Used by _forTableState, _forLocalReplicaInit and _forAdminCompletion.\n  _doPollOpDelay(req, poReq, startTime) {\n    if (req.opt.timeout !== Infinity) {\n      const remaining = startTime + req.opt.timeout - (Date.now() + req.opt.delay);\n      //Fail if we are less than opt.delay ahead of timing out.\n      if (remaining <= 0) {\n        throw new NoSQLTimeoutError(req.opt.timeout, null, req);\n      }\n      //Make sure timeout of poll op request (poReq) does not go past\n      //total poll timeout.\n      if (poReq.opt.timeout > remaining) {\n        poReq.opt.timeout = remaining;\n      }\n    }\n    return sleep(req.opt.delay);\n  }\n  async _forTableState(table, tableState, opt, skipInit) {\n    const req = {\n      api: typeof table === 'string' ? this.forTableState : this.forCompletion,\n      table,\n      tableState,\n      opt\n    };\n\n    //If called from _withCompletion, the work below was already done on\n    //the original request.  In addition this check avoids throwing wrong\n    //error if remaining timeout < pollDelay.  Same applies to\n    //_forAdminCompletion().\n    if (!skipInit) {\n      ops.PollTableStateOp.applyDefaults(req, this._config);\n      ops.PollTableStateOp.validate(req);\n    }\n\n    // Should be set by PollTableStateOp.applyDefaults() above or from\n    // _withCompletion().\n    assert(req.opt != null);\n\n    //For forCompletion(), when table is TableResult, return if already\n    //reached desired state.\n    if (req.api === this.forCompletion && table.tableState === tableState) {\n      return table;\n    }\n\n    //Request for GetTableOp.\n    const gtReq = {\n      api: req.api,\n      table,\n      opt: {\n        compartment: req.opt.compartment,\n        timeout: Math.min(this._config.timeout, req.opt.timeout)\n      }\n    };\n    const startTime = Date.now();\n    for (;;) {\n      try {\n        const res = await this._execute(ops.GetTableOp, gtReq);\n        if (res.tableState === req.tableState) {\n          return res;\n        }\n      } catch (err) {\n        if (err.errorCode === ErrorCode.TABLE_NOT_FOUND && req.tableState === TableState.DROPPED) {\n          const res = {\n            tableName: gtReq.tableName,\n            tableState: TableState.DROPPED\n          };\n          //In this case onResult was not called by _execute above.\n          ops.PollTableStateOp.onResult(this, req, res);\n          return res;\n        }\n        throw err;\n      }\n      await this._doPollOpDelay(req, gtReq, startTime);\n    }\n  }\n  async _forLocalReplicaInit(table, opt) {\n    const req = {\n      api: this.forLocalReplicaInit,\n      table,\n      opt\n    };\n    if (this._config.serviceType !== ServiceType.CLOUD) {\n      throw NoSQLError.create(ErrorCode.OPERATION_NOT_SUPPORTED, \"forLocalReplicaInit is not supported for service type \".concat(this._config.serviceType, \" (requires Cloud Service)\"), null, req);\n    }\n    ops.PollTableOp.applyDefaults(req, this._config);\n    ops.PollTableOp.validate(req);\n    assert(req.opt != null);\n\n    //Request for GetTableOp.\n    const gtReq = {\n      api: req.api,\n      table,\n      opt: {\n        compartment: req.opt.compartment,\n        timeout: Math.min(this._config.timeout, req.opt.timeout)\n      }\n    };\n    const startTime = Date.now();\n    for (;;) {\n      const res = await this._execute(ops.GetTableOp, gtReq);\n      if (res.isLocalReplicaInitialized) {\n        return res;\n      }\n      await this._doPollOpDelay(req, gtReq, startTime);\n    }\n  }\n  async *_tableUsageIterable(tableName, opt) {\n    if (opt == null) {\n      opt = {};\n    } else if (typeof opt === 'object') {\n      opt = Object.assign({}, opt);\n      opt.startIndex = undefined;\n    }\n    if (opt.limit == null) {\n      opt.limit = DEF_TABLE_USAGE_LIMIT;\n    }\n    let res;\n    do {\n      res = await this.getTableUsage(tableName, opt);\n      if (!res.usageRecords.length) {\n        break;\n      }\n      opt.startIndex = res.nextIndex;\n      yield res;\n    } while (res.usageRecords.length === opt.limit);\n  }\n  async _getIndex(tableName, indexName, opt) {\n    const req = {\n      api: this.getIndex,\n      tableName,\n      opt\n    };\n    req.opt = this._assignOpt(opt, {\n      indexName\n    });\n    const res = await this._client.execute(ops.GetIndexesOp, req);\n    if (res.length != 1) {\n      throw new NoSQLProtocolError(\"Unexpected number of index results: \".concat(res.length), null, req);\n    }\n    return res[0];\n  }\n\n  //Note: This function is only used if opt.all is set to true and is not\n  //fully implemented yet to account for throttling errors.  Reserved for\n  //future use.\n  async _deleteRangeAll(tableName, key, opt) {\n    const req = {\n      api: this.deleteRange,\n      tableName,\n      key,\n      opt\n    };\n    //Accumulate deletedCount and consumedCapacity\n    const total = {\n      deletedCount: 0,\n      consumedCapacity: this._config.serviceType !== ServiceType.KVSTORE ? {\n        readKB: 0,\n        readUnits: 0,\n        writeKB: 0,\n        writeUnits: 0\n      } : null\n    };\n    for (;;) {\n      const res = await this._client.execute(ops.MultiDeleteOp, req);\n      assert(res.deletedCount != null);\n      assert(res.consumedCapacity != null || total.consumedCapacity == null);\n      total.deletedCount += res.deletedCount;\n      if (total.consumedCapacity) {\n        for (let key in total.consumedCapacity) {\n          total.consumedCapacity[key] += res.consumedCapacity[key];\n        }\n      }\n      if (!res.continuationKey) {\n        res.deletedCount = total.deletedCount;\n        if (total.consumedCapacity) {\n          Object.assign(res.consumedCapacity, total.consumedCapacity);\n        }\n        return res;\n      }\n      opt.continuationKey = res.continuationKey;\n    }\n  }\n  async _prepare(stmt, opt) {\n    const res = await this._client.execute(ops.PrepareOp, {\n      api: this.prepare,\n      stmt,\n      opt\n    });\n    res.__proto__ = PreparedStatement.prototype;\n    return res;\n  }\n  async _query(stmt, opt) {\n    const req = {\n      api: this.query,\n      opt\n    };\n    let ck = opt ? opt.continuationKey : null;\n    if (ck && ck._prepStmt) {\n      req.prepStmt = ck._prepStmt;\n    } else if (typeof stmt !== 'string') {\n      req.prepStmt = stmt;\n    } else {\n      req.stmt = stmt;\n    }\n    if (!req.prepStmt) {\n      const res = await this._client.execute(ops.QueryOp, req);\n      //We always read the prepared statement if the request does not\n      //have it.\n      assert(res._prepStmt);\n      //Simple query may already have results, so we just return them.\n      if (!res._prepStmt._queryPlan) {\n        return res;\n      }\n\n      //Advanced query will have no results in this case, only the\n      //prepared statement. To make it more intuitive for the user, we\n      //execute the first prepared query call.\n      req.prepStmt = res._prepStmt;\n      req.stmt = undefined;\n      ck = res.continuationKey;\n      assert(ck); //see QueryOp.onResult()\n      assert(req.opt); //see Op.applyDefaults()\n      req.opt.continuationKey = ck;\n    }\n\n    //Advanced query.\n    if (req.prepStmt._queryPlan) {\n      let qpExec = ck ? ck._qpExec : null;\n      if (!qpExec) {\n        //First advanced query call, create plan executor.\n        qpExec = new QueryPlanExecutor(this, req.prepStmt);\n      }\n      return qpExec.execute(req);\n    }\n\n    //Simple query.\n    return this._client.execute(ops.QueryOp, req);\n  }\n  async *_queryIterable(stmt, opt) {\n    if (opt == null) {\n      opt = {};\n    } else if (typeof opt === 'object') {\n      opt = Object.assign({}, opt);\n      opt.continuationKey = undefined;\n    }\n    do {\n      const res = await this.query(stmt, opt);\n      opt.continuationKey = res.continuationKey;\n      yield res;\n    } while (opt.continuationKey);\n  }\n  _execute(op, req) {\n    return this._client.execute(op, req);\n  }\n  async _adminStatus(req) {\n    if (req.adminResult != null && req.adminResult.operationId == null) {\n      //still validate options passed for correctness\n      ops.AdminStatusOp.applyDefaults(req, this._config);\n      ops.AdminStatusOp.validate(req);\n      return req.adminResult;\n    }\n    return this._execute(ops.AdminStatusOp, req);\n  }\n  async _forAdminCompletion(adminResult, opt, skipInit) {\n    const req = {\n      api: this.forCompletion,\n      adminResult,\n      opt\n    };\n    if (!skipInit) {\n      ops.AdminPollOp.applyDefaults(req, this._config);\n      ops.AdminPollOp.validate(req);\n    }\n\n    // Should be set by AdminPollOp.applyDefaults() above or from\n    // _withCompletion().\n    assert(req.opt != null);\n    if (adminResult.state === AdminState.COMPLETE) {\n      return adminResult;\n    }\n\n    //Request for AdminStatusOp.\n    const asReq = {\n      api: req.api,\n      adminResult,\n      opt: {\n        timeout: Math.min(this._config.timeout, req.opt.timeout)\n      }\n    };\n    const startTime = Date.now();\n    for (;;) {\n      const res = await this._execute(ops.AdminStatusOp, asReq);\n      if (res.state === AdminState.COMPLETE) {\n        return res;\n      }\n      await this._doPollOpDelay(req, asReq, startTime);\n    }\n  }\n  async _forCompletion(res, opt, skipInit) {\n    let ret;\n    if (res == null) {\n      throw new NoSQLArgumentError('forCompletion: missing result object');\n    }\n    if (res._forAdmin) {\n      ret = await this._forAdminCompletion(res, opt, skipInit);\n    } else {\n      const isDropTable = typeof res._stmt === 'string' && res._stmt.match(/^\\s*DROP\\s+TABLE\\s+/i);\n      ret = await this._forTableState(res, isDropTable ? TableState.DROPPED : TableState.ACTIVE, opt, skipInit);\n    }\n    return replaceObject(res, ret);\n  }\n  async _withCompletion(op, req) {\n    const startTime = Date.now();\n    const res = await this._execute(op, req);\n\n    //This initialization would be done by _execute() above.\n    assert(req.opt != null && req.opt.__proto__ === this._config);\n    let timeOut = req.opt._ownsTimeout ? req.opt.timeout : this._config.tablePollTimeout;\n    if (timeOut !== Infinity) {\n      timeOut -= Date.now() - startTime;\n    }\n    req.opt.timeout = Math.max(timeOut, 1);\n    return this._forCompletion(res, req.opt, true);\n  }\n  async _adminListOp(opName, stmt, req) {\n    const listOpt = {\n      complete: true,\n      timeout: DEF_ADMIN_LIST_TIMEOUT\n    };\n    if (req.opt == null) {\n      req.opt = listOpt;\n    } else if (typeof req.opt === 'object') {\n      //if typeof opt !== 'object', it will be passed to adminDDL\n      //and throw during validation\n      req.opt = Object.assign(listOpt, req.opt);\n    }\n    let res = await this.adminDDL(stmt, req.opt);\n    if (res.output == null) {\n      throw new NoSQLProtocolError(\"Missing output for \".concat(opName), null, req);\n    }\n    try {\n      res = JSON.parse(res.output);\n    } catch (err) {\n      throw new NoSQLProtocolError(\"Error parsing output for \".concat(opName), null, req);\n    }\n    if (res == null || typeof res !== 'object') {\n      throw new NoSQLProtocolError(\"Invalid output for \".concat(opName), null, req);\n    }\n    return res;\n  }\n  async _listNamespaces(opt) {\n    const req = {\n      //will be included in any thrown errors\n      api: this.listNamespaces,\n      opt\n    };\n    const res = await this._adminListOp('listNamespaces', 'SHOW AS JSON NAMESPACES', req);\n    if (res.namespaces == null) {\n      return [];\n    }\n    if (!Array.isArray(res.namespaces) || res.namespaces.findIndex(el => typeof el !== 'string') !== -1) {\n      throw new NoSQLProtocolError('Invalid namespaces array in \\\nthe output for listNamespaces operation', null, req);\n    }\n    return res.namespaces;\n  }\n  async _listUsers(opt) {\n    const req = {\n      //will be included in any thrown errors\n      api: this.listUsers,\n      opt\n    };\n    const res = await this._adminListOp('listUsers', 'SHOW AS JSON USERS', req);\n    if (res.users == null) {\n      return [];\n    }\n    if (!Array.isArray(res.users)) {\n      throw new NoSQLProtocolError('Invalid users array in the output \\\nfor listUsers operation', null, req);\n    }\n    return res.users.map(user => {\n      if (user == null || typeof user !== 'object' || typeof user.id !== 'string' || typeof user.name !== 'string') {\n        throw new NoSQLProtocolError('Invalid value in the users \\\narray in the output for listUsers operation', null, req);\n      }\n      return {\n        id: user.id,\n        name: user.name\n      };\n    });\n  }\n  async _listRoles(opt) {\n    const req = {\n      //will be included in any thrown errors\n      api: this.listRoles,\n      opt\n    };\n    const res = await this._adminListOp('listRoles', 'SHOW AS JSON ROLES', req);\n    if (res.roles == null) {\n      return [];\n    }\n    if (!Array.isArray(res.roles)) {\n      throw new NoSQLProtocolError('Invalid roles array in the output \\\nfor listRoles operation', null, req);\n    }\n    return res.roles.map(role => {\n      if (role == null || typeof role !== 'object' || typeof role.name !== 'string') {\n        throw new NoSQLProtocolError('Invalid value in the roles \\\narray in the output for listRoles operation', null, req);\n      }\n      return role.name;\n    });\n  }\n\n  //used for testing\n  get _serialVersion() {\n    return this._client.serialVersion;\n  }\n  close() {\n    this._client.shutdown();\n    return Promise.resolve(Config.destroy(this._config));\n  }\n  async _precacheAuth() {\n    await this._config.auth.provider.getAuthorization({\n      opt: {\n        __proto__: this._config\n      },\n      lastError: new NoSQLError(ErrorCode.INVALID_AUTHORIZATION),\n      _op: ops.GetTableOp\n    });\n    return this;\n  }\n}\nmodule.exports = NoSQLClientImpl;","map":{"version":3,"names":["EventEmitter","require","assert","HttpClient","ops","TableState","AdminState","ServiceType","ErrorCode","NoSQLTimeoutError","NoSQLProtocolError","NoSQLArgumentError","Config","sleep","replaceObject","PreparedStatement","QueryPlanExecutor","NoSQLError","DEF_ADMIN_LIST_TIMEOUT","DEF_TABLE_USAGE_LIMIT","NoSQLClientImpl","constructor","config","_config","create","_client","on","event","listener","removeListener","_assignOpt","opt","addOpt","Object","assign","_doPollOpDelay","req","poReq","startTime","timeout","Infinity","remaining","Date","now","delay","_forTableState","table","tableState","skipInit","api","forTableState","forCompletion","PollTableStateOp","applyDefaults","validate","gtReq","compartment","Math","min","res","_execute","GetTableOp","err","errorCode","TABLE_NOT_FOUND","DROPPED","tableName","onResult","_forLocalReplicaInit","forLocalReplicaInit","serviceType","CLOUD","OPERATION_NOT_SUPPORTED","concat","PollTableOp","isLocalReplicaInitialized","_tableUsageIterable","startIndex","undefined","limit","getTableUsage","usageRecords","length","nextIndex","_getIndex","indexName","getIndex","execute","GetIndexesOp","_deleteRangeAll","key","deleteRange","total","deletedCount","consumedCapacity","KVSTORE","readKB","readUnits","writeKB","writeUnits","MultiDeleteOp","continuationKey","_prepare","stmt","PrepareOp","prepare","__proto__","prototype","_query","query","ck","_prepStmt","prepStmt","QueryOp","_queryPlan","qpExec","_qpExec","_queryIterable","op","_adminStatus","adminResult","operationId","AdminStatusOp","_forAdminCompletion","AdminPollOp","state","COMPLETE","asReq","_forCompletion","ret","_forAdmin","isDropTable","_stmt","match","ACTIVE","_withCompletion","timeOut","_ownsTimeout","tablePollTimeout","max","_adminListOp","opName","listOpt","complete","adminDDL","output","JSON","parse","_listNamespaces","listNamespaces","namespaces","Array","isArray","findIndex","el","_listUsers","listUsers","users","map","user","id","name","_listRoles","listRoles","roles","role","_serialVersion","serialVersion","close","shutdown","Promise","resolve","destroy","_precacheAuth","auth","provider","getAuthorization","lastError","INVALID_AUTHORIZATION","_op","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/nosql_client_impl.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst assert = require('assert');\nconst HttpClient = require('./http_client');\n\nconst ops = require('./ops');\n\nconst TableState = require('./constants').TableState;\nconst AdminState = require('./constants').AdminState;\nconst ServiceType = require('./constants').ServiceType;\nconst ErrorCode = require('./error_code');\nconst NoSQLTimeoutError = require('./error').NoSQLTimeoutError;\nconst NoSQLProtocolError = require('./error').NoSQLProtocolError;\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst Config = require('./config');\nconst sleep = require('./utils').sleep;\nconst replaceObject = require('./utils').replaceObject;\nconst PreparedStatement = require('./stmt').PreparedStatement;\nconst QueryPlanExecutor = require('./query/common').QueryPlanExecutor;\nconst NoSQLError = require('./error').NoSQLError;\n\n//Default timeout for admin list operations such as listNamespaces, listUsers,\n//listRoles.\nconst DEF_ADMIN_LIST_TIMEOUT = 30000;\n\n//Default limit for table usage iterable. The value is set to 24 hours of\n//1-minute usage records.\nconst DEF_TABLE_USAGE_LIMIT = 1440;\n\nclass NoSQLClientImpl extends EventEmitter {\n\n    constructor(config) {\n        super();\n        this._config = Config.create(config);\n        this._client = new HttpClient(this._config);\n        //Forward all events from the _client.\n        this.on('newListener', (event, listener) => {\n            this._client.on(event, listener);\n        });\n        this.on('removeListener', (event, listener) => {\n            this._client.removeListener(event, listener);\n        });\n        //To prevent throwing if no error events are registered.\n        //We should log the error in this listener.\n        this.on('error', () => {});\n    }\n\n    _assignOpt(opt, addOpt) {\n        if (opt == null) {\n            return addOpt;\n        }\n        //We don't throw here because we want the error to be handled\n        //asynchronously.  If a user passes invalid opt which is not\n        //an object, we just return it and pass it to asynchronous code\n        //for validation.\n        if (typeof opt !== 'object') {\n            return opt;\n        }\n        return Object.assign({}, opt, addOpt);\n    }\n\n    //Used by _forTableState, _forLocalReplicaInit and _forAdminCompletion.\n    _doPollOpDelay(req, poReq, startTime) {\n        if (req.opt.timeout !== Infinity) {\n            const remaining = startTime + req.opt.timeout -\n                (Date.now() + req.opt.delay);\n            //Fail if we are less than opt.delay ahead of timing out.\n            if (remaining <= 0) {\n                throw new NoSQLTimeoutError(req.opt.timeout, null, req);\n            }\n            //Make sure timeout of poll op request (poReq) does not go past\n            //total poll timeout.\n            if (poReq.opt.timeout > remaining) {\n                poReq.opt.timeout = remaining;\n            }\n        }\n        return sleep(req.opt.delay);\n    }\n\n    async _forTableState(table, tableState, opt, skipInit) {\n        const req = {\n            api: typeof table === 'string' ? this.forTableState :\n                this.forCompletion,\n            table,\n            tableState,\n            opt\n        };\n\n        //If called from _withCompletion, the work below was already done on\n        //the original request.  In addition this check avoids throwing wrong\n        //error if remaining timeout < pollDelay.  Same applies to\n        //_forAdminCompletion().\n        if (!skipInit) {\n            ops.PollTableStateOp.applyDefaults(req, this._config);\n            ops.PollTableStateOp.validate(req);\n        }\n\n        // Should be set by PollTableStateOp.applyDefaults() above or from\n        // _withCompletion().\n        assert(req.opt != null);\n\n        //For forCompletion(), when table is TableResult, return if already\n        //reached desired state.\n        if (req.api === this.forCompletion &&\n            table.tableState === tableState) {\n            return table;\n        }\n\n        //Request for GetTableOp.\n        const gtReq = {\n            api: req.api,\n            table,\n            opt: {\n                compartment: req.opt.compartment,\n                timeout: Math.min(this._config.timeout, req.opt.timeout)\n            }\n        };\n        \n        const startTime = Date.now();\n        for(;;) {\n            try {\n                const res = await this._execute(ops.GetTableOp, gtReq);\n                if (res.tableState === req.tableState) {\n                    return res;\n                }\n            } catch(err) {\n                if (err.errorCode === ErrorCode.TABLE_NOT_FOUND &&\n                    req.tableState === TableState.DROPPED) {\n                    const res = {\n                        tableName: gtReq.tableName,\n                        tableState: TableState.DROPPED\n                    };\n                    //In this case onResult was not called by _execute above.\n                    ops.PollTableStateOp.onResult(this, req, res);\n                    return res;\n                }\n                throw err;\n            }\n            await this._doPollOpDelay(req, gtReq, startTime);\n        }\n    }\n\n    async _forLocalReplicaInit(table, opt) {\n        const req = {\n            api: this.forLocalReplicaInit,\n            table,\n            opt\n        };\n\n        if (this._config.serviceType !== ServiceType.CLOUD) {\n            throw NoSQLError.create(ErrorCode.OPERATION_NOT_SUPPORTED,\n                `forLocalReplicaInit is not supported for service type \\\n${this._config.serviceType} (requires Cloud Service)`, null, req);\n        }\n\n        ops.PollTableOp.applyDefaults(req, this._config);\n        ops.PollTableOp.validate(req);\n        assert(req.opt != null);\n\n        //Request for GetTableOp.\n        const gtReq = {\n            api: req.api,\n            table,\n            opt: {\n                compartment: req.opt.compartment,\n                timeout: Math.min(this._config.timeout, req.opt.timeout)\n            }\n        };\n        \n        const startTime = Date.now();\n        for(;;) {\n            const res = await this._execute(ops.GetTableOp, gtReq);\n            if (res.isLocalReplicaInitialized) {\n                return res;\n            }\n            await this._doPollOpDelay(req, gtReq, startTime);\n        }\n    }\n\n    async * _tableUsageIterable(tableName, opt) {\n        if (opt == null) {\n            opt = {};\n        } else if (typeof opt === 'object') {\n            opt = Object.assign({}, opt);\n            opt.startIndex = undefined;\n        }\n        if (opt.limit == null) {\n            opt.limit = DEF_TABLE_USAGE_LIMIT;\n        }\n        let res;\n        do {\n            res = await this.getTableUsage(tableName, opt);\n            if (!res.usageRecords.length) {\n                break;\n            }\n            opt.startIndex = res.nextIndex;\n            yield res;\n        } while(res.usageRecords.length === opt.limit);\n    }\n\n    async _getIndex(tableName, indexName, opt) {\n        const req = {\n            api: this.getIndex,\n            tableName,\n            opt\n        };\n        req.opt = this._assignOpt(opt, { indexName });\n        const res = await this._client.execute(ops.GetIndexesOp, req);\n        if (res.length != 1) {\n            throw new NoSQLProtocolError(\n                `Unexpected number of index results: ${res.length}`,\n                null, req);\n        }\n        return res[0];\n    }\n\n    //Note: This function is only used if opt.all is set to true and is not\n    //fully implemented yet to account for throttling errors.  Reserved for\n    //future use.\n    async _deleteRangeAll(tableName, key, opt) {\n        const req = {\n            api: this.deleteRange,\n            tableName,\n            key,\n            opt\n        };\n        //Accumulate deletedCount and consumedCapacity\n        const total = {\n            deletedCount: 0,\n            consumedCapacity: \n                this._config.serviceType !== ServiceType.KVSTORE ? {\n                    readKB: 0,\n                    readUnits: 0,\n                    writeKB: 0,\n                    writeUnits: 0\n                } : null\n        };\n\n        for(;;) {\n            const res = await this._client.execute(ops.MultiDeleteOp, req);\n            assert(res.deletedCount != null);\n            assert(res.consumedCapacity != null ||\n                total.consumedCapacity == null);\n            total.deletedCount += res.deletedCount;\n            if (total.consumedCapacity) {\n                for(let key in total.consumedCapacity) {\n                    total.consumedCapacity[key] += res.consumedCapacity[key];\n                }\n            }\n            if (!res.continuationKey) {\n                res.deletedCount = total.deletedCount;\n                if (total.consumedCapacity) {\n                    Object.assign(res.consumedCapacity,\n                        total.consumedCapacity);\n                }\n                return res;\n            }\n            opt.continuationKey = res.continuationKey;\n        }\n    }\n\n    async _prepare(stmt, opt) {\n        const res = await this._client.execute(ops.PrepareOp, {\n            api: this.prepare,\n            stmt,\n            opt\n        });\n        res.__proto__ = PreparedStatement.prototype;\n        return res;\n    }\n\n    async _query(stmt, opt) {\n        const req = {\n            api: this.query,\n            opt\n        };\n\n        let ck = opt ? opt.continuationKey : null;\n        if (ck && ck._prepStmt) {\n            req.prepStmt = ck._prepStmt;\n        } else if (typeof stmt !== 'string') {\n            req.prepStmt = stmt;\n        } else {\n            req.stmt = stmt;\n        }\n\n        if (!req.prepStmt) {\n            const res = await this._client.execute(ops.QueryOp, req);\n            //We always read the prepared statement if the request does not\n            //have it.\n            assert(res._prepStmt);\n            //Simple query may already have results, so we just return them.\n            if (!res._prepStmt._queryPlan) {\n                return res;\n            }\n\n            //Advanced query will have no results in this case, only the\n            //prepared statement. To make it more intuitive for the user, we\n            //execute the first prepared query call.\n            req.prepStmt = res._prepStmt;\n            req.stmt = undefined;\n            ck = res.continuationKey;\n            assert(ck); //see QueryOp.onResult()\n            assert(req.opt); //see Op.applyDefaults()\n            req.opt.continuationKey = ck;\n        }\n\n        //Advanced query.\n        if (req.prepStmt._queryPlan) {\n            let qpExec = ck ? ck._qpExec : null;\n            if (!qpExec) {\n                //First advanced query call, create plan executor.\n                qpExec = new QueryPlanExecutor(this, req.prepStmt);\n            }\n            return qpExec.execute(req);\n        }\n\n        //Simple query.\n        return this._client.execute(ops.QueryOp, req);\n    }\n\n    async * _queryIterable(stmt, opt) {\n        if (opt == null) {\n            opt = {};\n        } else if (typeof opt === 'object') {\n            opt = Object.assign({}, opt);\n            opt.continuationKey = undefined;\n        }\n        \n        do {\n            const res = await this.query(stmt, opt);\n            opt.continuationKey = res.continuationKey;\n            yield res;\n        } while(opt.continuationKey);\n    }\n\n    _execute(op, req) {\n        return this._client.execute(op, req);\n    }\n\n    async _adminStatus(req) {\n        if (req.adminResult != null && req.adminResult.operationId == null) {\n            //still validate options passed for correctness\n            ops.AdminStatusOp.applyDefaults(req, this._config);\n            ops.AdminStatusOp.validate(req);\n            return req.adminResult;\n        }\n        return this._execute(ops.AdminStatusOp, req);\n    }\n\n    async _forAdminCompletion(adminResult, opt, skipInit) {\n        const req = {\n            api: this.forCompletion,\n            adminResult,\n            opt\n        };\n\n        if (!skipInit) {\n            ops.AdminPollOp.applyDefaults(req, this._config);\n            ops.AdminPollOp.validate(req);\n        }\n\n        // Should be set by AdminPollOp.applyDefaults() above or from\n        // _withCompletion().\n        assert(req.opt != null);\n\n        if (adminResult.state === AdminState.COMPLETE) {\n            return adminResult;\n        }\n\n        //Request for AdminStatusOp.\n        const asReq = {\n            api: req.api,\n            adminResult,\n            opt: {\n                timeout: Math.min(this._config.timeout, req.opt.timeout)\n            }\n        };\n\n        const startTime = Date.now();\n        for(;;) {\n            const res = await this._execute(ops.AdminStatusOp, asReq);\n            if (res.state === AdminState.COMPLETE) {\n                return res;\n            }\n            await this._doPollOpDelay(req, asReq, startTime);\n        }\n    }\n\n    async _forCompletion(res, opt, skipInit) {\n        let ret;\n        if (res == null) {\n            throw new NoSQLArgumentError(\n                'forCompletion: missing result object');\n        }\n        if (res._forAdmin) {\n            ret = await this._forAdminCompletion(res, opt, skipInit);\n        } else {\n            const isDropTable = typeof res._stmt === 'string' &&\n                res._stmt.match(/^\\s*DROP\\s+TABLE\\s+/i);\n            ret = await this._forTableState(res, isDropTable ?\n                TableState.DROPPED : TableState.ACTIVE, opt, skipInit);\n        }\n        return replaceObject(res, ret);\n    }\n\n    async _withCompletion(op, req) {\n        const startTime = Date.now();\n        const res = await this._execute(op, req);\n\n        //This initialization would be done by _execute() above.\n        assert(req.opt != null && req.opt.__proto__ === this._config);\n        \n        let timeOut = req.opt._ownsTimeout ?\n            req.opt.timeout : this._config.tablePollTimeout;\n        if (timeOut !== Infinity) {\n            timeOut -= (Date.now() - startTime);\n        }\n\n        req.opt.timeout = Math.max(timeOut, 1);\n        return this._forCompletion(res, req.opt, true);\n    }\n\n    async _adminListOp(opName, stmt, req) {\n        const listOpt = {\n            complete: true,\n            timeout: DEF_ADMIN_LIST_TIMEOUT\n        };\n        if (req.opt == null) {\n            req.opt = listOpt;\n        } else if (typeof req.opt === 'object') {\n            //if typeof opt !== 'object', it will be passed to adminDDL\n            //and throw during validation\n            req.opt = Object.assign(listOpt, req.opt);\n        }\n        let res = await this.adminDDL(stmt, req.opt);\n        if (res.output == null) {\n            throw new NoSQLProtocolError(`Missing output for ${opName}`, null,\n                req);\n        }\n        try {\n            res = JSON.parse(res.output);\n        } catch(err) {\n            throw new NoSQLProtocolError(`Error parsing output for \\\n${opName}`, null, req);\n        }\n        if (res == null || typeof res !== 'object') {\n            throw new NoSQLProtocolError(`Invalid output for ${opName}`, null,\n                req);\n        }\n        return res;\n    }\n\n    async _listNamespaces(opt) {\n        const req = { //will be included in any thrown errors\n            api: this.listNamespaces,\n            opt\n        };\n        const res = await this._adminListOp('listNamespaces',\n            'SHOW AS JSON NAMESPACES', req);\n        if (res.namespaces == null) {\n            return [];\n        }\n        if (!Array.isArray(res.namespaces) || res.namespaces.findIndex(\n            el => typeof el !== 'string') !== -1) {\n            throw new NoSQLProtocolError('Invalid namespaces array in \\\nthe output for listNamespaces operation', null, req);\n        }\n        return res.namespaces;\n    }\n\n    async _listUsers(opt) {\n        const req = { //will be included in any thrown errors\n            api: this.listUsers,\n            opt\n        };\n        const res = await this._adminListOp('listUsers', 'SHOW AS JSON USERS',\n            req);\n        if (res.users == null) {\n            return [];\n        }\n        if (!Array.isArray(res.users)) {\n            throw new NoSQLProtocolError('Invalid users array in the output \\\nfor listUsers operation', null, req);\n        }\n        return res.users.map(user => {\n            if (user == null || typeof user !== 'object' ||\n            typeof user.id !== 'string' || typeof user.name !== 'string') {\n                throw new NoSQLProtocolError('Invalid value in the users \\\narray in the output for listUsers operation', null, req);\n            }\n            return {\n                id: user.id,\n                name: user.name\n            };\n        });\n    }\n\n    async _listRoles(opt) {\n        const req = { //will be included in any thrown errors\n            api: this.listRoles,\n            opt\n        };\n        const res = await this._adminListOp('listRoles', 'SHOW AS JSON ROLES',\n            req);\n        if (res.roles == null) {\n            return [];\n        }\n        if (!Array.isArray(res.roles)) {\n            throw new NoSQLProtocolError('Invalid roles array in the output \\\nfor listRoles operation', null, req);\n        }\n        return res.roles.map(role => {\n            if (role == null || typeof role !== 'object' ||\n            typeof role.name !== 'string') {\n                throw new NoSQLProtocolError('Invalid value in the roles \\\narray in the output for listRoles operation', null, req);\n            }\n            return role.name;\n        });\n    }\n\n    //used for testing\n    get _serialVersion() {\n        return this._client.serialVersion;\n    }\n\n    close() {\n        this._client.shutdown();\n        return Promise.resolve(Config.destroy(this._config));\n    }\n\n    async _precacheAuth() {\n        await this._config.auth.provider.getAuthorization({\n            opt: {\n                __proto__: this._config\n            },\n            lastError: new NoSQLError(ErrorCode.INVALID_AUTHORIZATION),\n            _op: ops.GetTableOp\n        });\n        return this;\n    }\n    \n}\n\nmodule.exports = NoSQLClientImpl;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}