{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst isInt32 = require('../utils').isInt32;\nconst TableState = require('../constants').TableState;\nconst AdminState = require('../constants').AdminState;\nconst ServiceType = require('../constants').ServiceType;\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst CapacityMode = require('../constants').CapacityMode;\nconst Region = require('../region');\nconst Type = require('../binary_protocol/constants').Type;\nconst MathContext = require('../binary_protocol/constants').MathContext;\nconst error = require('../error');\nconst NoSQLArgumentError = error.NoSQLArgumentError;\nconst NoSQLProtocolError = error.NoSQLProtocolError;\nconst BinaryProtocol = require('../binary_protocol/protocol');\nconst Fields = require('./constants').Fields;\nclass Protocol {\n  //Serialization, nw is Nson writer.\n\n  static writeHeader(nw, opCode, serialVersion, req) {\n    nw.startMapField(Fields.HEADER);\n    nw.writeIntField(Fields.VERSION, serialVersion);\n    this.checkWriteStringField(nw, Fields.TABLE_NAME, req.tableName);\n    nw.writeIntField(Fields.OP_CODE, opCode);\n    nw.writeIntField(Fields.TIMEOUT, req.opt.requestTimeout);\n    nw.writeIntField(Fields.TOPO_SEQ_NUM, req._topoInfo ? req._topoInfo.seqNum : -1);\n    nw.endMapField();\n  }\n  static checkWriteIntField(nw, name, val) {\n    if (val != null) {\n      nw.writeIntField(name, val);\n    }\n  }\n  static checkWriteLongField(nw, name, val) {\n    if (val != null) {\n      nw.writeLongField(name, val);\n    }\n  }\n  static checkWriteStringField(nw, name, val) {\n    if (val != null) {\n      nw.writeStringField(name, val);\n    }\n  }\n  static checkWriteBooleanField(nw, name, val) {\n    if (val) {\n      nw.writeBooleanField(name, val);\n    }\n  }\n  static writeConsistency(nw, cons) {\n    nw.startMapField(Fields.CONSISTENCY);\n    nw.writeIntField(Fields.TYPE, cons.ordinal);\n    nw.endMapField();\n  }\n  static writeKey(nw, key, opt) {\n    nw.writeFieldName(Fields.KEY);\n    this.writeFieldValue(nw, key, opt);\n  }\n  static writeValue(nw, val, opt) {\n    nw.writeFieldName(Fields.VALUE);\n    this.writeFieldValue(nw, val, opt);\n  }\n\n  //Assumes ttl already in canonical form, see TTLUtil#validate()\n  static ttlToString(ttl) {\n    if (ttl.days != null) {\n      return (ttl.days !== Infinity ? ttl.days : 0) + ' DAYS';\n    }\n    assert(ttl.hours != null);\n    return ttl.hours + ' HOURS';\n  }\n  static _writeMapEntries(nw, ent, opt) {\n    nw.startMap();\n    for (let [key, val] of ent) {\n      if (typeof key !== 'string') {\n        throw new NoSQLArgumentError(`Invalid map or object key for \\\nfield value: ${key}, must be a string`);\n      }\n      nw.writeFieldName(key);\n      this.writeFieldValue(nw, val, opt);\n    }\n    nw.endMap();\n  }\n  static writeMap(nw, map, opt) {\n    this._writeMapEntries(nw, map.entries(), opt);\n  }\n  static writeObject(nw, obj, opt) {\n    this._writeMapEntries(nw, Object.entries(obj), opt);\n  }\n  static writeRowVersion(nw, version) {\n    nw.writeBinaryField(Fields.ROW_VERSION, version);\n  }\n  static writeFieldRange(nw, fr, opt) {\n    nw.startMapField(Fields.RANGE);\n    nw.writeStringField(Fields.RANGE_PATH, fr.fieldName);\n    let inclusive = fr.startWith != null;\n    let val = inclusive ? fr.startWith : fr.startAfter;\n    if (val != null) {\n      nw.startMapField(Fields.START);\n      this.writeValue(nw, val, opt);\n      nw.writeBooleanField(Fields.INCLUSIVE, inclusive);\n      nw.endMapField();\n    }\n    inclusive = fr.endWith != null;\n    val = inclusive ? fr.endWith : fr.endBefore;\n    if (val != null) {\n      nw.startMapField(Fields.END);\n      this.writeValue(nw, val, opt);\n      nw.writeBooleanField(Fields.INCLUSIVE, inclusive);\n      nw.endMapField();\n    }\n    nw.endMapField();\n  }\n  static writeFieldValue(nw, val, opt) {\n    if (typeof val === 'function') {\n      //If the field specified as a function, we write its return value\n      val = val();\n    }\n    if (val === undefined) {\n      return nw.writeNull();\n    }\n    if (val === null) {\n      return nw.writeJsonNull();\n    }\n    switch (typeof val) {\n      case 'boolean':\n        nw.writeBoolean(val);\n        break;\n      case 'string':\n        nw.writeString(val);\n        break;\n      case 'number':\n        if (Number.isSafeInteger(val)) {\n          if (isInt32(val)) {\n            nw.writeInt(val);\n          } else {\n            nw.writeLong(val);\n          }\n        } else {\n          nw.writeDouble(val);\n        }\n        break;\n      case 'bigint':\n        nw.writeLong(val);\n        break;\n      case 'object':\n        if (Buffer.isBuffer(val)) {\n          nw.writeBinary(val);\n        } else if (val instanceof Date) {\n          nw.writeDate(val);\n        } else if (Array.isArray(val)) {\n          nw.startArray();\n          for (const elem of val) {\n            this.writeFieldValue(nw, elem, opt);\n          }\n          nw.endArray();\n        } else if (opt._dbNumber != null && opt._dbNumber.isInstance(val)) {\n          nw.writeStringAsNumber(opt._dbNumber.stringValue(val));\n        } else {\n          if (val instanceof Map) {\n            this.writeMap(nw, val, opt);\n          } else {\n            this.writeObject(nw, val, opt);\n          }\n        }\n        break;\n      default:\n        if (val === EMPTY_VALUE) {\n          nw.writeEmpty();\n          break;\n        }\n        throw new NoSQLArgumentError('Unsupported value type ' + `${typeof val} for value ${val.toString()}`);\n    }\n  }\n  static serializeWriteRequest(nw, req) {\n    this.writeDurability(nw, req.opt.durability);\n    nw.writeBooleanField(Fields.RETURN_ROW, req.opt.returnExisting);\n  }\n  static writeDurability(nw, dur) {\n    nw.writeIntField(Fields.DURABILITY, BinaryProtocol.durabilityToNum(dur));\n  }\n  static writeMathContext(nw, opt) {\n    if (opt._dbNumber == null) {\n      return nw.writeIntField(Fields.MATH_CONTEXT_CODE, MathContext.DEFAULT);\n    }\n    nw.writeIntField(Fields.MATH_CONTEXT_CODE, MathContext.CUSTOM);\n    nw.writeIntField(Fields.MATH_CONTEXT_PRECISION, opt._dbNumber.precision);\n    nw.writeIntField(Fields.MATH_CONTEXT_ROUNDING_MODE, opt._dbNumber.roundingMode);\n  }\n\n  //Deserialization.\n\n  static mapError(rc, msg, req) {\n    return BinaryProtocol.mapError(rc, msg, req);\n  }\n\n  //To throw correct error if received invalid value.\n  static numToEnum(val, cons, req) {\n    try {\n      return cons.fromOrdinal(val);\n    } catch (err) {\n      throw new NoSQLProtocolError(`Received invalid value of ${cons.name}: {val}`, err, req);\n    }\n  }\n\n  //Same as above.\n  static parseJSON(val, name, req) {\n    try {\n      return JSON.parse(val);\n    } catch (err) {\n      throw new NoSQLProtocolError(`Error parsing ${name}: ${err.message}`, err, req);\n    }\n  }\n  static readArray(nr, readItem, ...args) {\n    nr.expectType(Type.ARRAY);\n    const res = new Array(nr.count);\n    for (let i = 0; i < res.length; i++) {\n      nr.next();\n      //Enable readItem to use Protocol context\n      res[i] = readItem.call(this, nr, ...args);\n    }\n    return res;\n  }\n\n  //processField() takes field name as an argument.  It returns true if\n  //the field was read and processed or false if the field was ignored, in\n  //which case we will skip it.\n  //We assume processField() gets any other needed info (including the\n  //NsonReader instance) from the closure context, as this is more\n  //convenient, but we may add other overloads if required.\n  static readMap(nr, processField) {\n    nr.expectType(Type.MAP);\n    const cnt = nr.count;\n    for (let i = 0; i < cnt; i++) {\n      nr.next();\n      if (!processField(nr.field)) {\n        nr.skipValue();\n      }\n    }\n  }\n  static readDateAsLong(nr) {\n    const val = nr.readLong();\n    return val ? new Date(val) : undefined;\n  }\n  static validateTopologyInfo(topoInfo) {\n    //We don't need to validate types of seqNum and shardIds because they\n    //are read with correct types by NsonReader.\n    if (topoInfo.seqNum == null || topoInfo.seqNum < 0) {\n      throw new NoSQLProtocolError(`Received invalid topology seqNum: ${topoInfo.seqNum}`);\n    }\n    if (!topoInfo.shardIds || !topoInfo.shardIds.length) {\n      throw new NoSQLProtocolError(`Missing shard ids for topology seqNum ${topoInfo.seqNum}`);\n    }\n  }\n  static readTopologyInfo(nr) {\n    const res = {};\n    this.readMap(nr, field => {\n      switch (field) {\n        case Fields.PROXY_TOPO_SEQNUM:\n          res.seqNum = nr.readInt();\n          return true;\n        case Fields.SHARD_IDS:\n          res.shardIds = this.readArray(nr, nr => nr.readInt());\n          return true;\n        default:\n          return false;\n      }\n    });\n    this.validateTopologyInfo(res);\n    return res;\n  }\n  static readReplicaInfo(nr, req) {\n    const res = {};\n    this.readMap(nr, field => {\n      switch (field) {\n        case Fields.REGION:\n          res.replicaName = nr.readString();\n          //May be undefined for regions not yet added to region.js.\n          res.region = Region.fromRegionId(res.replicaName);\n          return true;\n        case Fields.TABLE_OCID:\n          res.replicaOCID = nr.readString();\n          return true;\n        case Fields.WRITE_UNITS:\n          res.writeUnits = nr.readInt();\n          return true;\n        case Fields.LIMITS_MODE:\n          res.capacityMode = this.numToEnum(nr.readInt(), CapacityMode, req);\n          return true;\n        case Fields.TABLE_STATE:\n          res.state = this.numToEnum(nr.readInt(), TableState, req);\n          return true;\n        default:\n          return false;\n      }\n    });\n    return res;\n  }\n  static deserializeConsumedCapacity(nr) {\n    const res = {};\n    this.readMap(nr, field => {\n      switch (field) {\n        case Fields.READ_UNITS:\n          res.readUnits = nr.readInt();\n          return true;\n        case Fields.READ_KB:\n          res.readKB = nr.readInt();\n          return true;\n        case Fields.WRITE_KB:\n          res.writeKB = nr.readInt();\n          res.writeUnits = res.writeKB;\n          return true;\n        default:\n          return false;\n      }\n    });\n    return res;\n  }\n  static deserializeResponse(nr, req, processField, res) {\n    let rc = 0;\n    let msg;\n    nr.next();\n    if (res == null) {\n      res = {};\n    }\n    this.readMap(nr, field => {\n      switch (field) {\n        case Fields.CONSUMED:\n          if (req.opt.serviceType !== ServiceType.KVSTORE) {\n            res.consumedCapacity = this.deserializeConsumedCapacity(nr);\n            return true;\n          }\n          return false;\n        case Fields.ERROR_CODE:\n          rc = nr.readInt();\n          return true;\n        case Fields.EXCEPTION:\n          msg = nr.readString();\n          return true;\n        case Fields.TOPOLOGY_INFO:\n          res._topoInfo = this.readTopologyInfo(nr);\n          return true;\n        default:\n          return processField(field, res);\n      }\n    });\n    if (rc != 0) {\n      throw this.mapError(rc, msg, req);\n    }\n    return res;\n  }\n  static deserializeTableResult(nr, req) {\n    return this.deserializeResponse(nr, req, (field, res) => {\n      switch (field) {\n        case Fields.COMPARTMENT_OCID:\n          res.compartmentId = nr.readString();\n          return true;\n        case Fields.NAMESPACE:\n          res.namespace = nr.readString();\n          return true;\n        case Fields.TABLE_OCID:\n          res.tableOCID = nr.readString();\n          return true;\n        case Fields.TABLE_NAME:\n          res.tableName = nr.readString();\n          return true;\n        case Fields.TABLE_STATE:\n          res.tableState = this.numToEnum(nr.readInt(), TableState, req);\n          return true;\n        case Fields.TABLE_SCHEMA:\n          res.schema = nr.readString();\n          return true;\n        case Fields.TABLE_DDL:\n          res.tableDDL = nr.readString();\n          return true;\n        case Fields.OPERATION_ID:\n          res.operationId = nr.readString();\n          return true;\n        case Fields.FREE_FORM_TAGS:\n          res.freeFormTags = this.parseJSON(nr.readString(), 'free-form tags', req);\n          return true;\n        case Fields.DEFINED_TAGS:\n          res.definedTags = this.parseJSON(nr.readString(), 'defined tags', req);\n          return true;\n        case Fields.ETAG:\n          res.etag = nr.readString();\n          return true;\n        case Fields.LIMITS:\n          res.tableLimits = {\n            readUnits: 0,\n            writeUnits: 0,\n            mode: CapacityMode.PROVISIONED\n          };\n          this.readMap(nr, limitsField => {\n            switch (limitsField) {\n              case Fields.READ_UNITS:\n                res.tableLimits.readUnits = nr.readInt();\n                return true;\n              case Fields.WRITE_UNITS:\n                res.tableLimits.writeUnits = nr.readInt();\n                return true;\n              case Fields.STORAGE_GB:\n                res.tableLimits.storageGB = nr.readInt();\n                return true;\n              case Fields.LIMITS_MODE:\n                res.tableLimits.mode = this.numToEnum(nr.readInt(), CapacityMode, req);\n                return true;\n              default:\n                return false;\n            }\n          });\n          return true;\n        case Fields.SCHEMA_FROZEN:\n          res.isSchemaFrozen = nr.readBoolean();\n          return true;\n        case Fields.INITIALIZED:\n          res.isLocalReplicaInitialized = nr.readBoolean();\n          return true;\n        case Fields.REPLICAS:\n          res.isReplicated = true;\n          res.replicas = this.readArray(nr, this.readReplicaInfo, req);\n          return true;\n        default:\n          return false;\n      }\n    }, req.opt.serviceType === ServiceType.CLOUD ? {\n      isSchemaFrozen: false,\n      isReplicated: false,\n      isLocalReplicaInitialized: false\n    } : {});\n  }\n  static readArrayValue(nr, opt) {\n    const cnt = nr.count;\n    var res = new Array(cnt);\n    for (let i = 0; i < cnt; i++) {\n      nr.next();\n      res[i] = this.readFieldValue(nr, opt);\n    }\n    return res;\n  }\n\n  //For now, we will use objectst to represent map values because currently\n  //both Record and Map columns are sent with the same type code and it is\n  //more natural to represent Record value as object.  IMO, it is more\n  //adequate for now to represent Map value as object than to represent\n  //Record value as JavaScript Map.\n  static readMapValue(nr, opt) {\n    nr.expectType(Type.MAP);\n    const res = {};\n    const cnt = nr.count;\n    for (let i = 0; i < cnt; i++) {\n      nr.next();\n      res[nr.field] = this.readFieldValue(nr, opt);\n    }\n    return res;\n  }\n\n  //Assume the type code has already been read.\n  static readFieldValue(nr, opt) {\n    switch (nr.type) {\n      case Type.ARRAY:\n        return this.readArrayValue(nr, opt);\n      case Type.BINARY:\n        return nr.readBinary();\n      case Type.BOOLEAN:\n        return nr.readBoolean();\n      case Type.DOUBLE:\n        return nr.readDouble();\n      case Type.INTEGER:\n        return nr.readInt();\n      case Type.LONG:\n        return nr.readLong(opt.longAsBigInt);\n      case Type.MAP:\n        return this.readMapValue(nr, opt);\n      case Type.STRING:\n        return nr.readString();\n      case Type.TIMESTAMP:\n        return nr.readDate();\n      case Type.NUMBER:\n        return opt._dbNumber != null ? opt._dbNumber.create(nr.readNumberAsString()) : Number(nr.readNumberAsString());\n      case Type.NULL:\n        return undefined;\n      case Type.JSON_NULL:\n        return null;\n      case Type.EMPTY:\n        return EMPTY_VALUE;\n      default:\n        throw new NoSQLProtocolError(`Unknown value type code: ${nr.type}`);\n    }\n  }\n  static readRow(nr, opt) {\n    return this.readMapValue(nr, opt);\n  }\n  static readRowVersion(nr) {\n    return nr.readBinary();\n  }\n  static deserializeReturnInfo(nr, res, opt) {\n    this.readMap(nr, field => {\n      switch (field) {\n        case Fields.EXISTING_MOD_TIME:\n          res.existingModificationTime = this.readDateAsLong(nr);\n          return true;\n        case Fields.EXISTING_VERSION:\n          res.existingVersion = this.readRowVersion(nr);\n          return true;\n        case Fields.EXISTING_VALUE:\n          res.existingRow = this.readRow(nr, opt);\n          return true;\n        default:\n          return false;\n      }\n    });\n  }\n  static deserializeSystemResult(nr, req) {\n    return this.deserializeResponse(nr, req, (field, res) => {\n      switch (field) {\n        case Fields.SYSOP_STATE:\n          res.state = AdminState.fromOrdinal(nr.readInt());\n          return true;\n        case Fields.SYSOP_RESULT:\n          res.output = nr.readString();\n          return true;\n        case Fields.STATEMENT:\n          res.statement = nr.readString();\n          return true;\n        case Fields.OPERATION_ID:\n          res.operationId = nr.readString();\n          return true;\n        default:\n          return false;\n      }\n    });\n  }\n}\nmodule.exports = Protocol;","map":{"version":3,"names":["assert","require","isInt32","TableState","AdminState","ServiceType","EMPTY_VALUE","CapacityMode","Region","Type","MathContext","error","NoSQLArgumentError","NoSQLProtocolError","BinaryProtocol","Fields","Protocol","writeHeader","nw","opCode","serialVersion","req","startMapField","HEADER","writeIntField","VERSION","checkWriteStringField","TABLE_NAME","tableName","OP_CODE","TIMEOUT","opt","requestTimeout","TOPO_SEQ_NUM","_topoInfo","seqNum","endMapField","checkWriteIntField","name","val","checkWriteLongField","writeLongField","writeStringField","checkWriteBooleanField","writeBooleanField","writeConsistency","cons","CONSISTENCY","TYPE","ordinal","writeKey","key","writeFieldName","KEY","writeFieldValue","writeValue","VALUE","ttlToString","ttl","days","Infinity","hours","_writeMapEntries","ent","startMap","endMap","writeMap","map","entries","writeObject","obj","Object","writeRowVersion","version","writeBinaryField","ROW_VERSION","writeFieldRange","fr","RANGE","RANGE_PATH","fieldName","inclusive","startWith","startAfter","START","INCLUSIVE","endWith","endBefore","END","undefined","writeNull","writeJsonNull","writeBoolean","writeString","Number","isSafeInteger","writeInt","writeLong","writeDouble","Buffer","isBuffer","writeBinary","Date","writeDate","Array","isArray","startArray","elem","endArray","_dbNumber","isInstance","writeStringAsNumber","stringValue","Map","writeEmpty","toString","serializeWriteRequest","writeDurability","durability","RETURN_ROW","returnExisting","dur","DURABILITY","durabilityToNum","writeMathContext","MATH_CONTEXT_CODE","DEFAULT","CUSTOM","MATH_CONTEXT_PRECISION","precision","MATH_CONTEXT_ROUNDING_MODE","roundingMode","mapError","rc","msg","numToEnum","fromOrdinal","err","parseJSON","JSON","parse","message","readArray","nr","readItem","args","expectType","ARRAY","res","count","i","length","next","call","readMap","processField","MAP","cnt","field","skipValue","readDateAsLong","readLong","validateTopologyInfo","topoInfo","shardIds","readTopologyInfo","PROXY_TOPO_SEQNUM","readInt","SHARD_IDS","readReplicaInfo","REGION","replicaName","readString","region","fromRegionId","TABLE_OCID","replicaOCID","WRITE_UNITS","writeUnits","LIMITS_MODE","capacityMode","TABLE_STATE","state","deserializeConsumedCapacity","READ_UNITS","readUnits","READ_KB","readKB","WRITE_KB","writeKB","deserializeResponse","CONSUMED","serviceType","KVSTORE","consumedCapacity","ERROR_CODE","EXCEPTION","TOPOLOGY_INFO","deserializeTableResult","COMPARTMENT_OCID","compartmentId","NAMESPACE","namespace","tableOCID","tableState","TABLE_SCHEMA","schema","TABLE_DDL","tableDDL","OPERATION_ID","operationId","FREE_FORM_TAGS","freeFormTags","DEFINED_TAGS","definedTags","ETAG","etag","LIMITS","tableLimits","mode","PROVISIONED","limitsField","STORAGE_GB","storageGB","SCHEMA_FROZEN","isSchemaFrozen","readBoolean","INITIALIZED","isLocalReplicaInitialized","REPLICAS","isReplicated","replicas","CLOUD","readArrayValue","readFieldValue","readMapValue","type","BINARY","readBinary","BOOLEAN","DOUBLE","readDouble","INTEGER","LONG","longAsBigInt","STRING","TIMESTAMP","readDate","NUMBER","create","readNumberAsString","NULL","JSON_NULL","EMPTY","readRow","readRowVersion","deserializeReturnInfo","EXISTING_MOD_TIME","existingModificationTime","EXISTING_VERSION","existingVersion","EXISTING_VALUE","existingRow","deserializeSystemResult","SYSOP_STATE","SYSOP_RESULT","output","STATEMENT","statement","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/nson_protocol/protocol.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\n\nconst isInt32 = require('../utils').isInt32;\nconst TableState = require('../constants').TableState;\nconst AdminState = require('../constants').AdminState;\nconst ServiceType = require('../constants').ServiceType;\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst CapacityMode = require('../constants').CapacityMode;\nconst Region = require('../region');\nconst Type = require('../binary_protocol/constants').Type;\nconst MathContext = require('../binary_protocol/constants').MathContext;\n\nconst error = require('../error');\nconst NoSQLArgumentError = error.NoSQLArgumentError;\nconst NoSQLProtocolError = error.NoSQLProtocolError;\n\nconst BinaryProtocol = require('../binary_protocol/protocol');\nconst Fields = require('./constants').Fields;\n\nclass Protocol {\n\n    //Serialization, nw is Nson writer.\n\n    static writeHeader(nw, opCode, serialVersion, req) {\n        nw.startMapField(Fields.HEADER);\n        nw.writeIntField(Fields.VERSION, serialVersion);\n        this.checkWriteStringField(nw, Fields.TABLE_NAME, req.tableName);\n        nw.writeIntField(Fields.OP_CODE, opCode);\n        nw.writeIntField(Fields.TIMEOUT, req.opt.requestTimeout);\n        nw.writeIntField(Fields.TOPO_SEQ_NUM,\n            req._topoInfo ? req._topoInfo.seqNum : -1);\n        nw.endMapField();\n    }\n\n    static checkWriteIntField(nw, name, val) {\n        if (val != null) {\n            nw.writeIntField(name, val);\n        }\n    }\n\n    static checkWriteLongField(nw, name, val) {\n        if (val != null) {\n            nw.writeLongField(name, val);\n        }\n    }\n\n    static checkWriteStringField(nw, name, val) {\n        if (val != null) {\n            nw.writeStringField(name, val);\n        }\n    }\n\n    static checkWriteBooleanField(nw, name, val) {\n        if (val) {\n            nw.writeBooleanField(name, val);\n        }\n    }\n\n    static writeConsistency(nw, cons) {\n        nw.startMapField(Fields.CONSISTENCY);\n        nw.writeIntField(Fields.TYPE, cons.ordinal);\n        nw.endMapField();\n    }\n\n    static writeKey(nw, key, opt) {\n        nw.writeFieldName(Fields.KEY);\n        this.writeFieldValue(nw, key, opt);\n    }\n\n    static writeValue(nw, val, opt) {\n        nw.writeFieldName(Fields.VALUE);\n        this.writeFieldValue(nw, val, opt);\n    }\n\n    //Assumes ttl already in canonical form, see TTLUtil#validate()\n    static ttlToString(ttl) {\n        if (ttl.days != null) {\n            return (ttl.days !== Infinity ? ttl.days : 0) + ' DAYS';\n        }\n        assert(ttl.hours != null);\n        return ttl.hours + ' HOURS';\n    }\n\n    static _writeMapEntries(nw, ent, opt) {\n        nw.startMap();\n        for(let [key, val] of ent) {\n            if (typeof key !== 'string') {\n                throw new NoSQLArgumentError(`Invalid map or object key for \\\nfield value: ${key}, must be a string`);\n            }\n            nw.writeFieldName(key);\n            this.writeFieldValue(nw, val, opt);\n        }\n        nw.endMap();\n    }\n\n    static writeMap(nw, map, opt) {\n        this._writeMapEntries(nw, map.entries(), opt);\n    }\n\n    static writeObject(nw, obj, opt) {\n        this._writeMapEntries(nw, Object.entries(obj), opt);\n    }\n\n    static writeRowVersion(nw, version) {\n        nw.writeBinaryField(Fields.ROW_VERSION, version);\n    }\n\n    static writeFieldRange(nw, fr, opt) {\n        nw.startMapField(Fields.RANGE);\n        nw.writeStringField(Fields.RANGE_PATH, fr.fieldName);\n\n        let inclusive = (fr.startWith != null);\n        let val = inclusive ? fr.startWith : fr.startAfter;\n        if (val != null) {\n            nw.startMapField(Fields.START);\n            this.writeValue(nw, val, opt);\n            nw.writeBooleanField(Fields.INCLUSIVE, inclusive);\n            nw.endMapField();\n        }\n\n        inclusive = (fr.endWith != null);\n        val = inclusive ? fr.endWith : fr.endBefore;\n        if (val != null) {\n            nw.startMapField(Fields.END);\n            this.writeValue(nw, val, opt);\n            nw.writeBooleanField(Fields.INCLUSIVE, inclusive);\n            nw.endMapField();\n        }\n\n        nw.endMapField();\n    }\n\n    static writeFieldValue(nw, val, opt) {\n        if (typeof val === 'function') {\n            //If the field specified as a function, we write its return value\n            val = val();\n        }\n        if (val === undefined) {\n            return nw.writeNull();\n        }\n        if (val === null) {\n            return nw.writeJsonNull();\n        }\n        switch(typeof val) {\n        case 'boolean':\n            nw.writeBoolean(val);\n            break;\n        case 'string':\n            nw.writeString(val);\n            break;\n        case 'number':\n            if (Number.isSafeInteger(val)) {\n                if (isInt32(val)) {\n                    nw.writeInt(val);\n                } else {\n                    nw.writeLong(val);\n                }\n            } else {\n                nw.writeDouble(val);\n            }\n            break;\n        case 'bigint':\n            nw.writeLong(val);\n            break;\n        case 'object':\n            if (Buffer.isBuffer(val)) {\n                nw.writeBinary(val);\n            } else if (val instanceof Date) {\n                nw.writeDate(val);\n            } else if (Array.isArray(val)) {\n                nw.startArray();\n                for(const elem of val) {\n                    this.writeFieldValue(nw, elem, opt);\n                }\n                nw.endArray();\n            } else if (opt._dbNumber != null &&\n                opt._dbNumber.isInstance(val)) {\n                nw.writeStringAsNumber(opt._dbNumber.stringValue(val));\n            } else {\n                if (val instanceof Map) {\n                    this.writeMap(nw, val, opt);\n                } else {\n                    this.writeObject(nw, val, opt);\n                }\n            }\n            break;\n        default:\n            if (val === EMPTY_VALUE) {\n                nw.writeEmpty();\n                break;\n            }\n            throw new NoSQLArgumentError('Unsupported value type ' +\n                `${typeof val} for value ${val.toString()}`);\n        }\n    }\n\n    static serializeWriteRequest(nw, req) {\n        this.writeDurability(nw, req.opt.durability);\n        nw.writeBooleanField(Fields.RETURN_ROW, req.opt.returnExisting);\n    }\n\n    static writeDurability(nw, dur) {\n        nw.writeIntField(Fields.DURABILITY,\n            BinaryProtocol.durabilityToNum(dur));\n    }\n\n    static writeMathContext(nw, opt) {\n        if (opt._dbNumber == null) {\n            return nw.writeIntField(Fields.MATH_CONTEXT_CODE,\n                MathContext.DEFAULT);\n        }\n\n        nw.writeIntField(Fields.MATH_CONTEXT_CODE, MathContext.CUSTOM);\n        nw.writeIntField(Fields.MATH_CONTEXT_PRECISION,\n            opt._dbNumber.precision);\n        nw.writeIntField(Fields.MATH_CONTEXT_ROUNDING_MODE,\n            opt._dbNumber.roundingMode);\n    }\n\n    //Deserialization.\n\n    static mapError(rc, msg, req) {\n        return BinaryProtocol.mapError(rc, msg, req);\n    }\n\n    //To throw correct error if received invalid value.\n    static numToEnum(val, cons, req) {\n        try {\n            return cons.fromOrdinal(val);\n        } catch(err) {\n            throw new NoSQLProtocolError(\n                `Received invalid value of ${cons.name}: {val}`, err, req);\n        }\n    }\n\n    //Same as above.\n    static parseJSON(val, name, req) {\n        try {\n            return JSON.parse(val);\n        } catch(err) {\n            throw new NoSQLProtocolError(\n                `Error parsing ${name}: ${err.message}`, err, req);\n        }\n    }\n\n    static readArray(nr, readItem, ...args) {\n        nr.expectType(Type.ARRAY);\n        const res = new Array(nr.count);\n\n        for (let i = 0; i < res.length; i++) {\n            nr.next();\n            //Enable readItem to use Protocol context\n            res[i] = readItem.call(this, nr, ...args);\n        }\n\n        return res;\n    }\n\n    //processField() takes field name as an argument.  It returns true if\n    //the field was read and processed or false if the field was ignored, in\n    //which case we will skip it.\n    //We assume processField() gets any other needed info (including the\n    //NsonReader instance) from the closure context, as this is more\n    //convenient, but we may add other overloads if required.\n    static readMap(nr, processField) {\n        nr.expectType(Type.MAP);\n        const cnt = nr.count;        \n        for (let i = 0; i < cnt; i++) {\n            nr.next();\n            if (!processField(nr.field)) {\n                nr.skipValue();\n            }\n        }\n    }\n\n    static readDateAsLong(nr) {\n        const val = nr.readLong();\n        return val ? new Date(val) : undefined;\n    }\n\n    static validateTopologyInfo(topoInfo) {\n        //We don't need to validate types of seqNum and shardIds because they\n        //are read with correct types by NsonReader.\n        if (topoInfo.seqNum == null || topoInfo.seqNum < 0) {\n            throw new NoSQLProtocolError(\n                `Received invalid topology seqNum: ${topoInfo.seqNum}`);\n        }\n        if (!topoInfo.shardIds || !topoInfo.shardIds.length) {\n            throw new NoSQLProtocolError(\n                `Missing shard ids for topology seqNum ${topoInfo.seqNum}`);\n        }\n    }\n\n    static readTopologyInfo(nr) {\n        const res = {};\n\n        this.readMap(nr, field => {\n            switch(field) {\n            case Fields.PROXY_TOPO_SEQNUM:\n                res.seqNum = nr.readInt();\n                return true;\n            case Fields.SHARD_IDS:\n                res.shardIds = this.readArray(nr, nr => nr.readInt());\n                return true;\n            default:\n                return false;\n            }\n        });\n\n        this.validateTopologyInfo(res);\n        return res;\n    }\n\n    static readReplicaInfo(nr, req) {\n        const res = {};\n\n        this.readMap(nr, field => {\n            switch(field) {\n            case Fields.REGION:\n                res.replicaName = nr.readString();\n                //May be undefined for regions not yet added to region.js.\n                res.region = Region.fromRegionId(res.replicaName);\n                return true;\n            case Fields.TABLE_OCID:\n                res.replicaOCID = nr.readString();\n                return true;\n            case Fields.WRITE_UNITS:\n                res.writeUnits = nr.readInt();\n                return true;\n            case Fields.LIMITS_MODE:\n                res.capacityMode = this.numToEnum(nr.readInt(), CapacityMode,\n                    req);\n                return true;\n            case Fields.TABLE_STATE:\n                res.state = this.numToEnum(nr.readInt(), TableState, req);\n                return true;\n            default:\n                return false;\n            }\n        });\n\n        return res;\n    }\n\n    static deserializeConsumedCapacity(nr) {\n        const res = {};\n        \n        this.readMap(nr, field => {\n            switch(field) {\n            case Fields.READ_UNITS:\n                res.readUnits = nr.readInt();\n                return true;\n            case Fields.READ_KB:\n                res.readKB = nr.readInt();\n                return true;\n            case Fields.WRITE_KB:\n                res.writeKB = nr.readInt();\n                res.writeUnits = res.writeKB;\n                return true;\n            default:\n                return false;\n            }\n        });\n\n        return res;\n    }\n\n    static deserializeResponse(nr, req, processField, res) {\n        let rc = 0;\n        let msg;\n\n        nr.next();\n        if (res == null) {\n            res = {};\n        }\n\n        this.readMap(nr, field => {\n            switch (field) {\n            case Fields.CONSUMED:\n                if (req.opt.serviceType !== ServiceType.KVSTORE) {\n                    res.consumedCapacity =\n                        this.deserializeConsumedCapacity(nr);\n                    return true;\n                }\n                return false;\n            case Fields.ERROR_CODE:\n                rc = nr.readInt();\n                return true;\n            case Fields.EXCEPTION:\n                msg = nr.readString();\n                return true;\n            case Fields.TOPOLOGY_INFO:\n                res._topoInfo = this.readTopologyInfo(nr);\n                return true;\n            default:\n                return processField(field, res);\n            }\n        });\n\n        if (rc != 0) {\n            throw this.mapError(rc, msg, req);\n        }\n\n        return res;\n    }\n\n    static deserializeTableResult(nr, req) {\n        return this.deserializeResponse(nr, req, (field, res) => {\n            switch (field) {\n            case Fields.COMPARTMENT_OCID:\n                res.compartmentId = nr.readString();\n                return true;\n            case Fields.NAMESPACE:\n                res.namespace = nr.readString();\n                return true;\n            case Fields.TABLE_OCID:\n                res.tableOCID = nr.readString();\n                return true;\n            case Fields.TABLE_NAME:\n                res.tableName = nr.readString();\n                return true;\n            case Fields.TABLE_STATE:\n                res.tableState = this.numToEnum(nr.readInt(), TableState,\n                    req);\n                return true;\n            case Fields.TABLE_SCHEMA:\n                res.schema = nr.readString();\n                return true;\n            case Fields.TABLE_DDL:\n                res.tableDDL = nr.readString();\n                return true;\n            case Fields.OPERATION_ID:\n                res.operationId = nr.readString();\n                return true;\n            case Fields.FREE_FORM_TAGS:\n                res.freeFormTags = this.parseJSON(nr.readString(),\n                    'free-form tags', req);\n                return true;\n            case Fields.DEFINED_TAGS:\n                res.definedTags = this.parseJSON(nr.readString(),\n                    'defined tags', req);\n                return true;\n            case Fields.ETAG:\n                res.etag = nr.readString();\n                return true;\n            case Fields.LIMITS:\n                res.tableLimits = {\n                    readUnits: 0,\n                    writeUnits: 0,\n                    mode: CapacityMode.PROVISIONED\n                };\n                this.readMap(nr, limitsField => {\n                    switch (limitsField) {\n                    case Fields.READ_UNITS:\n                        res.tableLimits.readUnits = nr.readInt();\n                        return true;\n                    case Fields.WRITE_UNITS:\n                        res.tableLimits.writeUnits = nr.readInt();\n                        return true;\n                    case Fields.STORAGE_GB:\n                        res.tableLimits.storageGB = nr.readInt();\n                        return true;\n                    case Fields.LIMITS_MODE:\n                        res.tableLimits.mode = this.numToEnum(nr.readInt(),\n                            CapacityMode, req);\n                        return true;\n                    default:\n                        return false;\n                    }\n                });\n                return true;\n            case Fields.SCHEMA_FROZEN:\n                res.isSchemaFrozen = nr.readBoolean();\n                return true;\n            case Fields.INITIALIZED:\n                res.isLocalReplicaInitialized = nr.readBoolean();\n                return true;\n            case Fields.REPLICAS:\n                res.isReplicated = true;\n                res.replicas = this.readArray(nr, this.readReplicaInfo, req);\n                return true;\n            default:\n                return false;\n            }\n        }, req.opt.serviceType === ServiceType.CLOUD ? {\n            isSchemaFrozen: false,\n            isReplicated: false,\n            isLocalReplicaInitialized: false\n        } : {});\n    }\n\n    static readArrayValue(nr, opt) {\n        const cnt = nr.count;\n        var res = new Array(cnt);\n        for (let i = 0; i < cnt; i++) {\n            nr.next();\n            res[i] = this.readFieldValue(nr, opt);\n        }\n        return res;\n    }\n\n    //For now, we will use objectst to represent map values because currently\n    //both Record and Map columns are sent with the same type code and it is\n    //more natural to represent Record value as object.  IMO, it is more\n    //adequate for now to represent Map value as object than to represent\n    //Record value as JavaScript Map.\n    static readMapValue(nr, opt) {\n        nr.expectType(Type.MAP);\n        const res = {};\n        const cnt = nr.count;     \n        for (let i = 0; i < cnt; i++) {\n            nr.next();\n            res[nr.field] = this.readFieldValue(nr, opt);\n        }\n        return res;\n    }\n\n    //Assume the type code has already been read.\n    static readFieldValue(nr, opt) {\n        switch(nr.type) {\n        case Type.ARRAY:\n            return this.readArrayValue(nr, opt);\n        case Type.BINARY:\n            return nr.readBinary();\n        case Type.BOOLEAN:\n            return nr.readBoolean();\n        case Type.DOUBLE:\n            return nr.readDouble();\n        case Type.INTEGER:\n            return nr.readInt();\n        case Type.LONG:\n            return nr.readLong(opt.longAsBigInt);\n        case Type.MAP:\n            return this.readMapValue(nr, opt);\n        case Type.STRING:\n            return nr.readString();\n        case Type.TIMESTAMP:\n            return nr.readDate();\n        case Type.NUMBER:\n            return (opt._dbNumber != null) ?\n                opt._dbNumber.create(nr.readNumberAsString()) :\n                Number(nr.readNumberAsString());\n        case Type.NULL:\n            return undefined;\n        case Type.JSON_NULL:\n            return null;\n        case Type.EMPTY:\n            return EMPTY_VALUE;\n        default:\n            throw new NoSQLProtocolError(\n                `Unknown value type code: ${nr.type}`);\n        }\n    }\n\n    static readRow(nr, opt) {\n        return this.readMapValue(nr, opt);\n    }\n\n    static readRowVersion(nr) {\n        return nr.readBinary();\n    }\n\n    static deserializeReturnInfo(nr, res, opt) {\n        this.readMap(nr, field => {\n            switch (field){\n            case Fields.EXISTING_MOD_TIME:\n                res.existingModificationTime = this.readDateAsLong(nr);\n                return true;\n            case Fields.EXISTING_VERSION:\n                res.existingVersion = this.readRowVersion(nr);\n                return true;\n            case Fields.EXISTING_VALUE:\n                res.existingRow = this.readRow(nr, opt);\n                return true;\n            default:\n                return false;\n            }\n        });\n    }\n\n    static deserializeSystemResult(nr, req) {\n        return this.deserializeResponse(nr, req, (field, res) => {\n            switch (field) {\n            case Fields.SYSOP_STATE:\n                res.state = AdminState.fromOrdinal(nr.readInt());\n                return true;\n            case Fields.SYSOP_RESULT:\n                res.output = nr.readString();\n                return true;\n            case Fields.STATEMENT:\n                res.statement = nr.readString();\n                return true;\n            case Fields.OPERATION_ID:\n                res.operationId = nr.readString();\n                return true;\n            default:\n                return false;\n            }\n        });\n    }\n\n}\n\nmodule.exports = Protocol;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}