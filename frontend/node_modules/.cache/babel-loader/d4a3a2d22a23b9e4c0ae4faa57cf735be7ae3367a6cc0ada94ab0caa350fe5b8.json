{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst ErrorCode = require('../error_code');\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\nconst Limits = require('../constants').Limits;\nconst isPosInt32 = require('../utils').isPosInt32;\nconst isPosInt32OrZero = require('../utils').isPosInt32OrZero;\nconst Op = require('./op');\n\n/* \"5\" == PrepareCallback.QueryOperation.SELECT */\nconst OPCODE_SELECT = 5;\nclass QueryOpBase extends Op {\n  static _decrementQueryVersion(client, versionUsed) {\n    //See comment to HttpClient._decrementSerialVersion().\n    if (client._queryVersion !== versionUsed) {\n      return true;\n    }\n    //Allow going from V4 to V3.\n    if (client._queryVersion === this.QUERY_V4) {\n      client._queryVersion = this.QUERY_V3;\n      return true;\n    }\n    return false;\n  }\n\n  //See Op for base class implementations of the following methods.\n\n  static setProtocolVersion(client, req) {\n    super.setProtocolVersion(client, req);\n    if (client._queryVersion == null) {\n      client._queryVersion = this.QUERY_VERSION;\n    }\n    req._queryVersion = client._queryVersion;\n  }\n\n  //Returns true if the operation can be retried immediately because we\n  //received UNSUPPORTED_PROTOCOL or UNSUPPORTED_QUERY_VERSION errors.\n  static handleUnsupportedProtocol(client, req, err) {\n    if (super.handleUnsupportedProtocol(client, req, err)) {\n      return true;\n    }\n\n    //Check if we got UNSUPPORTED_QUERY_VERSION error and can can retry\n    //with older protocol, in which case we can immediately retry\n    //(otherwise use retry handler as usual).\n    if (err.errorCode === ErrorCode.UNSUPPORTED_QUERY_VERSION) {\n      if (!this._decrementQueryVersion(client, req._serialVersion)) {\n        throw err;\n      }\n      return true;\n    }\n    return false;\n  }\n  static protocolChanged(client, req) {\n    return super.protocolChanged(client, req) || req._queryVersion !== client._queryVersion;\n  }\n}\n\n//Query protocol versions currently in use.\nQueryOpBase.QUERY_V3 = 3;\nQueryOpBase.QUERY_V4 = 4;\n//Current query version.\nQueryOpBase.QUERY_VERSION = QueryOpBase.QUERY_V4;\nclass PrepareOp extends QueryOpBase {\n  static validate(req) {\n    this._validateRequest(req);\n    if (typeof req.stmt !== 'string' || !req.stmt.length) {\n      throw new NoSQLArgumentError('Invalid statement', req);\n    }\n  }\n  static getTableName(req, res) {\n    return res != null ? res._tableName : null;\n  }\n  static get supportsRateLimiting() {\n    return true;\n  }\n  static doesReads() {\n    return true;\n  }\n}\nclass QueryOp extends QueryOpBase {\n  static validate(req) {\n    this._validateRequest(req);\n    this._chkConsistency(req);\n    if (req.opt.durability != null) {\n      this._chkProtoVer('Query durability option', 4, req);\n      this._validateDurability(req);\n    }\n    if (req.opt.limit != null && !isPosInt32(req.opt.limit)) {\n      throw new NoSQLArgumentError('Invalid limit', req);\n    }\n    if (req.opt.maxReadKB != null) {\n      if (!isPosInt32(req.opt.maxReadKB)) {\n        throw new NoSQLArgumentError('Invalid maxReadKB', req);\n      } else if (req.opt.maxReadKB > Limits.READ_KB) {\n        throw new NoSQLArgumentError('maxReadKB value exceeds ' + `limit of ${Limits.READ_KB}`, req);\n      }\n    }\n    if (req.opt.maxWriteKB != null) {\n      if (!isPosInt32(req.opt.maxWriteKB)) {\n        throw new NoSQLArgumentError('Invalid \"maxWriteKB\" value', req);\n      } else if (req.opt.maxWriteKB > Limits.WRITE_KB) {\n        throw new NoSQLArgumentError('maxWriteKB value exceeds ' + `limit of ${Limits.WRITE_KB}`, req);\n      }\n    }\n    if (req.opt.maxMemoryMB != null && !isPosInt32(req.opt.maxMemoryMB)) {\n      throw new NoSQLArgumentError('Invalid \"maxMemoryMB\" value', req);\n    }\n    if (req.opt.traceLevel != null && (!isPosInt32OrZero(req.opt.traceLevel) || req.opt.traceLevel > 32)) {\n      throw new NoSQLArgumentError('Invalid trace level, must be <= 32', req);\n    }\n    this._chkContinuationKey(req);\n    if (req.stmt != null) {\n      assert(typeof req.stmt === 'string');\n      if (!req.stmt.length) {\n        throw new NoSQLArgumentError('Invalid statement', req);\n      }\n    } else {\n      assert(req.prepStmt != null);\n      if (typeof req.prepStmt !== 'object' || !Buffer.isBuffer(req.prepStmt._prepStmt)) {\n        throw new NoSQLArgumentError('Invalid prepared statement', req);\n      }\n      if (req.prepStmt.bindings != null && typeof req.prepStmt.bindings !== 'object') {\n        throw new NoSQLArgumentError('Invalid bindings', req);\n      }\n    }\n  }\n  static onResult(client, req, res) {\n    super.onResult(client, req, res);\n    //Make continuation key ready for the next query() call\n    let prepStmt;\n    if (res._prepStmt) {\n      //received prepared statement\n      prepStmt = res._prepStmt;\n      //advanced query will be executed on the next query() call,\n      //so we need continuation key\n      if (res._prepStmt._queryPlan) {\n        res.continuationKey = {\n          [Op.ccAsObj]: true\n        };\n      }\n      if (res.continuationKey) {\n        res.continuationKey._prepStmt = prepStmt;\n      }\n    } else {\n      prepStmt = req.prepStmt;\n      if (res.continuationKey) {\n        res.continuationKey._prepStmt = prepStmt;\n      }\n    }\n    assert(req.opt); //see Op.applyDefaults()\n    //Batch counter is needed for query tracing.\n    if (req.opt.traceLevel > 0 && res.continuationKey) {\n      res.continuationKey._batchNum = req.opt.continuationKey && req.opt.continuationKey._batchNum ? req.opt.continuationKey._batchNum + 1 : 1;\n    }\n  }\n  static _getPrepStmt(req, res) {\n    if (req.prepStmt != null) {\n      return req.prepStmt;\n    }\n    const ck = req.opt.continuationKey;\n    if (ck != null) {\n      return ck._prepStmt;\n    }\n    //We need this for simple queries returing only one batch of results\n    //and thus having no continuation key.\n    return res != null ? res._prepStmt : null;\n  }\n  static getTableName(req, res) {\n    const prepStmt = this._getPrepStmt(req, res);\n    return prepStmt != null ? prepStmt._tableName : null;\n  }\n  static get supportsRateLimiting() {\n    return true;\n  }\n  static doesReads() {\n    return true;\n  }\n  static doesWrites(req, res) {\n    const prepStmt = this._getPrepStmt(req, res);\n    return prepStmt != null ? prepStmt._opCode != OPCODE_SELECT : false;\n  }\n}\nmodule.exports = {\n  PrepareOp,\n  QueryOp\n};","map":{"version":3,"names":["assert","require","ErrorCode","NoSQLArgumentError","Limits","isPosInt32","isPosInt32OrZero","Op","OPCODE_SELECT","QueryOpBase","_decrementQueryVersion","client","versionUsed","_queryVersion","QUERY_V4","QUERY_V3","setProtocolVersion","req","QUERY_VERSION","handleUnsupportedProtocol","err","errorCode","UNSUPPORTED_QUERY_VERSION","_serialVersion","protocolChanged","PrepareOp","validate","_validateRequest","stmt","length","getTableName","res","_tableName","supportsRateLimiting","doesReads","QueryOp","_chkConsistency","opt","durability","_chkProtoVer","_validateDurability","limit","maxReadKB","READ_KB","maxWriteKB","WRITE_KB","maxMemoryMB","traceLevel","_chkContinuationKey","prepStmt","Buffer","isBuffer","_prepStmt","bindings","onResult","_queryPlan","continuationKey","ccAsObj","_batchNum","_getPrepStmt","ck","doesWrites","_opCode","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/ops/query.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\n\nconst ErrorCode = require('../error_code');\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\nconst Limits = require('../constants').Limits;\nconst isPosInt32 = require('../utils').isPosInt32;\nconst isPosInt32OrZero = require('../utils').isPosInt32OrZero;\nconst Op = require('./op');\n\n/* \"5\" == PrepareCallback.QueryOperation.SELECT */\nconst OPCODE_SELECT = 5;\n\nclass QueryOpBase extends Op {\n\n    static _decrementQueryVersion(client, versionUsed) {\n        //See comment to HttpClient._decrementSerialVersion().\n        if (client._queryVersion !== versionUsed) {\n            return true;\n        }\n        //Allow going from V4 to V3.\n        if (client._queryVersion === this.QUERY_V4) {\n            client._queryVersion = this.QUERY_V3;\n            return true;\n        }\n        return false;\n    }\n\n    //See Op for base class implementations of the following methods.\n\n    static setProtocolVersion(client, req) {\n        super.setProtocolVersion(client, req);\n        if (client._queryVersion == null) {\n            client._queryVersion = this.QUERY_VERSION;\n        }\n        req._queryVersion = client._queryVersion;\n    }\n\n    //Returns true if the operation can be retried immediately because we\n    //received UNSUPPORTED_PROTOCOL or UNSUPPORTED_QUERY_VERSION errors.\n    static handleUnsupportedProtocol(client, req, err) {\n        if (super.handleUnsupportedProtocol(client, req, err)) {\n            return true;\n        }\n\n        //Check if we got UNSUPPORTED_QUERY_VERSION error and can can retry\n        //with older protocol, in which case we can immediately retry\n        //(otherwise use retry handler as usual).\n        if (err.errorCode === ErrorCode.UNSUPPORTED_QUERY_VERSION) {\n            if (!this._decrementQueryVersion(client, req._serialVersion)) {\n                throw err;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    static protocolChanged(client, req) {\n        return super.protocolChanged(client, req) ||\n            req._queryVersion !== client._queryVersion;\n    }\n}\n\n//Query protocol versions currently in use.\nQueryOpBase.QUERY_V3 = 3;\nQueryOpBase.QUERY_V4 = 4;\n//Current query version.\nQueryOpBase.QUERY_VERSION = QueryOpBase.QUERY_V4;\n\nclass PrepareOp extends QueryOpBase {\n\n    static validate(req) {\n        this._validateRequest(req);\n        if (typeof req.stmt !== 'string' || !req.stmt.length) {\n            throw new NoSQLArgumentError('Invalid statement', req);\n        }\n    }\n\n    static getTableName(req, res) {\n        return res != null ? res._tableName : null;\n    }\n\n    static get supportsRateLimiting() {\n        return true;\n    }\n\n    static doesReads() {\n        return true;\n    }\n\n}\n\nclass QueryOp extends QueryOpBase {\n\n    static validate(req) {\n        this._validateRequest(req);\n        this._chkConsistency(req);\n        if (req.opt.durability != null) {\n            this._chkProtoVer('Query durability option', 4, req);\n            this._validateDurability(req);\n        }\n        if (req.opt.limit != null && !isPosInt32(req.opt.limit)) {\n            throw new NoSQLArgumentError('Invalid limit', req);\n        }\n        if (req.opt.maxReadKB != null) {\n            if (!isPosInt32(req.opt.maxReadKB)) {\n                throw new NoSQLArgumentError('Invalid maxReadKB', req);\n            } else if (req.opt.maxReadKB > Limits.READ_KB) {\n                throw new NoSQLArgumentError('maxReadKB value exceeds ' +\n                    `limit of ${Limits.READ_KB}`, req);\n            }\n        }\n        if (req.opt.maxWriteKB != null) {\n            if (!isPosInt32(req.opt.maxWriteKB)) {\n                throw new NoSQLArgumentError('Invalid \"maxWriteKB\" value',\n                    req);\n            } else if (req.opt.maxWriteKB > Limits.WRITE_KB) {\n                throw new NoSQLArgumentError('maxWriteKB value exceeds ' +\n                    `limit of ${Limits.WRITE_KB}`, req);\n            }\n        }\n        if (req.opt.maxMemoryMB != null && !isPosInt32(req.opt.maxMemoryMB)) {\n            throw new NoSQLArgumentError('Invalid \"maxMemoryMB\" value', req);\n        }\n        if (req.opt.traceLevel != null &&\n            (!isPosInt32OrZero(req.opt.traceLevel) ||\n            req.opt.traceLevel > 32)) {\n            throw new NoSQLArgumentError(\n                'Invalid trace level, must be <= 32', req);\n        }\n        this._chkContinuationKey(req);\n        \n        if (req.stmt != null) {\n            assert(typeof req.stmt === 'string');\n            if (!req.stmt.length) {\n                throw new NoSQLArgumentError('Invalid statement', req);\n            }\n        } else {\n            assert(req.prepStmt != null);\n            if (typeof req.prepStmt !== 'object' ||\n                !Buffer.isBuffer(req.prepStmt._prepStmt)) {\n                throw new NoSQLArgumentError('Invalid prepared statement',\n                    req);\n            }\n            if (req.prepStmt.bindings != null &&\n                typeof req.prepStmt.bindings !== 'object') {\n                throw new NoSQLArgumentError('Invalid bindings', req);\n            }\n        }\n    }\n\n    static onResult(client, req, res) {\n        super.onResult(client, req, res);\n        //Make continuation key ready for the next query() call\n        let prepStmt;\n        if (res._prepStmt) { //received prepared statement\n            prepStmt = res._prepStmt;\n            //advanced query will be executed on the next query() call,\n            //so we need continuation key\n            if (res._prepStmt._queryPlan) {\n                res.continuationKey = { [Op.ccAsObj]: true };\n            }\n            if (res.continuationKey) {\n                res.continuationKey._prepStmt = prepStmt;\n            }\n        } else {\n            prepStmt = req.prepStmt;\n            if (res.continuationKey) {\n                res.continuationKey._prepStmt = prepStmt;\n            }\n        }\n\n        assert(req.opt); //see Op.applyDefaults()\n        //Batch counter is needed for query tracing.\n        if (req.opt.traceLevel > 0 && res.continuationKey) {\n            res.continuationKey._batchNum =\n                req.opt.continuationKey && req.opt.continuationKey._batchNum ?\n                    req.opt.continuationKey._batchNum + 1 : 1;\n        }\n    }\n\n    static _getPrepStmt(req, res) {\n        if (req.prepStmt != null) {\n            return req.prepStmt;\n        }\n        const ck = req.opt.continuationKey;\n        if (ck != null) {\n            return ck._prepStmt;\n        }\n        //We need this for simple queries returing only one batch of results\n        //and thus having no continuation key.\n        return res != null ? res._prepStmt : null;\n    }\n\n    static getTableName(req, res) {\n        const prepStmt = this._getPrepStmt(req, res);\n        return prepStmt != null ? prepStmt._tableName : null;\n    }\n\n    static get supportsRateLimiting() {\n        return true;\n    }\n\n    static doesReads() {\n        return true;\n    }\n\n    static doesWrites(req, res) {\n        const prepStmt = this._getPrepStmt(req, res);\n        return prepStmt != null ?\n            prepStmt._opCode != OPCODE_SELECT : false;\n    }\n}\n\nmodule.exports = {\n    PrepareOp,\n    QueryOp\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}