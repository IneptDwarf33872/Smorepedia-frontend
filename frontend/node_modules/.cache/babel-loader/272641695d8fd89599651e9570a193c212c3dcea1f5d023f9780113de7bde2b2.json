{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst http = require('http');\nconst https = require('https');\nconst EventEmitter = require('events');\nconst NsonProtocolManager = require('./nson_protocol/protocol_manager');\nconst BinaryProtocolManager = require('./binary_protocol/protocol_manager');\nconst ErrorCode = require('./error_code');\nconst error = require('./error');\nconst NoSQLNetworkError = error.NoSQLNetworkError;\nconst NoSQLServiceError = error.NoSQLServiceError;\nconst NoSQLTimeoutError = error.NoSQLTimeoutError;\nconst HttpConstants = require('./constants').HttpConstants;\nconst PACKAGE_VERSION = require('./constants').PACKAGE_VERSION;\nconst Limits = require('./constants').Limits;\nconst RateLimiterClient = require('./rate_limiter/client');\nconst promisified = require('./utils').promisified;\nconst sleep = require('./utils').sleep;\nclass HttpClient extends EventEmitter {\n  constructor(config) {\n    super();\n    //This shouldn't throw since we already validated the endpoint in\n    //Config._endpoint2url()\n    assert(config.url);\n    this._url = new URL(HttpConstants.NOSQL_DATA_PATH, config.url);\n    this._config = config;\n    this._useSSL = this._url.protocol.startsWith('https');\n    this._httpMod = this._useSSL ? https : http;\n    if ('httpOpt' in config) {\n      this._agent = new this._httpMod.Agent(config.httpOpt);\n    } else {\n      this._agent = this._httpMod.globalAgent;\n    }\n\n    //can be customized to use other protocols\n    this._pm = NsonProtocolManager;\n    this._requestId = 1;\n\n    // Session cookie\n    this._sessionCookie = null;\n\n    //init rate limiting if enabled\n    if (RateLimiterClient.rateLimitingEnabled(config)) {\n      this._rlClient = new RateLimiterClient(this);\n    }\n\n    // user-agent string\n    this._user_agent = 'NoSQL-NodeSDK/' + PACKAGE_VERSION + '(node.js ' + process.version + '; ' + process.platform + '/' + process.arch + ')';\n  }\n  _handleResponse(op, req, res, buf, callback) {\n    try {\n      if (res.statusCode == HttpConstants.HTTP_OK) {\n        // is there a set-cookie header? If so, use it\n        var cookie = res.headers[HttpConstants.SET_COOKIE];\n        if (cookie != null) {\n          if (Array.isArray(cookie)) {\n            cookie = cookie[0];\n          }\n          this._setSessionCookie(cookie);\n        }\n        const nosqlRes = op.deserialize(this._pm, buf, req);\n        return callback(null, nosqlRes);\n      } else {\n        let errOutput;\n        if (res.statusCode == HttpConstants.HTTP_BAD_REQUEST) {\n          errOutput = buf.toString('utf8');\n        }\n        return callback(new NoSQLServiceError(res, errOutput, req));\n      }\n    } catch (err) {\n      err._req = req;\n      return callback(err);\n    } finally {\n      this._pm.releaseBuffer(buf);\n    }\n  }\n  _setSessionCookie(cookie) {\n    if (cookie.startsWith('session=')) {\n      var value = cookie.substring(0, cookie.indexOf(';'));\n      this._sessionCookie = value;\n    }\n  }\n  _decrementSerialVersion(versionUsed) {\n    //The purpose of checking versionUsed is to avoid a race condition\n    //where _decrementSerialVersion() gets called called concurrently by\n    //mutliple requests and thus decrements the serial version twice\n    //without retrying the request with the intermediate version.\n    if (this._pm.serialVersion !== versionUsed) {\n      return true;\n    }\n\n    //Check if current protocol can decrement its serial version.\n    if (this._pm.decrementSerialVersion()) {\n      return true;\n    }\n\n    //If not and the current protocol is Nson, switch to binary protocol.\n    if (this._pm === NsonProtocolManager) {\n      this._pm = BinaryProtocolManager;\n      return true;\n    }\n    return false;\n  }\n  _executeOnceWithAuth(op, req, auth, endSend, callback) {\n    const reqId = this._requestId++;\n    assert(req._buf);\n    assert(req.opt.requestTimeout);\n    const httpOpt = {\n      hostname: this._url.hostname,\n      port: this._url.port,\n      path: this._url.pathname,\n      method: HttpConstants.POST,\n      headers: {\n        [HttpConstants.HOST]: this._url.host,\n        [HttpConstants.REQUEST_ID]: reqId,\n        [HttpConstants.CONNECTION]: 'keep-alive',\n        [HttpConstants.ACCEPT]: this._pm.contentType,\n        [HttpConstants.USER_AGENT]: this._user_agent,\n        [HttpConstants.CONTENT_TYPE]: this._pm.contentType,\n        [HttpConstants.CONTENT_LENGTH]: this._pm.getContentLength(req._buf)\n      },\n      agent: this._agent,\n      timeout: req.opt.requestTimeout\n    };\n    if (typeof auth === 'string') {\n      httpOpt.headers[HttpConstants.AUTHORIZATION] = auth;\n    } else if (auth != null) {\n      Object.assign(httpOpt.headers, auth);\n    }\n    if (this._sessionCookie != null) {\n      httpOpt.headers[HttpConstants.COOKIE] = this._sessionCookie;\n    }\n    if (req.opt.namespace != null) {\n      httpOpt.headers[HttpConstants.NAMESPACE] = req.opt.namespace;\n    }\n    const httpReq = this._httpMod.request(httpOpt, res => {\n      if (this._pm.encoding) {\n        res.setEncoding(this._pm.encoding);\n      }\n      const buf = this._pm.getBuffer();\n      res.on('data', chunk => {\n        this._pm.addChunk(buf, chunk);\n      });\n      res.on('end', () => {\n        this._handleResponse(op, req, res, buf, callback);\n      });\n    }).on('error', err => callback(new NoSQLNetworkError(null, req, err)));\n\n    //This code should not throw synchronously. The code that can throw\n    //have been moved to _executeOnce().\n    httpReq.write(this._pm.getContent(req._buf), this._pm.encoding);\n    httpReq.end(endSend);\n  }\n  async _executeOnce(op, req) {\n    const buf = this._pm.getBuffer();\n    let auth;\n    try {\n      op.serialize(this._pm, buf, req);\n      //Allow auth provider to use request content. This is needed for\n      //cross-region authentication in the Cloud. ProtoMgr is used to\n      //get content, content type type and length in\n      //protocol-independent manner.\n      req._protoMgr = this._pm;\n      req._buf = buf;\n      auth = await this._config.auth.provider.getAuthorization(req);\n    } catch (err) {\n      req._buf = undefined;\n      this._pm.releaseBuffer(buf);\n      err._req = req;\n      throw err;\n    }\n    return promisified(this, this._executeOnceWithAuth, op, req, auth,\n    //Small optimization to release buffer (for reuse) immediately\n    //after request is sent rather than after waiting for a response.\n    () => {\n      req._buf = undefined;\n      this._pm.releaseBuffer(buf);\n    });\n  }\n  get serialVersion() {\n    return this._pm.serialVersion;\n  }\n  async execute(op, req) {\n    op.applyDefaults(req, this._config);\n    op.setProtocolVersion(this, req);\n    op.validate(req);\n    req._op = op;\n    if (this._rlClient != null && op.supportsRateLimiting) {\n      this._rlClient.initRequest(req);\n    }\n    const startTime = Date.now();\n    let timeout = req.opt.timeout;\n    let remaining = timeout;\n    let numRetries = 1;\n    let res;\n    for (;;) {\n      if (this._rlClient != null && op.supportsRateLimiting) {\n        await this._rlClient.startRequest(req, remaining, timeout, numRetries);\n      }\n      try {\n        res = await this._executeOnce(op, req);\n        break;\n      } catch (err) {\n        timeout = err.errorCode === ErrorCode.SECURITY_INFO_UNAVAILABLE ? Math.max(req.opt.securityInfoTimeout, req.opt.timeout) : req.opt.timeout;\n        remaining = startTime + timeout - Date.now();\n\n        //If remaining <= 0, we will throw NoSQLTimeoutError below.\n        if (remaining > 0 && op.handleUnsupportedProtocol(this, req, err)) {\n          //Since we changed protocol version(s), set new protocol\n          //version(s) and revalidate the request before continuing.\n          op.setProtocolVersion(this, req);\n          op.validate(req);\n          continue;\n        }\n        if (this._rlClient != null && op.supportsRateLimiting) {\n          this._rlClient.onError(req, err);\n        }\n        if (!err.retryable || !req.opt.retry.handler.doRetry(req, numRetries, err)) {\n          this.emit('error', err, req);\n          throw err;\n        }\n        const delay = req.opt.retry.handler.delay(req, numRetries, err);\n        remaining -= delay;\n        if (remaining <= 0) {\n          throw new NoSQLTimeoutError(timeout, numRetries, req, err);\n        }\n        this.emit('retryable', err, req, numRetries);\n        req.lastError = err;\n        numRetries++;\n\n        //Adjust HTTP request timeout for the time already elapsed.\n        req.opt.requestTimeout = Math.min(remaining, Limits.MAX_REQUEST_TIMEOUT);\n        await sleep(delay);\n\n        //Handle case where protocol version(s) have been changed by\n        //another concurrent request.\n        if (op.protocolChanged(this, req)) {\n          op.setProtocolVersion(this, req);\n          op.validate(req);\n        }\n      }\n    }\n    op.onResult(this, req, res);\n    if (this._rlClient != null && op.supportsRateLimiting) {\n      remaining = startTime + timeout - Date.now();\n      await this._rlClient.finishRequest(req, res, remaining);\n    }\n    return res;\n  }\n  shutdown() {\n    this._agent.destroy();\n    if (this._rlClient != null) {\n      this._rlClient.close();\n    }\n  }\n}\nmodule.exports = HttpClient;","map":{"version":3,"names":["assert","require","http","https","EventEmitter","NsonProtocolManager","BinaryProtocolManager","ErrorCode","error","NoSQLNetworkError","NoSQLServiceError","NoSQLTimeoutError","HttpConstants","PACKAGE_VERSION","Limits","RateLimiterClient","promisified","sleep","HttpClient","constructor","config","url","_url","URL","NOSQL_DATA_PATH","_config","_useSSL","protocol","startsWith","_httpMod","_agent","Agent","httpOpt","globalAgent","_pm","_requestId","_sessionCookie","rateLimitingEnabled","_rlClient","_user_agent","process","version","platform","arch","_handleResponse","op","req","res","buf","callback","statusCode","HTTP_OK","cookie","headers","SET_COOKIE","Array","isArray","_setSessionCookie","nosqlRes","deserialize","errOutput","HTTP_BAD_REQUEST","toString","err","_req","releaseBuffer","value","substring","indexOf","_decrementSerialVersion","versionUsed","serialVersion","decrementSerialVersion","_executeOnceWithAuth","auth","endSend","reqId","_buf","opt","requestTimeout","hostname","port","path","pathname","method","POST","HOST","host","REQUEST_ID","CONNECTION","ACCEPT","contentType","USER_AGENT","CONTENT_TYPE","CONTENT_LENGTH","getContentLength","agent","timeout","AUTHORIZATION","Object","assign","COOKIE","namespace","NAMESPACE","httpReq","request","encoding","setEncoding","getBuffer","on","chunk","addChunk","write","getContent","end","_executeOnce","serialize","_protoMgr","provider","getAuthorization","undefined","execute","applyDefaults","setProtocolVersion","validate","_op","supportsRateLimiting","initRequest","startTime","Date","now","remaining","numRetries","startRequest","errorCode","SECURITY_INFO_UNAVAILABLE","Math","max","securityInfoTimeout","handleUnsupportedProtocol","onError","retryable","retry","handler","doRetry","emit","delay","lastError","min","MAX_REQUEST_TIMEOUT","protocolChanged","onResult","finishRequest","shutdown","destroy","close","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/http_client.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst http = require('http');\nconst https = require('https');\nconst EventEmitter = require('events');\nconst NsonProtocolManager = require('./nson_protocol/protocol_manager');\nconst BinaryProtocolManager = require('./binary_protocol/protocol_manager');\nconst ErrorCode = require('./error_code');\nconst error = require('./error');\nconst NoSQLNetworkError = error.NoSQLNetworkError;\nconst NoSQLServiceError = error.NoSQLServiceError;\nconst NoSQLTimeoutError = error.NoSQLTimeoutError;\nconst HttpConstants = require('./constants').HttpConstants;\nconst PACKAGE_VERSION = require('./constants').PACKAGE_VERSION;\nconst Limits = require('./constants').Limits;\nconst RateLimiterClient = require('./rate_limiter/client');\nconst promisified = require('./utils').promisified;\nconst sleep = require('./utils').sleep;\n\nclass HttpClient extends EventEmitter {\n\n    constructor(config) {\n        super();\n        //This shouldn't throw since we already validated the endpoint in\n        //Config._endpoint2url()\n        assert(config.url);\n        this._url = new URL(HttpConstants.NOSQL_DATA_PATH, config.url);\n\n        this._config = config;\n        this._useSSL = this._url.protocol.startsWith('https');\n        this._httpMod = this._useSSL ? https : http;\n        if ('httpOpt' in config) {\n            this._agent = new this._httpMod.Agent(config.httpOpt);\n        }\n        else {\n            this._agent = this._httpMod.globalAgent;\n        }\n\n        //can be customized to use other protocols\n        this._pm = NsonProtocolManager;\n        this._requestId = 1;\n\n        // Session cookie\n        this._sessionCookie = null;\n\n        //init rate limiting if enabled\n        if (RateLimiterClient.rateLimitingEnabled(config)) {\n            this._rlClient = new RateLimiterClient(this);\n        }\n\n        // user-agent string\n        this._user_agent = 'NoSQL-NodeSDK/' + PACKAGE_VERSION +\n            '(node.js ' + process.version + '; ' + process.platform +\n            '/' + process.arch + ')';\n    }\n\n    _handleResponse(op, req, res, buf, callback) {\n        try {\n            if (res.statusCode == HttpConstants.HTTP_OK) {\n                // is there a set-cookie header? If so, use it\n                var cookie = res.headers[HttpConstants.SET_COOKIE];\n                if (cookie != null) {\n                    if (Array.isArray(cookie)) {\n                        cookie = cookie[0];\n                    }\n                    this._setSessionCookie(cookie);\n                }\n                const nosqlRes = op.deserialize(this._pm, buf, req);\n                return callback(null, nosqlRes);\n            } else {\n                let errOutput;\n                if (res.statusCode == HttpConstants.HTTP_BAD_REQUEST) {\n                    errOutput = buf.toString('utf8');\n                }\n                return callback(new NoSQLServiceError(res, errOutput,\n                    req));\n            }\n        } catch(err) {\n            err._req = req;\n            return callback(err);\n        } finally {\n            this._pm.releaseBuffer(buf);\n        }\n    }\n\n    _setSessionCookie(cookie) {\n        if (cookie.startsWith('session=')) {\n            var value = cookie.substring(0, cookie.indexOf(';'));\n            this._sessionCookie = value;\n        }\n    }\n\n    _decrementSerialVersion(versionUsed) {\n        //The purpose of checking versionUsed is to avoid a race condition\n        //where _decrementSerialVersion() gets called called concurrently by\n        //mutliple requests and thus decrements the serial version twice\n        //without retrying the request with the intermediate version.\n        if (this._pm.serialVersion !== versionUsed) {\n            return true;\n        }\n\n        //Check if current protocol can decrement its serial version.\n        if (this._pm.decrementSerialVersion()) {\n            return true;\n        }\n        \n        //If not and the current protocol is Nson, switch to binary protocol.\n        if (this._pm === NsonProtocolManager) {\n            this._pm = BinaryProtocolManager;\n            return true;\n        }\n\n        return false;\n    }\n\n    _executeOnceWithAuth(op, req, auth, endSend, callback) {\n        const reqId = this._requestId++;\n        assert(req._buf);\n        assert(req.opt.requestTimeout);\n\n        const httpOpt = {\n            hostname: this._url.hostname,\n            port: this._url.port,\n            path: this._url.pathname,\n            method: HttpConstants.POST,\n            headers: {\n                [HttpConstants.HOST]: this._url.host,\n                [HttpConstants.REQUEST_ID]: reqId,\n                [HttpConstants.CONNECTION]: 'keep-alive',\n                [HttpConstants.ACCEPT]: this._pm.contentType,\n                [HttpConstants.USER_AGENT]: this._user_agent,\n                [HttpConstants.CONTENT_TYPE]: this._pm.contentType,\n                [HttpConstants.CONTENT_LENGTH]: this._pm.getContentLength(\n                    req._buf)\n            },\n            agent: this._agent,\n            timeout: req.opt.requestTimeout\n        };\n        if (typeof auth === 'string') {\n            httpOpt.headers[HttpConstants.AUTHORIZATION] = auth;\n        } else if (auth != null) {\n            Object.assign(httpOpt.headers, auth);\n        }\n\n        if (this._sessionCookie != null) {\n            httpOpt.headers[HttpConstants.COOKIE] = this._sessionCookie;\n        }\n\n        if (req.opt.namespace != null) {\n            httpOpt.headers[HttpConstants.NAMESPACE] = req.opt.namespace;\n        }\n\n        const httpReq = this._httpMod.request(httpOpt, (res) => {\n            if (this._pm.encoding) {\n                res.setEncoding(this._pm.encoding);\n            }\n            const buf = this._pm.getBuffer();\n            res.on('data', (chunk) => {\n                this._pm.addChunk(buf, chunk);\n            });\n            res.on('end', () => {\n                this._handleResponse(op, req, res, buf, callback);\n            });\n        }).on('error', (err) =>\n            callback(new NoSQLNetworkError(null, req, err)));\n\n        //This code should not throw synchronously. The code that can throw\n        //have been moved to _executeOnce().\n        httpReq.write(this._pm.getContent(req._buf), this._pm.encoding);\n        httpReq.end(endSend);\n    }\n\n    async _executeOnce(op, req) {\n        const buf = this._pm.getBuffer();\n        let auth;\n        try {\n            op.serialize(this._pm, buf, req);\n            //Allow auth provider to use request content. This is needed for\n            //cross-region authentication in the Cloud. ProtoMgr is used to\n            //get content, content type type and length in\n            //protocol-independent manner.\n            req._protoMgr = this._pm;\n            req._buf = buf;\n            auth = await this._config.auth.provider.getAuthorization(req);\n        } catch(err) {\n            req._buf = undefined;\n            this._pm.releaseBuffer(buf);\n            err._req = req;\n            throw err;\n        }\n\n        return promisified(this, this._executeOnceWithAuth, op, req, auth,\n            //Small optimization to release buffer (for reuse) immediately\n            //after request is sent rather than after waiting for a response.\n            () => {\n                req._buf = undefined;\n                this._pm.releaseBuffer(buf);\n            });\n    }\n\n    get serialVersion() {\n        return this._pm.serialVersion;\n    }\n\n    async execute(op, req) {\n        op.applyDefaults(req, this._config);\n        op.setProtocolVersion(this, req);\n        op.validate(req);\n        req._op = op;\n\n        if (this._rlClient != null && op.supportsRateLimiting) {\n            this._rlClient.initRequest(req);\n        }\n\n        const startTime = Date.now();\n        let timeout = req.opt.timeout;\n        let remaining = timeout;\n        let numRetries = 1;\n        let res;\n\n        for(;;) {\n            if (this._rlClient != null && op.supportsRateLimiting) {\n                await this._rlClient.startRequest(req, remaining, timeout,\n                    numRetries);\n            }\n            try {\n                res = await this._executeOnce(op, req);\n                break;\n            } catch(err) {\n                timeout = err.errorCode ===\n                    ErrorCode.SECURITY_INFO_UNAVAILABLE ?\n                    Math.max(req.opt.securityInfoTimeout, req.opt.timeout) :\n                    req.opt.timeout;\n                remaining = startTime + timeout - Date.now();\n\n                //If remaining <= 0, we will throw NoSQLTimeoutError below.\n                if (remaining > 0 &&\n                    op.handleUnsupportedProtocol(this, req, err)) {\n                    //Since we changed protocol version(s), set new protocol\n                    //version(s) and revalidate the request before continuing.\n                    op.setProtocolVersion(this, req);\n                    op.validate(req);\n                    continue;\n                }\n\n                if (this._rlClient != null && op.supportsRateLimiting) {\n                    this._rlClient.onError(req, err);\n                }\n\n                if (!err.retryable || !req.opt.retry.handler.doRetry(\n                    req, numRetries, err)) {\n                    this.emit('error', err, req);\n                    throw err;\n                }\n\n                const delay = req.opt.retry.handler.delay(req, numRetries,\n                    err);\n                remaining -= delay;\n\n                if (remaining <= 0) {\n                    throw new NoSQLTimeoutError(timeout, numRetries, req,\n                        err);\n                }\n\n                this.emit('retryable', err, req, numRetries);\n                req.lastError = err;                \n                numRetries++;\n                \n                //Adjust HTTP request timeout for the time already elapsed.\n                req.opt.requestTimeout = Math.min(remaining,\n                    Limits.MAX_REQUEST_TIMEOUT);\n\n                await sleep(delay);\n\n                //Handle case where protocol version(s) have been changed by\n                //another concurrent request.\n                if (op.protocolChanged(this, req)) {\n                    op.setProtocolVersion(this, req);\n                    op.validate(req);\n                }\n            }\n        }\n\n        op.onResult(this, req, res);\n        if (this._rlClient != null && op.supportsRateLimiting) {\n            remaining = startTime + timeout - Date.now();\n            await this._rlClient.finishRequest(req, res, remaining);\n        }\n\n        return res;\n    }\n\n    shutdown() {\n        this._agent.destroy();\n        if (this._rlClient != null) {\n            this._rlClient.close();\n        }\n    }\n}\n\nmodule.exports = HttpClient;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}