{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst isInt32 = require('../utils').isInt32;\nconst sortMapEntries = require('../utils').sortMapEntries;\nconst TableState = require('../constants').TableState;\nconst AdminState = require('../constants').AdminState;\nconst ScanDirection = require('../constants').ScanDirection;\nconst ServiceType = require('../constants').ServiceType;\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst CapacityMode = require('../constants').CapacityMode;\nconst Type = require('./constants').Type;\nconst TTLTimeUnit = require('./constants').TTLTimeUnit;\nconst MathContext = require('./constants').MathContext;\nconst ErrorCode = require('../error_code');\nconst error = require('../error');\nconst NoSQLError = error.NoSQLError;\nconst NoSQLArgumentError = error.NoSQLArgumentError;\nconst NoSQLProtocolError = error.NoSQLProtocolError;\nclass Protocol {\n  //Consider special cases where error code/message needs to be changed.\n  static _createError(errCode, msg, req) {\n    assert(req && req._op);\n    switch (errCode) {\n      case ErrorCode.BAD_PROTOCOL_MESSAGE:\n        //Older servers will send this message when they don't support\n        //current query version.\n        if (msg && msg.toLowerCase().includes('invalid query version')) {\n          errCode = ErrorCode.UNSUPPORTED_QUERY_VERSION;\n        }\n        break;\n      case ErrorCode.TABLE_NOT_FOUND:\n        //Special case for TABLE_NOT_FOUND errors on writeMany with\n        //multiple tables. Earlier server versions do not support this and\n        //will return a TABLE_NOT_FOUND error with the table names in a\n        //single string, separated by commas, with no brackets, like:\n        //table1,table2,table3\n        //Later versions may legitimately return TABLE_NOT_FOUND error,\n        //but table names will be inside a bracketed list, like:\n        //[table1, table2, table3]\n\n        //Using string comparison for op's name to avoid introducing\n        //another dependency on ops module.\n        if (req._op.name === 'WriteMultipleOp' && req.tableName == null && msg && msg.includes(',') && !msg.includes('[')) {\n          errCode = ErrorCode.OPERATION_NOT_SUPPORTED;\n          msg = 'WriteMany operation with multiple tables is not \\\nsupported by the version of the connected server';\n        }\n        break;\n      default:\n        break;\n    }\n    return NoSQLError.create(errCode, msg, null, req);\n  }\n\n  //Serialization.\n\n  static writeTimeout(dw, timeout) {\n    dw.writeInt(timeout);\n  }\n  static writeConsistency(dw, cons) {\n    dw.writeByte(cons.ordinal);\n  }\n  static writeScanDirection(dw, dir) {\n    if (!dir) {\n      dir = ScanDirection.UNORDERED;\n    }\n    dw.writeByte(dir.ordinal);\n  }\n\n  //Assumes ttl already in canonical form, see TTLUtil#validate()\n  static writeTTL(dw, ttl) {\n    if (ttl == null) {\n      //null or undefined\n      return dw.writeLong(-1);\n    }\n    if (ttl.days != null) {\n      dw.writeLong(ttl.days !== Infinity ? ttl.days : 0);\n      return dw.writeByte(TTLTimeUnit.DAYS);\n    }\n    assert(ttl.hours != null);\n    dw.writeLong(ttl.hours);\n    dw.writeByte(TTLTimeUnit.HOURS);\n  }\n  static writeArray(dw, array, opt) {\n    const lengthOffset = dw.buffer.length;\n    dw.writeInt32BE(0);\n    const start = dw.buffer.length;\n    dw.writeInt32BE(array.length);\n    for (let val of array) {\n      this.writeFieldValue(dw, val, opt);\n    }\n    dw.buffer.writeInt32BE(dw.buffer.length - start, lengthOffset);\n  }\n  static _writeMapEntries(dw, ent, cnt, opt) {\n    if (opt._writeSortedMaps) {\n      //used by the query code to serialize grouping columns of type MAP\n      ent = sortMapEntries(ent);\n    }\n    const lengthOffset = dw.buffer.length;\n    dw.writeInt32BE(0);\n    const start = dw.buffer.length;\n    dw.writeInt32BE(cnt);\n    for (let [key, val] of ent) {\n      if (typeof key !== 'string') {\n        throw new NoSQLArgumentError(`Invalid map or object key for \\\nfield value: ${key}, must be a string`);\n      }\n      dw.writeString(key);\n      this.writeFieldValue(dw, val, opt);\n    }\n    dw.buffer.writeInt32BE(dw.buffer.length - start, lengthOffset);\n  }\n  static writeMap(dw, map, opt) {\n    this._writeMapEntries(dw, map.entries(), map.size, opt);\n  }\n  static writeObject(dw, obj, opt) {\n    const ent = Object.entries(obj);\n    this._writeMapEntries(dw, ent, ent.length, opt);\n  }\n  static writeVersion(dw, version) {\n    dw.writeBinary(version);\n  }\n  static writeOpCode(dw, opCode, serialVersion) {\n    dw.writeInt16BE(serialVersion);\n    dw.writeByte(opCode);\n  }\n  static writeSubOpCode(dw, opCode) {\n    dw.writeByte(opCode);\n  }\n  static writeFieldRange(dw, fr, opt) {\n    if (!fr) {\n      dw.writeBoolean(false);\n      return;\n    }\n    dw.writeBoolean(true);\n    dw.writeString(fr.fieldName);\n    if (fr.startWith) {\n      dw.writeBoolean(true);\n      this.writeFieldValue(dw, fr.startWith, opt);\n      dw.writeBoolean(true);\n    } else if (fr.startAfter) {\n      dw.writeBoolean(true);\n      this.writeFieldValue(dw, fr.startAfter, opt);\n      dw.writeBoolean(false);\n    } else {\n      dw.writeBoolean(false);\n    }\n    if (fr.endWith) {\n      dw.writeBoolean(true);\n      this.writeFieldValue(dw, fr.endWith, opt);\n      dw.writeBoolean(true);\n    } else if (fr.endBefore) {\n      dw.writeBoolean(true);\n      this.writeFieldValue(dw, fr.endBefore, opt);\n      dw.writeBoolean(false);\n    } else {\n      dw.writeBoolean(false);\n    }\n  }\n  static writeFieldValue(dw, val, opt) {\n    if (opt._replacer) {\n      val = opt._replacer(val, opt);\n    }\n    if (typeof val === 'function') {\n      //If the field specified as a function, we write its return value\n      val = val();\n    }\n    if (val === undefined) {\n      return dw.writeByte(Type.NULL);\n    }\n    if (val === null) {\n      return dw.writeByte(Type.JSON_NULL);\n    }\n    switch (typeof val) {\n      case 'boolean':\n        dw.writeByte(Type.BOOLEAN);\n        dw.writeBoolean(val);\n        break;\n      case 'string':\n        dw.writeByte(Type.STRING);\n        dw.writeString(val);\n        break;\n      case 'number':\n        if (Number.isSafeInteger(val)) {\n          if (isInt32(val)) {\n            dw.writeByte(Type.INTEGER);\n            dw.writeInt(val);\n          } else {\n            dw.writeByte(Type.LONG);\n            dw.writeLong(val);\n          }\n        } else {\n          dw.writeByte(Type.DOUBLE);\n          dw.writeDouble(val);\n        }\n        break;\n      case 'bigint':\n        dw.writeByte(Type.LONG);\n        dw.writeLong(val);\n        break;\n      case 'object':\n        if (Buffer.isBuffer(val)) {\n          dw.writeByte(Type.BINARY);\n          dw.writeBinary(val);\n          break;\n        } else if (val instanceof Date) {\n          dw.writeByte(Type.TIMESTAMP);\n          dw.writeDate(val);\n          break;\n        } else if (Array.isArray(val)) {\n          dw.writeByte(Type.ARRAY);\n          this.writeArray(dw, val, opt);\n          break;\n        } else if (opt._dbNumber != null && opt._dbNumber.isInstance(val)) {\n          dw.writeByte(Type.NUMBER);\n          dw.writeString(opt._dbNumber.stringValue(val));\n          break;\n        } else {\n          dw.writeByte(Type.MAP);\n          if (val instanceof Map) {\n            this.writeMap(dw, val, opt);\n          } else {\n            this.writeObject(dw, val, opt);\n          }\n          break;\n        }\n      default:\n        throw new NoSQLArgumentError('Unsupported value type ' + `${typeof val} for value ${val.toString()}`);\n    }\n  }\n  static serializeRequest(dw, req) {\n    assert(req.opt.requestTimeout);\n    this.writeTimeout(dw, req.opt.requestTimeout);\n  }\n  static serializeReadRequest(dw, req) {\n    this.serializeRequest(dw, req);\n    dw.writeString(req.tableName);\n    this.writeConsistency(dw, req.opt.consistency);\n  }\n  static serializeWriteRequest(dw, req, serialVersion) {\n    this.serializeRequest(dw, req);\n    dw.writeString(req.tableName);\n    dw.writeBoolean(req.opt.returnExisting);\n    this.writeDurability(dw, req.opt.durability, serialVersion);\n  }\n  static durabilityToNum(dur) {\n    if (dur == null) {\n      return 0;\n    }\n    let val = dur.masterSync.ordinal;\n    val |= dur.replicaSync.ordinal << 2;\n    val |= dur.replicaAck.ordinal << 4;\n    return val;\n  }\n  static writeDurability(dw, dur, serialVersion) {\n    if (serialVersion < 3) {\n      return;\n    }\n    dw.writeByte(this.durabilityToNum(dur));\n  }\n  static writeMathContext(dw, opt) {\n    if (opt._dbNumber == null) {\n      return dw.writeByte(MathContext.DEFAULT);\n    }\n    dw.writeByte(MathContext.CUSTOM);\n    dw.writeInt32BE(opt._dbNumber.precision);\n    dw.writeInt32BE(opt._dbNumber.roundingMode);\n  }\n\n  //Deserialization.\n\n  static readArray(dr, opt) {\n    dr.readInt32BE(); //read total length\n    const len = dr.readInt32BE();\n    const array = new Array(len);\n    for (let i = 0; i < len; i++) {\n      array[i] = this.readFieldValue(dr, opt);\n    }\n    return array;\n  }\n\n  //For now, we will use readObject() for Map columns because currently\n  //both Record and Map columns are sent with the same type code and it is\n  //more natural to represent Record value as object.  IMO, it is more\n  //adequate for now to represent Map value as object than to represent\n  //Record value as JavaScript Map.\n  static readMap(dr, opt) {\n    dr.readInt32BE(); //read total length\n    const size = dr.readInt32BE();\n    const map = new Map();\n    for (let i = 0; i < size; i++) {\n      const key = dr.readString();\n      const val = this.readFieldValue(dr, opt);\n      map.set(key, val);\n    }\n    return map;\n  }\n  static readObject(dr, opt) {\n    dr.readInt32BE(); //read total length\n    const size = dr.readInt32BE();\n    const obj = {};\n    for (let i = 0; i < size; i++) {\n      const key = dr.readString();\n      const val = this.readFieldValue(dr, opt);\n      obj[key] = val;\n    }\n    return obj;\n  }\n  static readFieldValue(dr, opt) {\n    const type = dr.readByte();\n    switch (type) {\n      case Type.ARRAY:\n        return this.readArray(dr, opt);\n      case Type.BINARY:\n        return dr.readBinary();\n      case Type.BOOLEAN:\n        return dr.readBoolean();\n      case Type.DOUBLE:\n        return dr.readDouble();\n      case Type.INTEGER:\n        return dr.readInt();\n      case Type.LONG:\n        return dr.readLong(opt.longAsBigInt);\n      case Type.MAP:\n        //Until Record type code is added to the protocol\n        return this.readObject(dr, opt);\n      case Type.STRING:\n        return dr.readString();\n      case Type.TIMESTAMP:\n        return dr.readDate();\n      case Type.NUMBER:\n        return opt._dbNumber != null ? opt._dbNumber.create(dr.readString()) : Number(dr.readString());\n      case Type.NULL:\n        return undefined;\n      case Type.JSON_NULL:\n        return null;\n      case Type.EMPTY:\n        return EMPTY_VALUE;\n      default:\n        throw new NoSQLProtocolError(`Unknown value type code: ${type}`);\n    }\n  }\n  static readRecord(dr, opt) {\n    const type = dr.readByte();\n    //Until Record type code is added to the protocol\n    if (type !== Type.MAP) {\n      throw new NoSQLProtocolError(`Unexpected type code for row: \\\n${type}, expecting ${Type.MAP} (map)`);\n    }\n    return this.readObject(dr, opt, true);\n  }\n  static readVersion(dr) {\n    return dr.readBinary();\n  }\n  static deserializeConsumedCapacity(dr, res, opt) {\n    const readUnits = dr.readInt();\n    const readKB = dr.readInt();\n    const writeKB = dr.readInt();\n    if (opt.serviceType !== ServiceType.KVSTORE) {\n      res.consumedCapacity = {\n        readUnits,\n        readKB,\n        writeUnits: writeKB,\n        writeKB\n      };\n    }\n  }\n  static deserializeWriteResponse(dr, opt, res, serialVersion) {\n    const returnInfo = dr.readBoolean();\n    if (returnInfo) {\n      res.existingRow = this.readRecord(dr, opt);\n      res.existingVersion = this.readVersion(dr);\n      if (serialVersion > 2) {\n        res.existingModificationTime = new Date(dr.readLong());\n      }\n    }\n    return res;\n  }\n  static deserializeWriteResponseWithId(dr, opt, res, serialVersion) {\n    this.deserializeWriteResponse(dr, opt, res, serialVersion);\n    if (dr.readBoolean()) {\n      //has generated id column value\n      res.generatedValue = this.readFieldValue(dr, opt);\n    }\n    return res;\n  }\n  static deserializeTableResult(dr, opt, serialVersion) {\n    const res = {};\n    const hasInfo = dr.readBoolean();\n    if (hasInfo) {\n      const compartmentId = dr.readString();\n      if (opt.serviceType === ServiceType.CLOUD) {\n        res.compartmentId = compartmentId;\n      }\n      res.tableName = dr.readString();\n      res.tableState = TableState.fromOrdinal(dr.readByte());\n    }\n    const hasStaticState = dr.readBoolean();\n    if (hasStaticState) {\n      const readUnits = dr.readInt();\n      const writeUnits = dr.readInt();\n      const storageGB = dr.readInt();\n      let mode = CapacityMode.PROVISIONED;\n      if (serialVersion > 2) {\n        mode = CapacityMode.fromOrdinal(dr.readByte());\n      }\n      if (opt.serviceType !== ServiceType.KVSTORE) {\n        res.tableLimits = {\n          readUnits,\n          writeUnits,\n          storageGB,\n          mode\n        };\n      }\n      res.schema = dr.readString();\n    }\n    res.operationId = dr.readString();\n    return res;\n  }\n  static readTopologyInfo(dr) {\n    const seqNum = dr.readInt();\n    if (seqNum < -1) {\n      throw new NoSQLProtocolError(`Invalid topology sequence number: ${seqNum}`);\n    }\n    if (seqNum === -1) {\n      //No topology info sent by proxy\n      return null;\n    }\n    const shardIds = dr.readIntArray();\n    return {\n      seqNum,\n      shardIds\n    };\n  }\n  static mapError(rc, msg, req) {\n    let errCode;\n    try {\n      errCode = ErrorCode.fromOrdinal(rc);\n    } catch (err) {\n      return new NoSQLProtocolError('Received invalid error code: ' + rc, err, req);\n    }\n    const err = this._createError(errCode, msg, req);\n    err._rejectedByDriver = false; //for testing\n    return err;\n  }\n  static deserializeSystemResult(dr) {\n    const res = {};\n    res.state = AdminState.fromOrdinal(dr.readByte());\n    res.operationId = dr.readString();\n    res.statement = dr.readString();\n    res.output = dr.readString();\n    return res;\n  }\n}\nmodule.exports = Protocol;","map":{"version":3,"names":["assert","require","isInt32","sortMapEntries","TableState","AdminState","ScanDirection","ServiceType","EMPTY_VALUE","CapacityMode","Type","TTLTimeUnit","MathContext","ErrorCode","error","NoSQLError","NoSQLArgumentError","NoSQLProtocolError","Protocol","_createError","errCode","msg","req","_op","BAD_PROTOCOL_MESSAGE","toLowerCase","includes","UNSUPPORTED_QUERY_VERSION","TABLE_NOT_FOUND","name","tableName","OPERATION_NOT_SUPPORTED","create","writeTimeout","dw","timeout","writeInt","writeConsistency","cons","writeByte","ordinal","writeScanDirection","dir","UNORDERED","writeTTL","ttl","writeLong","days","Infinity","DAYS","hours","HOURS","writeArray","array","opt","lengthOffset","buffer","length","writeInt32BE","start","val","writeFieldValue","_writeMapEntries","ent","cnt","_writeSortedMaps","key","writeString","writeMap","map","entries","size","writeObject","obj","Object","writeVersion","version","writeBinary","writeOpCode","opCode","serialVersion","writeInt16BE","writeSubOpCode","writeFieldRange","fr","writeBoolean","fieldName","startWith","startAfter","endWith","endBefore","_replacer","undefined","NULL","JSON_NULL","BOOLEAN","STRING","Number","isSafeInteger","INTEGER","LONG","DOUBLE","writeDouble","Buffer","isBuffer","BINARY","Date","TIMESTAMP","writeDate","Array","isArray","ARRAY","_dbNumber","isInstance","NUMBER","stringValue","MAP","Map","toString","serializeRequest","requestTimeout","serializeReadRequest","consistency","serializeWriteRequest","returnExisting","writeDurability","durability","durabilityToNum","dur","masterSync","replicaSync","replicaAck","writeMathContext","DEFAULT","CUSTOM","precision","roundingMode","readArray","dr","readInt32BE","len","i","readFieldValue","readMap","readString","set","readObject","type","readByte","readBinary","readBoolean","readDouble","readInt","readLong","longAsBigInt","readDate","EMPTY","readRecord","readVersion","deserializeConsumedCapacity","res","readUnits","readKB","writeKB","serviceType","KVSTORE","consumedCapacity","writeUnits","deserializeWriteResponse","returnInfo","existingRow","existingVersion","existingModificationTime","deserializeWriteResponseWithId","generatedValue","deserializeTableResult","hasInfo","compartmentId","CLOUD","tableState","fromOrdinal","hasStaticState","storageGB","mode","PROVISIONED","tableLimits","schema","operationId","readTopologyInfo","seqNum","shardIds","readIntArray","mapError","rc","err","_rejectedByDriver","deserializeSystemResult","state","statement","output","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/binary_protocol/protocol.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\n\nconst isInt32 = require('../utils').isInt32;\nconst sortMapEntries = require('../utils').sortMapEntries;\nconst TableState = require('../constants').TableState;\nconst AdminState = require('../constants').AdminState;\nconst ScanDirection = require('../constants').ScanDirection;\nconst ServiceType = require('../constants').ServiceType;\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst CapacityMode = require('../constants').CapacityMode;\nconst Type = require('./constants').Type;\nconst TTLTimeUnit = require('./constants').TTLTimeUnit;\nconst MathContext = require('./constants').MathContext;\n\nconst ErrorCode = require('../error_code');\nconst error = require('../error');\nconst NoSQLError = error.NoSQLError;\nconst NoSQLArgumentError = error.NoSQLArgumentError;\nconst NoSQLProtocolError = error.NoSQLProtocolError;\n\nclass Protocol {\n\n    //Consider special cases where error code/message needs to be changed.\n    static _createError(errCode, msg, req) {\n        assert(req && req._op);\n\n        switch(errCode) {\n        case ErrorCode.BAD_PROTOCOL_MESSAGE:\n            //Older servers will send this message when they don't support\n            //current query version.\n            if (msg && msg.toLowerCase().includes('invalid query version')) {\n                errCode = ErrorCode.UNSUPPORTED_QUERY_VERSION;\n            }\n            break;\n        case ErrorCode.TABLE_NOT_FOUND:\n            //Special case for TABLE_NOT_FOUND errors on writeMany with\n            //multiple tables. Earlier server versions do not support this and\n            //will return a TABLE_NOT_FOUND error with the table names in a\n            //single string, separated by commas, with no brackets, like:\n            //table1,table2,table3\n            //Later versions may legitimately return TABLE_NOT_FOUND error,\n            //but table names will be inside a bracketed list, like:\n            //[table1, table2, table3]\n\n            //Using string comparison for op's name to avoid introducing\n            //another dependency on ops module.\n            if (req._op.name === 'WriteMultipleOp' && req.tableName == null &&\n                msg && msg.includes(',') && !msg.includes('[')) {\n                errCode = ErrorCode.OPERATION_NOT_SUPPORTED;\n                msg = 'WriteMany operation with multiple tables is not \\\nsupported by the version of the connected server';\n            }\n            break;\n        default:\n            break;\n        }\n\n        return NoSQLError.create(errCode, msg, null, req);\n    }\n\n    //Serialization.\n\n    static writeTimeout(dw, timeout) {\n        dw.writeInt(timeout);\n    }\n\n    static writeConsistency(dw, cons) {\n        dw.writeByte(cons.ordinal);\n    }\n\n    static writeScanDirection(dw, dir) {\n        if (!dir) {\n            dir = ScanDirection.UNORDERED;\n        }\n        dw.writeByte(dir.ordinal);\n    }\n\n    //Assumes ttl already in canonical form, see TTLUtil#validate()\n    static writeTTL(dw, ttl) {\n        if (ttl == null) { //null or undefined\n            return dw.writeLong(-1);\n        }\n        if (ttl.days != null) {\n            dw.writeLong(ttl.days !== Infinity ? ttl.days : 0);\n            return dw.writeByte(TTLTimeUnit.DAYS);\n        }\n        assert(ttl.hours != null);\n        dw.writeLong(ttl.hours);\n        dw.writeByte(TTLTimeUnit.HOURS);\n    }\n\n    static writeArray(dw, array, opt) {\n        const lengthOffset = dw.buffer.length;\n        dw.writeInt32BE(0);\n        const start = dw.buffer.length;\n\n        dw.writeInt32BE(array.length);\n        for(let val of array) {\n            this.writeFieldValue(dw, val, opt);\n        }\n\n        dw.buffer.writeInt32BE(dw.buffer.length - start, lengthOffset);\n    }\n\n    static _writeMapEntries(dw, ent, cnt, opt) {\n        if (opt._writeSortedMaps) {\n            //used by the query code to serialize grouping columns of type MAP\n            ent = sortMapEntries(ent);\n        }\n\n        const lengthOffset = dw.buffer.length;\n        dw.writeInt32BE(0);\n        const start = dw.buffer.length;\n\n        dw.writeInt32BE(cnt);\n        for(let [key, val] of ent) {\n            if (typeof key !== 'string') {\n                throw new NoSQLArgumentError(`Invalid map or object key for \\\nfield value: ${key}, must be a string`);\n            }\n            dw.writeString(key);\n            this.writeFieldValue(dw, val, opt);\n        }\n\n        dw.buffer.writeInt32BE(dw.buffer.length - start, lengthOffset);\n    }\n\n    static writeMap(dw, map, opt) {\n        this._writeMapEntries(dw, map.entries(), map.size, opt);\n    }\n\n    static writeObject(dw, obj, opt) {\n        const ent = Object.entries(obj);\n        this._writeMapEntries(dw, ent, ent.length, opt);\n    }\n\n    static writeVersion(dw, version) {\n        dw.writeBinary(version);\n    }\n\n    static writeOpCode(dw, opCode, serialVersion) {\n        dw.writeInt16BE(serialVersion);\n        dw.writeByte(opCode);\n    }\n\n    static writeSubOpCode(dw, opCode) {\n        dw.writeByte(opCode);\n    }\n\n    static writeFieldRange(dw, fr, opt) {\n        if (!fr) {\n            dw.writeBoolean(false);\n            return;\n        }\n\n        dw.writeBoolean(true);\n        dw.writeString(fr.fieldName);\n\n        if (fr.startWith) {\n            dw.writeBoolean(true);\n            this.writeFieldValue(dw, fr.startWith, opt);\n            dw.writeBoolean(true);\n        } else if (fr.startAfter) {\n            dw.writeBoolean(true);\n            this.writeFieldValue(dw, fr.startAfter, opt);\n            dw.writeBoolean(false);\n        } else {\n            dw.writeBoolean(false);\n        }\n\n        if (fr.endWith) {\n            dw.writeBoolean(true);\n            this.writeFieldValue(dw, fr.endWith, opt);\n            dw.writeBoolean(true);\n        } else if (fr.endBefore) {\n            dw.writeBoolean(true);\n            this.writeFieldValue(dw, fr.endBefore, opt);\n            dw.writeBoolean(false);\n        } else {\n            dw.writeBoolean(false);\n        }\n    }\n\n    static writeFieldValue(dw, val, opt) {\n        if (opt._replacer) {\n            val = opt._replacer(val, opt);\n        }\n        if (typeof val === 'function') {\n            //If the field specified as a function, we write its return value\n            val = val();\n        }\n        if (val === undefined) {\n            return dw.writeByte(Type.NULL);\n        }\n        if (val === null) {\n            return dw.writeByte(Type.JSON_NULL);\n        }\n        switch(typeof val) {\n        case 'boolean':\n            dw.writeByte(Type.BOOLEAN);\n            dw.writeBoolean(val);\n            break;\n        case 'string':\n            dw.writeByte(Type.STRING);\n            dw.writeString(val);\n            break;\n        case 'number':\n            if (Number.isSafeInteger(val)) {\n                if (isInt32(val)) {\n                    dw.writeByte(Type.INTEGER);\n                    dw.writeInt(val);\n                } else {\n                    dw.writeByte(Type.LONG);\n                    dw.writeLong(val);\n                }\n            } else {\n                dw.writeByte(Type.DOUBLE);\n                dw.writeDouble(val);\n            }\n            break;\n        case 'bigint':\n            dw.writeByte(Type.LONG);\n            dw.writeLong(val);\n            break;\n        case 'object':\n            if (Buffer.isBuffer(val)) {\n                dw.writeByte(Type.BINARY);\n                dw.writeBinary(val);\n                break;\n            } else if (val instanceof Date) {\n                dw.writeByte(Type.TIMESTAMP);\n                dw.writeDate(val);\n                break;\n            } else if (Array.isArray(val)) {\n                dw.writeByte(Type.ARRAY);\n                this.writeArray(dw, val, opt);\n                break;\n            } else if (opt._dbNumber != null &&\n                opt._dbNumber.isInstance(val)) {\n                dw.writeByte(Type.NUMBER);\n                dw.writeString(opt._dbNumber.stringValue(val));\n                break;\n            } else {\n                dw.writeByte(Type.MAP);\n                if (val instanceof Map) {\n                    this.writeMap(dw, val, opt);\n                } else {\n                    this.writeObject(dw, val, opt);\n                }\n                break;\n            }\n        default:\n            throw new NoSQLArgumentError('Unsupported value type ' +\n                `${typeof val} for value ${val.toString()}`);\n        }\n    }\n\n    static serializeRequest(dw, req) {\n        assert(req.opt.requestTimeout);\n        this.writeTimeout(dw, req.opt.requestTimeout);\n    }\n\n    static serializeReadRequest(dw, req) {\n        this.serializeRequest(dw, req);\n        dw.writeString(req.tableName);\n        this.writeConsistency(dw, req.opt.consistency);\n    }\n\n    static serializeWriteRequest(dw, req, serialVersion) {\n        this.serializeRequest(dw, req);\n        dw.writeString(req.tableName);\n        dw.writeBoolean(req.opt.returnExisting);\n        this.writeDurability(dw, req.opt.durability, serialVersion);\n    }\n\n    static durabilityToNum(dur) {\n        if (dur == null) {\n            return 0;\n        }\n\n        let val = dur.masterSync.ordinal;\n        val |= (dur.replicaSync.ordinal << 2);\n        val |= (dur.replicaAck.ordinal << 4);\n        return val;\n    }\n\n    static writeDurability(dw, dur, serialVersion) {\n        if (serialVersion < 3) {\n            return;\n        }\n        dw.writeByte(this.durabilityToNum(dur));\n    }\n\n    static writeMathContext(dw, opt) {\n        if (opt._dbNumber == null) {\n            return dw.writeByte(MathContext.DEFAULT);\n        }\n        dw.writeByte(MathContext.CUSTOM);\n        dw.writeInt32BE(opt._dbNumber.precision);\n        dw.writeInt32BE(opt._dbNumber.roundingMode);\n    }\n\n    //Deserialization.\n\n    static readArray(dr, opt) {\n        dr.readInt32BE(); //read total length\n        const len = dr.readInt32BE();\n\n        const array = new Array(len);\n        for(let i = 0; i < len; i++) {\n            array[i] = this.readFieldValue(dr, opt);\n        }\n\n        return array;\n    }\n\n    //For now, we will use readObject() for Map columns because currently\n    //both Record and Map columns are sent with the same type code and it is\n    //more natural to represent Record value as object.  IMO, it is more\n    //adequate for now to represent Map value as object than to represent\n    //Record value as JavaScript Map.\n    static readMap(dr, opt) {\n        dr.readInt32BE(); //read total length\n        const size = dr.readInt32BE();\n\n        const map = new Map();\n        for(let i = 0; i < size; i++) {\n            const key = dr.readString();\n            const val = this.readFieldValue(dr, opt);\n            map.set(key, val);\n        }\n\n        return map;\n    }\n\n    static readObject(dr, opt) {\n        dr.readInt32BE(); //read total length\n        const size = dr.readInt32BE();\n\n        const obj = {};\n        for(let i = 0; i < size; i++) {\n            const key = dr.readString();\n            const val = this.readFieldValue(dr, opt);\n            obj[key] = val;\n        }\n\n        return obj;\n    }\n\n    static readFieldValue(dr, opt) {\n        const type = dr.readByte();\n        switch(type) {\n        case Type.ARRAY:\n            return this.readArray(dr, opt);\n        case Type.BINARY:\n            return dr.readBinary();\n        case Type.BOOLEAN:\n            return dr.readBoolean();\n        case Type.DOUBLE:\n            return dr.readDouble();\n        case Type.INTEGER:\n            return dr.readInt();\n        case Type.LONG:\n            return dr.readLong(opt.longAsBigInt);\n        case Type.MAP:\n            //Until Record type code is added to the protocol\n            return this.readObject(dr, opt);\n        case Type.STRING:\n            return dr.readString();\n        case Type.TIMESTAMP:\n            return dr.readDate();\n        case Type.NUMBER:\n            return (opt._dbNumber != null) ?\n                opt._dbNumber.create(dr.readString()) :\n                Number(dr.readString());\n        case Type.NULL:\n            return undefined;\n        case Type.JSON_NULL:\n            return null;\n        case Type.EMPTY:\n            return EMPTY_VALUE;\n        default:\n            throw new NoSQLProtocolError(`Unknown value type code: ${type}`);\n        }\n    }\n\n    static readRecord(dr, opt) {\n        const type = dr.readByte();\n        //Until Record type code is added to the protocol\n        if (type !== Type.MAP) {\n            throw new NoSQLProtocolError(`Unexpected type code for row: \\\n${type}, expecting ${Type.MAP} (map)`);\n        }\n        return this.readObject(dr, opt, true);\n    }\n\n    static readVersion(dr) {\n        return dr.readBinary();\n    }\n\n    static deserializeConsumedCapacity(dr, res, opt) {\n        const readUnits = dr.readInt();\n        const readKB = dr.readInt();\n        const writeKB = dr.readInt();\n        if (opt.serviceType !== ServiceType.KVSTORE) {\n            res.consumedCapacity = {\n                readUnits,\n                readKB,\n                writeUnits: writeKB,\n                writeKB\n            };\n        }\n    }\n\n    static deserializeWriteResponse(dr, opt, res, serialVersion) {\n        const returnInfo = dr.readBoolean();\n        if (returnInfo) {\n            res.existingRow = this.readRecord(dr, opt);\n            res.existingVersion = this.readVersion(dr);\n            if (serialVersion > 2) {\n                res.existingModificationTime = new Date(dr.readLong());\n            }\n        }\n        return res;\n    }\n\n    static deserializeWriteResponseWithId(dr, opt, res, serialVersion) {\n        this.deserializeWriteResponse(dr, opt, res, serialVersion);\n        if (dr.readBoolean()) { //has generated id column value\n            res.generatedValue = this.readFieldValue(dr, opt);\n        }\n        return res;\n    }\n\n    static deserializeTableResult(dr, opt, serialVersion) {\n        const res = {};\n        const hasInfo = dr.readBoolean();\n        if (hasInfo) {\n            const compartmentId = dr.readString();\n            if (opt.serviceType === ServiceType.CLOUD) {\n                res.compartmentId = compartmentId;\n            }\n            res.tableName = dr.readString();\n            res.tableState = TableState.fromOrdinal(dr.readByte());\n        }\n        const hasStaticState = dr.readBoolean();\n        if (hasStaticState) {\n            const readUnits = dr.readInt();\n            const writeUnits = dr.readInt();\n            const storageGB = dr.readInt();\n            let mode = CapacityMode.PROVISIONED;\n            if (serialVersion > 2) {\n                mode = CapacityMode.fromOrdinal(dr.readByte());\n            }\n            if (opt.serviceType !== ServiceType.KVSTORE) {\n                res.tableLimits = { readUnits, writeUnits, storageGB, mode };\n            }\n            res.schema = dr.readString();\n        }\n        res.operationId = dr.readString();\n        return res;\n    }\n\n    static readTopologyInfo(dr) {\n        const seqNum = dr.readInt();\n        if (seqNum < -1) {\n            throw new NoSQLProtocolError(\n                `Invalid topology sequence number: ${seqNum}`);\n        }\n        if (seqNum === -1) {\n            //No topology info sent by proxy\n            return null;\n        }\n        const shardIds = dr.readIntArray();\n        return {\n            seqNum,\n            shardIds\n        };\n    }\n\n    static mapError(rc, msg, req) {\n        let errCode;\n        try {\n            errCode = ErrorCode.fromOrdinal(rc);\n        } catch(err) {\n            return new NoSQLProtocolError(\n                'Received invalid error code: ' + rc, err, req);\n        }\n\n        const err = this._createError(errCode, msg, req);\n        \n        err._rejectedByDriver = false; //for testing\n        return err;\n    }\n\n    static deserializeSystemResult(dr) {\n        const res = {};\n        res.state = AdminState.fromOrdinal(dr.readByte());\n        res.operationId = dr.readString();\n        res.statement = dr.readString();\n        res.output = dr.readString();\n        return res;\n    }\n\n}\n\nmodule.exports = Protocol;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}