{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl\n *\n * Please see LICENSE.txt file included in the top-level directory of the\n * appropriate download for a copy of the license and additional information.\n */\n\n'use strict';\n\nconst util = require('util');\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst isNumeric = require('./utils').isNumeric;\nconst isPlainObject = require('../utils').isPlainObject;\nconst compare = require('../utils').compare;\nconst sortMapEntries = require('../utils').sortMapEntries;\nfunction _compVal(val1, val2) {\n  if (typeof val1 === 'number') {\n    //NaN is equal to itself and is greater than everything else\n    if (isNaN(val1)) {\n      return typeof val2 === 'number' && isNaN(val2) ? 0 : 1;\n    }\n    if (typeof val2 === 'number' && isNaN(val2)) {\n      return -1;\n    }\n  }\n  return compare(val1, val2);\n}\n\n//For comparison of different types we assume:\n//numerics < timestamps < strings < booleans\n//This function assumes the arguments are not null or EMPTY\nfunction compareNonNullAtomics(ctx, val1, val2) {\n  switch (typeof val1) {\n    case 'number':\n    case 'bigint':\n      if (typeof val2 === 'number' || typeof val2 === 'bigint') {\n        return _compVal(val1, val2);\n      }\n      if (ctx._dbNumber != null && ctx._dbNumber.isInstance(val2)) {\n        //3rd party number library may not support any operations with\n        //bigint, going through string ensures precision is preserved.\n        if (typeof val1 === 'bigint') {\n          val1 = ctx._dbNumber.create(val1.toString());\n        }\n        return -ctx._dbNumber.compare(val2, val1);\n      }\n      if (typeof val2 === 'string' || typeof val2 === 'boolean' || val2 instanceof Date) {\n        return -1;\n      }\n      break;\n    case 'string':\n    case 'boolean':\n      if (typeof val1 === typeof val2) {\n        return _compVal(val1, val2);\n      }\n      if (typeof val2 === 'string' || isNumeric(ctx, val2) || val2 instanceof Date) {\n        return 1;\n      }\n      if (typeof val2 === 'boolean') {\n        return -1;\n      }\n      break;\n    case 'object':\n      if (val1 instanceof Date) {\n        if (val2 instanceof Date) {\n          return _compVal(val1.getTime(), val2.getTime());\n        }\n        if (typeof val2 === 'string' || typeof val2 === 'boolean') {\n          return -1;\n        }\n        if (isNumeric(ctx, val2)) {\n          return 1;\n        }\n        break;\n      }\n      if (ctx._dbNumber != null && ctx._dbNumber.isInstance(val1)) {\n        if (typeof val2 === 'bigint') {\n          val2 = ctx._dbNumber.create(val2.toString());\n        }\n        if (ctx._dbNumber.isInstance(val2) || typeof val2 === 'number') {\n          return ctx._dbNumber.compare(val1, val2);\n        }\n        if (typeof val2 === 'string' || typeof val2 === 'boolean' || val2 instanceof Date) {\n          return -1;\n        }\n        break;\n      }\n    default:\n      throw ctx.unsupportedComp(val1);\n  }\n  throw ctx.unsupportedComp(val2);\n}\n\n//compare in ascending order only\n//compareRows() will reverse for descending order\n//undefined is used for SQL NULL, null for JSON NULL\nfunction compareAtomics(ctx, val1, val2, nullRank) {\n  if (val1 === undefined) {\n    switch (val2) {\n      case undefined:\n        return 0;\n      case null:\n      case EMPTY_VALUE:\n        return 1;\n      default:\n        return nullRank;\n    }\n  } else if (val1 === null) {\n    switch (val2) {\n      case undefined:\n        return -1;\n      case null:\n        return 0;\n      case EMPTY_VALUE:\n        return 1;\n      default:\n        return nullRank;\n    }\n  } else if (val1 === EMPTY_VALUE) {\n    switch (val2) {\n      case undefined:\n      case null:\n        return -1;\n      case EMPTY_VALUE:\n        return 0;\n      default:\n        return nullRank;\n    }\n  } else if (val2 == null || val2 === EMPTY_VALUE) {\n    return -nullRank;\n  }\n  return compareNonNullAtomics(ctx, val1, val2);\n}\n\n//Same as compareAtomics() but allows comparison of binary values. See\n//compareFieldValuesTotalOrder().\nfunction compareAtomicsTotalOrder(ctx, val1, val2, nullRank) {\n  if (Buffer.isBuffer(val1)) {\n    return Buffer.isBuffer(val2) ? Buffer.compare(val1, val2) : val2 == null || val2 === EMPTY_VALUE ? -nullRank : 1;\n  }\n  if (Buffer.isBuffer(val2)) {\n    return val1 == null || val1 === EMPTY_VALUE ? nullRank : -1;\n  }\n  return compareAtomics(ctx, val1, val2, nullRank);\n}\nfunction compareRows(ctx, row1, row2, sortSpecs) {\n  for (let ss of sortSpecs) {\n    let compRes = compareAtomics(ctx, row1[ss.fieldName], row2[ss.fieldName], ss.nullRank);\n    if (ss.isDesc) {\n      compRes = -compRes;\n    }\n    if (compRes) {\n      return compRes;\n    }\n  }\n  return 0;\n}\nfunction _compareArrays(ctx, arr1, arr2, nullRank) {\n  const len = Math.min(arr1.length, arr2.length);\n  for (let i = 0; i < len; i++) {\n    const res = compareFieldValuesTotalOrder(ctx, arr1[i], arr2[i], nullRank);\n    if (res !== 0) {\n      return res;\n    }\n  }\n  return compare(arr1.length, arr2.length);\n}\nfunction _compareMapEntries(ctx, ents1, ents2, nullRank) {\n  ents1 = sortMapEntries(ents1);\n  ents2 = sortMapEntries(ents2);\n  const len = Math.min(ents1.length, ents2.length);\n  for (let i = 0; i < len; i++) {\n    let res = compare(ents1[i][0], ents2[i][0]);\n    if (res !== 0) {\n      return res;\n    }\n    res = compareFieldValuesTotalOrder(ctx, ents1[i][1], ents2[i][1], nullRank);\n    if (res !== 0) {\n      return res;\n    }\n  }\n  return compare(ents1.length, ents2.length);\n}\n\n//Includes comparison of complex types, such as arrays and maps, as well as\n//binary. The order between different types is:\n//Arrays > Maps > Atomic values, and Binary values (which are atomic) are\n//greater than any other atomic values except special values (Null, Json Null\n//and Empty), for which nullRank is used. Other than that, the order is the\n//same as in compareAtomics().\nfunction compareFieldValuesTotalOrder(ctx, val1, val2, nullRank = 1) {\n  if (Array.isArray(val1)) {\n    return Array.isArray(val2) ? _compareArrays(ctx, val1, val2, nullRank) : 1;\n  }\n  if (val1 instanceof Map || isPlainObject(val1)) {\n    if (Array.isArray(val2)) {\n      return -1;\n    }\n    if (!(val2 instanceof Map) && !isPlainObject(val2)) {\n      return 1;\n    }\n    return _compareMapEntries(ctx, val1 instanceof Map ? val1.entries() : Object.entries(val1), val2 instanceof Map ? val2.entries() : Object.entries(val2), nullRank);\n  }\n  if (Array.isArray(val2) || val2 instanceof Map || isPlainObject(val2)) {\n    return -1;\n  }\n  return compareAtomicsTotalOrder(ctx, val1, val2, nullRank);\n}\n\n//We assume the values can be either Map of object, although Map is not\n//currently used in protocol when reading field values.\nfunction _mapValuesEqual(ctx, val1, val2) {\n  let ents1;\n  let size1;\n  if (val1 instanceof Map) {\n    ents1 = val1.entries();\n    size1 = val1.size;\n  } else {\n    ents1 = Object.entries(val1);\n    size1 = ents1.length;\n  }\n  const isMap2 = val2 instanceof Map;\n  const size2 = isMap2 ? val2.size : Object.keys(val2).length;\n  if (size1 !== size2) {\n    return false;\n  }\n  for (let [k1, v1] of ents1) {\n    const v2 = isMap2 ? val2.get(k1) : val2[k1];\n    if (!fieldValuesEqual(ctx, v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//Compare field values for grouping in SFWIterator.\n//Note that for efficiency the type checking of val2 is not done, since these\n//are the values deserialized while reading records.\nfunction fieldValuesEqual(ctx, val1, val2) {\n  if (val1 == null) {\n    //NULL (undefined) or JSON NULL (null)\n    return val1 === val2;\n  }\n  switch (typeof val1) {\n    case 'number':\n    case 'bigint':\n      if (typeof val2 === 'number' || typeof val2 === 'bigint') {\n        return val1 == val2;\n      }\n      if (ctx._dbNumber != null && ctx._dbNumber.isInstance(val2)) {\n        if (typeof val1 === 'bigint') {\n          val1 = ctx._dbNumber.create(val1.toString());\n        }\n        return ctx._dbNumber.valuesEqual(val2, val1);\n      }\n      return false;\n    case 'string':\n    case 'boolean':\n      return val1 === val2;\n    case 'object':\n      if (val1 instanceof Date) {\n        return val2 instanceof Date && val1.getTime() === val2.getTime();\n      }\n      if (Buffer.isBuffer(val1)) {\n        return Buffer.isBuffer(val2) && val1.equals(val2);\n      }\n      if (ctx._dbNumber != null && ctx._dbNumber.isInstance(val1)) {\n        if (typeof val2 === 'bigint') {\n          val2 = ctx._dbNumber.create(val2.toString());\n        }\n        return (ctx._dbNumber.isInstance(val2) || typeof val2 === 'number') && ctx._dbNumber.valuesEqual(val1, val2);\n      }\n      if (Array.isArray(val1)) {\n        return Array.isArray(val2) && val1.reduce((acc, curr, idx) => acc && fieldValuesEqual(curr, val2[idx]), true);\n      }\n      return _mapValuesEqual(val1, val2);\n    default:\n      throw ctx.illegalState(`Unexpected field value for equality \\\ncomparison: ${util.inspect(val1)}`);\n  }\n}\nmodule.exports = {\n  compareNonNullAtomics,\n  compareAtomics,\n  compareAtomicsTotalOrder,\n  compareRows,\n  compareFieldValuesTotalOrder,\n  fieldValuesEqual\n};","map":{"version":3,"names":["util","require","EMPTY_VALUE","isNumeric","isPlainObject","compare","sortMapEntries","_compVal","val1","val2","isNaN","compareNonNullAtomics","ctx","_dbNumber","isInstance","create","toString","Date","getTime","unsupportedComp","compareAtomics","nullRank","undefined","compareAtomicsTotalOrder","Buffer","isBuffer","compareRows","row1","row2","sortSpecs","ss","compRes","fieldName","isDesc","_compareArrays","arr1","arr2","len","Math","min","length","i","res","compareFieldValuesTotalOrder","_compareMapEntries","ents1","ents2","Array","isArray","Map","entries","Object","_mapValuesEqual","size1","size","isMap2","size2","keys","k1","v1","v2","get","fieldValuesEqual","valuesEqual","equals","reduce","acc","curr","idx","illegalState","inspect","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/query/compare.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl\n *\n * Please see LICENSE.txt file included in the top-level directory of the\n * appropriate download for a copy of the license and additional information.\n */\n\n'use strict';\n\nconst util = require('util');\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst isNumeric = require('./utils').isNumeric;\nconst isPlainObject = require('../utils').isPlainObject;\nconst compare = require('../utils').compare;\nconst sortMapEntries = require('../utils').sortMapEntries;\n\nfunction _compVal(val1, val2) {\n    if (typeof val1 === 'number') {\n        //NaN is equal to itself and is greater than everything else\n        if (isNaN(val1)) {\n            return (typeof val2 === 'number' && isNaN(val2)) ? 0 : 1;\n        }\n        if (typeof val2 === 'number' && isNaN(val2)) {\n            return -1;\n        }\n    }\n    return compare(val1, val2);\n}\n\n//For comparison of different types we assume:\n//numerics < timestamps < strings < booleans\n//This function assumes the arguments are not null or EMPTY\nfunction compareNonNullAtomics(ctx, val1, val2) {\n    switch(typeof val1) {\n    case 'number': case 'bigint':\n        if (typeof val2 === 'number' || typeof val2 === 'bigint') {\n            return _compVal(val1, val2);\n        }\n        if (ctx._dbNumber != null && ctx._dbNumber.isInstance(val2)) {\n            //3rd party number library may not support any operations with\n            //bigint, going through string ensures precision is preserved.\n            if (typeof val1 === 'bigint') {\n                val1 = ctx._dbNumber.create(val1.toString());\n            }\n            return -ctx._dbNumber.compare(val2, val1);\n        }\n        if (typeof val2 === 'string' || typeof val2 === 'boolean' ||\n            val2 instanceof Date) {\n            return -1;\n        }\n        break;\n    case 'string': case 'boolean':\n        if (typeof val1 === typeof val2) {\n            return _compVal(val1, val2);\n        }\n        if (typeof val2 === 'string' || isNumeric(ctx, val2) ||\n            val2 instanceof Date) {\n            return 1;\n        }\n        if (typeof val2 === 'boolean') {\n            return -1;\n        }\n        break;\n    case 'object':\n        if (val1 instanceof Date) {\n            if (val2 instanceof Date) {\n                return _compVal(val1.getTime(), val2.getTime());\n            }\n            if (typeof val2 === 'string' || typeof val2 === 'boolean') {\n                return -1;\n            }\n            if (isNumeric(ctx, val2)) {\n                return 1;\n            }\n            break;\n        }\n        if (ctx._dbNumber != null && ctx._dbNumber.isInstance(val1)) {\n            if (typeof val2 === 'bigint') {\n                val2 = ctx._dbNumber.create(val2.toString());\n            }\n            if (ctx._dbNumber.isInstance(val2) || typeof val2 === 'number') {\n                return ctx._dbNumber.compare(val1, val2);\n            }\n            if (typeof val2 === 'string' || typeof val2 === 'boolean' ||\n                val2 instanceof Date) {\n                return -1;\n            }\n            break;\n        }\n    default:\n        throw ctx.unsupportedComp(val1);\n    }\n    throw ctx.unsupportedComp(val2);\n}\n\n//compare in ascending order only\n//compareRows() will reverse for descending order\n//undefined is used for SQL NULL, null for JSON NULL\nfunction compareAtomics(ctx, val1, val2, nullRank) {\n    if (val1 === undefined) {\n        switch(val2) {\n        case undefined:\n            return 0;\n        case null: case EMPTY_VALUE:\n            return 1;\n        default:\n            return nullRank;\n        }\n    } else if (val1 === null) {\n        switch(val2) {\n        case undefined:\n            return -1;\n        case null:\n            return 0;\n        case EMPTY_VALUE:\n            return 1;\n        default:\n            return nullRank;\n        }\n    } else if (val1 === EMPTY_VALUE) {\n        switch(val2) {\n        case undefined: case null:\n            return -1;\n        case EMPTY_VALUE:\n            return 0;\n        default:\n            return nullRank;\n        }\n    } else if (val2 == null || val2 === EMPTY_VALUE) {\n        return -nullRank;\n    }\n    return compareNonNullAtomics(ctx, val1, val2);\n}\n\n//Same as compareAtomics() but allows comparison of binary values. See\n//compareFieldValuesTotalOrder().\nfunction compareAtomicsTotalOrder(ctx, val1, val2, nullRank) {\n    if (Buffer.isBuffer(val1)) {\n        return Buffer.isBuffer(val2) ?\n            Buffer.compare(val1, val2) :\n            ((val2 == null || val2 === EMPTY_VALUE) ? -nullRank : 1);\n    }\n    if (Buffer.isBuffer(val2)) {\n        return (val1 == null || val1 === EMPTY_VALUE) ? nullRank : -1;\n    }\n    return compareAtomics(ctx, val1, val2, nullRank);\n}\n\nfunction compareRows(ctx, row1, row2, sortSpecs) {\n    for(let ss of sortSpecs) {\n        let compRes = compareAtomics(ctx, row1[ss.fieldName],\n            row2[ss.fieldName], ss.nullRank);\n        if (ss.isDesc) {\n            compRes = -compRes;\n        }\n        if (compRes) {\n            return compRes;\n        }\n    }\n    return 0;\n}\n\nfunction _compareArrays(ctx, arr1, arr2, nullRank) {\n    const len = Math.min(arr1.length, arr2.length);\n    for(let i = 0; i < len; i++) {\n        const res = compareFieldValuesTotalOrder(ctx, arr1[i],\n            arr2[i], nullRank);\n        if (res !== 0) {\n            return res;\n        }\n    }\n    return compare(arr1.length, arr2.length);\n}\n\nfunction _compareMapEntries(ctx, ents1, ents2, nullRank) {\n    ents1 = sortMapEntries(ents1);\n    ents2 = sortMapEntries(ents2);\n    const len = Math.min(ents1.length, ents2.length);\n    for(let i = 0; i < len; i++) {\n        let res = compare(ents1[i][0], ents2[i][0]);\n        if (res !== 0) {\n            return res;\n        }\n        res = compareFieldValuesTotalOrder(ctx, ents1[i][1], ents2[i][1],\n            nullRank);\n        if (res !== 0) {\n            return res;\n        }\n    }\n    return compare(ents1.length, ents2.length);\n}\n\n//Includes comparison of complex types, such as arrays and maps, as well as\n//binary. The order between different types is:\n//Arrays > Maps > Atomic values, and Binary values (which are atomic) are\n//greater than any other atomic values except special values (Null, Json Null\n//and Empty), for which nullRank is used. Other than that, the order is the\n//same as in compareAtomics().\nfunction compareFieldValuesTotalOrder(ctx, val1, val2, nullRank = 1) {\n    if (Array.isArray(val1)) {\n        return Array.isArray(val2) ?\n            _compareArrays(ctx, val1, val2, nullRank) : 1;\n    }\n    if (val1 instanceof Map || isPlainObject(val1)) {\n        if (Array.isArray(val2)) {\n            return -1;\n        }\n        if (!(val2 instanceof Map) && !isPlainObject(val2)) {\n            return 1;\n        }\n        return _compareMapEntries(ctx,\n            val1 instanceof Map ? val1.entries() : Object.entries(val1),\n            val2 instanceof Map ? val2.entries() : Object.entries(val2),\n            nullRank);\n    }\n    if (Array.isArray(val2) || val2 instanceof Map || isPlainObject(val2)) {\n        return -1;\n    }\n    return compareAtomicsTotalOrder(ctx, val1, val2, nullRank);\n}\n\n//We assume the values can be either Map of object, although Map is not\n//currently used in protocol when reading field values.\nfunction _mapValuesEqual(ctx, val1, val2) {\n    let ents1;\n    let size1;\n    if (val1 instanceof Map) {\n        ents1 = val1.entries();\n        size1 = val1.size;\n    } else {\n        ents1 = Object.entries(val1);\n        size1 = ents1.length;\n    }\n    const isMap2 = val2 instanceof Map;\n    const size2 = isMap2 ? val2.size : Object.keys(val2).length;\n    if (size1 !== size2) {\n        return false;\n    }\n    for(let [k1, v1] of ents1) {\n        const v2 = isMap2 ? val2.get(k1) : val2[k1];\n        if (!fieldValuesEqual(ctx, v1, v2)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n//Compare field values for grouping in SFWIterator.\n//Note that for efficiency the type checking of val2 is not done, since these\n//are the values deserialized while reading records.\nfunction fieldValuesEqual(ctx, val1, val2) {\n    if (val1 == null) { //NULL (undefined) or JSON NULL (null)\n        return val1 === val2;\n    }\n    switch(typeof val1) {\n    case 'number': case 'bigint':\n        if (typeof val2 === 'number' || typeof val2 === 'bigint') {\n            return val1 == val2;\n        }\n        if (ctx._dbNumber != null && ctx._dbNumber.isInstance(val2)) {\n            if (typeof val1 === 'bigint') {\n                val1 = ctx._dbNumber.create(val1.toString());\n            }\n            return ctx._dbNumber.valuesEqual(val2, val1);\n        }\n        return false;\n    case 'string': case 'boolean':\n        return val1 === val2;\n    case 'object':\n        if (val1 instanceof Date) {\n            return val2 instanceof Date && val1.getTime() === val2.getTime();\n        }\n        if (Buffer.isBuffer(val1)) {\n            return Buffer.isBuffer(val2) && val1.equals(val2);\n        }\n        if (ctx._dbNumber != null && ctx._dbNumber.isInstance(val1)) {\n            if (typeof val2 === 'bigint') {\n                val2 = ctx._dbNumber.create(val2.toString());\n            }\n            return (ctx._dbNumber.isInstance(val2) ||\n                typeof val2 === 'number') &&\n                ctx._dbNumber.valuesEqual(val1, val2);\n        }\n        if (Array.isArray(val1)) {\n            return Array.isArray(val2) && val1.reduce((acc, curr, idx) =>\n                acc && fieldValuesEqual(curr, val2[idx]), true);\n        }\n        return _mapValuesEqual(val1, val2);\n    default:\n        throw ctx.illegalState(`Unexpected field value for equality \\\ncomparison: ${util.inspect(val1)}`);\n    }\n}\n\nmodule.exports = {\n    compareNonNullAtomics,\n    compareAtomics,\n    compareAtomicsTotalOrder,\n    compareRows,\n    compareFieldValuesTotalOrder,\n    fieldValuesEqual\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}