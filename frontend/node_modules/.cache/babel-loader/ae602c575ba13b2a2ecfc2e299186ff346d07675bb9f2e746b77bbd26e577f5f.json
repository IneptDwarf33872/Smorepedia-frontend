{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst propertyByString = require('./utils').propertyByString;\nconst isPosInt32 = require('./utils').isPosInt32;\nconst requireNoWP = require('./utils').requireNoWP;\nconst RoundingModes = {\n  UP: 0,\n  DOWN: 1,\n  CEILING: 2,\n  FLOOR: 3,\n  HALF_UP: 4,\n  HALF_DOWN: 5,\n  HALF_EVEN: 6,\n  UNNECESSARY: 7\n};\nconst DEFAULT_PRECISION = 20;\nclass NumberTypeHandler {\n  constructor(cfg) {\n    assert(cfg.dbNumber != null);\n    try {\n      this._initCons(cfg);\n\n      //These can be customized in future to allow creation of number\n      //instances by callable functions (instead of constructor). \n      this.isInstance = val => val instanceof this._cons;\n      this.create = val => new this._cons(val);\n      this._initMethod(cfg, 'stringValue', 1, ['toString'], []);\n      this._initMethod(cfg, 'compare', 2, ['comparedTo', 'compareTo', 'cmp', 'compare']);\n      this._initMethod(cfg, 'valuesEqual', 2, ['equals', 'isEqualTo', 'eq'], [], true);\n      if (this.valuesEqual == null) {\n        this.valuesEqual = (v1, v2) => this.compare(v1, v2) === 0;\n      }\n      this._initMethod(cfg, 'numberValue', 1, ['toNumber'], [], true);\n      if (this.numberValue == null) {\n        this.numberValue = v => Number(this.stringValue(v));\n      }\n      this._initMethod(cfg, 'add', 2, ['plus', 'add']);\n      this._initMethod(cfg, 'subtract', 2, ['minus', 'sub', 'subtract']);\n      this._initMethod(cfg, 'multiply', 2, ['times', 'multipliedBy', 'multiply', 'mul']);\n      this._initMethod(cfg, 'divide', 2, ['dividedBy', 'divide', 'div']);\n      this._initRoundingModesMap(cfg);\n      this._initGetRoundingMode(cfg);\n      this._initGetPrecision(cfg);\n      this._initRoundingMode(cfg);\n      this._initPrecision(cfg);\n    } catch (err) {\n      throw new NoSQLArgumentError('Failed to initialize dbNumber \\\nconfiguration', cfg, err);\n    }\n  }\n  get precision() {\n    return this._precision;\n  }\n  get roundingMode() {\n    return this._roundingMode;\n  }\n  _initCons(cfg) {\n    switch (typeof cfg.dbNumber) {\n      case 'function':\n        this._cons = cfg.dbNumber;\n        return;\n      case 'string':\n        this._cons = requireNoWP(cfg.dbNumber);\n        break;\n      case 'object':\n        if (cfg.dbNumber.module != null) {\n          if (typeof cfg.dbNumber.module !== 'string') {\n            throw new NoSQLArgumentError('Invalid dbNumber.module \\\nproperty, must be string', cfg);\n          }\n          this._mod = requireNoWP(cfg.dbNumber.module);\n          if (cfg.dbNumber.Constructor == null) {\n            this._cons = this._mod;\n            break;\n          } else if (typeof cfg.dbNumber.Constructor === 'string') {\n            this._cons = this._mod[cfg.dbNumber.Constructor];\n            break;\n          }\n        }\n        this._cons = typeof cfg.dbNumber.Constructor === 'string' ? requireNoWP(cfg.dbNumber.Constructor) : cfg.dbNumber.Constructor;\n        break;\n      default:\n        throw new NoSQLArgumentError('Invalid dbNumber property', cfg);\n    }\n    if (this._cons == null) {\n      throw new NoSQLArgumentError('Missing dbNumber constructor', cfg);\n    }\n    if (typeof this._cons !== 'function') {\n      throw new NoSQLArgumentError('Invalid dbNumber constructor', cfg);\n    }\n  }\n  _findFuncByProp(cfg, name, isStatic) {\n    if (typeof cfg.dbNumber !== 'object') {\n      return null;\n    }\n    const subName = isStatic ? 'static' : 'instance';\n    const sub = cfg.dbNumber[subName];\n    if (sub == null) {\n      return null;\n    }\n    if (typeof sub !== 'object') {\n      throw new NoSQLArgumentError(\"Invalid dbNumber.\".concat(subName, \" property\"), cfg);\n    }\n    const obj = isStatic ? this._cons : this._cons.prototype;\n    let func = sub[name];\n    if (func == null) {\n      return null;\n    }\n    if (typeof func === 'string') {\n      func = obj[func];\n    }\n    if (typeof func !== 'function') {\n      throw new NoSQLArgumentError(\"Property dbNumber.\".concat(subName, \".\").concat(name, \" points to missing or invalid method of \").concat(this._cons.name), cfg);\n    }\n    return func;\n  }\n  _findFunc(cfg, name, cands, staticCands, retNull) {\n    let func = this._findFuncByProp(cfg, name, false);\n    if (func != null) {\n      return {\n        isStatic: false,\n        func\n      };\n    }\n    func = this._findFuncByProp(cfg, name, true);\n    if (func != null) {\n      return {\n        isStatic: true,\n        func\n      };\n    }\n    if (cands != null) {\n      for (let cand of cands) {\n        func = this._cons.prototype[cand];\n        if (typeof func === 'function') {\n          return {\n            isStatic: false,\n            func\n          };\n        }\n      }\n    }\n    if (staticCands == null) {\n      staticCands = cands;\n    }\n    if (staticCands != null) {\n      for (let cand of staticCands) {\n        func = this._cons[cand];\n        if (typeof func === 'function') {\n          return {\n            isStatic: true,\n            func\n          };\n        }\n      }\n    }\n    if (retNull) {\n      return null;\n    }\n    throw new NoSQLArgumentError(\"Could not find dbNumber method for \".concat(name), cfg);\n  }\n  _initMethod(cfg, name, numArgs, cands, staticCands, isSoft) {\n    const meth = this._findFunc(cfg, name, cands, staticCands, isSoft);\n    if (meth == null) {\n      return;\n    }\n    if (meth.isStatic) {\n      this[name] = meth.func.bind(this._cons);\n    } else {\n      //not certain if this optimization is needed or the default case\n      //is sufficient\n      switch (numArgs) {\n        case 1:\n          this[name] = v => meth.func.call(v);\n          break;\n        case 2:\n          this[name] = (v1, v2) => meth.func.call(v1, v2);\n          break;\n        default:\n          this[name] = function (inst) {\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n            return meth.func.call(inst, ...args);\n          };\n          break;\n      }\n    }\n  }\n  _findRoundingModes(cfg) {\n    const candObjs = [this._cons];\n    if (this._mod != null) {\n      candObjs.push(this._mod);\n    }\n    //First look at dbNumber.RoundingModes which should be either a\n    //property name of rounding modes object or that object itself\n    if (cfg.dbNumber.RoundingModes != null) {\n      if (typeof cfg.dbNumber.RoundingModes === 'string') {\n        for (let candObj of candObjs) {\n          const roundingModes = propertyByString(candObj, cfg.dbNumber.RoundingModes);\n          if (roundingModes !== null && typeof roundingModes === 'object' || typeof roundingModes === 'function') {\n            return roundingModes;\n          }\n        }\n        throw new NoSQLArgumentError(\"Missing or invalid value for dbNumber.RoundingModes property \".concat(cfg.dbNumber.RoundingModes));\n      }\n      if (typeof cfg.dbNumber.RoundingModes !== 'object' && typeof cfg.dbNumber.RoundingModes !== 'function') {\n        throw new NoSQLArgumentError(\"Invalid dbNumber.RoundingModes: \".concat(util.inspect(cfg.dbNumber.RoundingModes)), cfg);\n      }\n      return cfg.dbNumber.RoundingModes;\n    }\n    //Otherwise check candidate property names on module or\n    //constructor\n    const candProps = ['RoundingModes', 'RoundingMode'];\n    for (let candObj of candObjs) {\n      for (let candProp of candProps) {\n        const roundingModes = candObj[candProp];\n        if (roundingModes !== null && typeof roundingModes === 'object' || typeof roundingModes === 'function') {\n          return roundingModes;\n        }\n      }\n    }\n    //If still not found, assume that constructor itself contains rounding\n    //mode constants\n    return this._cons;\n  }\n\n  //create a Map mapping 3rd party rounding mode constants to Java's\n  _initRoundingModesMap(cfg) {\n    this._roundingModes = this._findRoundingModes(cfg);\n    //Create a mapping from 3rd party rounding mode values to Java's\n    this._roundingModesMap = new Map();\n    for (let ent of Object.entries(RoundingModes)) {\n      //Look for properties with and without ROUND_ prefix\n      let val = this._roundingModes['ROUND_' + ent[0]];\n      if (val == null) {\n        val = this._roundingModes[ent[0]];\n      }\n      if (val != null) {\n        this._roundingModesMap.set(val, ent[1]);\n      }\n    }\n  }\n  _initGetRoundingMode(cfg) {\n    let rm;\n    let rmFunc;\n    if (cfg.dbNumber.getRoundingMode != null) {\n      switch (typeof cfg.dbNumber.getRoundingMode) {\n        case 'function':\n          rmFunc = cfg.dbNumber.getRoundingMode;\n          break;\n        case 'string':\n          rm = propertyByString(this._cons, cfg.dbNumber.getRoundingMode);\n          if (rm == null) {\n            throw new NoSQLArgumentError(\"Missing value for     dbNumber.getRoundingMode property \".concat(cfg.dbNumber.getRoundingMode), cfg);\n          }\n          rmFunc = cons => propertyByString(cons, cfg.dbNumber.getRoundingMode);\n          break;\n        default:\n          throw new NoSQLArgumentError(\"Invalid dbNumber.getRoundingMode: \".concat(util.inspect(cfg.dbNumber.getRoundingMode)));\n      }\n    } else {\n      //If dbNumber.getRoundingMode is not set and rounding modes\n      //mapping is not available, assume that the user just wants to set\n      //dbNumber.roundingMode explicitly or use default\n      if (this._roundingModesMap.size === 0) {\n        return;\n      }\n      //Otherwise check candidate names\n      let cands = ['rounding', 'roundingMode', 'ROUNDING_MODE', 'RM'];\n      for (let cand of cands) {\n        rm = this._cons[cand];\n        if (rm != null) {\n          rmFunc = cons => cons[cand];\n          break;\n        }\n      }\n      //If not found any way to get rounding mode, let the user set\n      //dbNumber.roundingMode explicitly or use default\n      if (rmFunc == null) {\n        return;\n      }\n    }\n    this._getRoundingMode = cons => {\n      const rmVal = rmFunc(cons);\n      const rm = this._roundingModesMap.get(rmVal);\n      if (rm == null) {\n        throw new NoSQLArgumentError(\"Could not determine rounding mode with value \".concat(util.inspect(rmVal), \", please check configuration properties dbNumber.RoundingModes and dbNumber.getRoundingMode\"), cfg);\n      }\n      return rm;\n    };\n  }\n  _initGetPrecision(cfg) {\n    let prec;\n    let precFunc;\n    if (cfg.dbNumber.getPrecision != null) {\n      switch (typeof cfg.dbNumber.getPrecision) {\n        case 'function':\n          precFunc = cfg.dbNumber.getPrecision;\n          break;\n        case 'string':\n          prec = propertyByString(this._cons, cfg.dbNumber.getPrecision);\n          if (!isPosInt32(prec)) {\n            throw new NoSQLArgumentError(\"Missing or invalid value for dbNumber.getRoundingMode property \".concat(cfg.dbNumber.getPrecision), cfg);\n          }\n          precFunc = cons => propertyByString(cons, cfg.dbNumber.getPrecision);\n          break;\n        default:\n          throw new NoSQLArgumentError(\"Invalid dbNumber.getPrecision: \".concat(util.inspect(cfg.dbNumber.getPrecision)));\n      }\n    }\n    if (precFunc == null) {\n      const cands = ['precision', 'PRECISION'];\n      for (let cand of cands) {\n        prec = this._cons[cand];\n        if (isPosInt32(prec)) {\n          precFunc = cons => cons[cand];\n          break;\n        }\n      }\n      if (precFunc == null) {\n        return;\n      }\n    }\n    this._getPrecision = cons => {\n      let prec = precFunc(cons);\n      if (!isPosInt32(prec)) {\n        throw new NoSQLArgumentError(\"Got invalid precision value: \".concat(util.inspect(prec), \", please check configuration property dbNumber.getPrecision\"), cfg);\n      }\n      return prec;\n    };\n  }\n\n  //get rounding mode constant in Java's format via _roundingModesMap\n  _initRoundingMode(cfg) {\n    if (cfg.dbNumber.roundingMode != null) {\n      if (typeof cfg.dbNumber.roundingMode === 'string') {\n        //check if dbNumber.roundingMode could be just a name of\n        //the rounding mode enumeration constant (with or without\n        //ROUND_ prefix)\n        const rm = cfg.dbNumber.roundingMode.startsWith('ROUND_') ? cfg.dbNumber.roundingMode.substring(6) : cfg.dbNumber.roundingMode;\n        if (rm in RoundingModes) {\n          this._roundingMode = RoundingModes[rm];\n          return;\n        }\n      }\n      this._roundingMode = this._roundingModesMap.get(cfg.dbNumber.roundingMode);\n      if (this._roundingMode == null) {\n        throw new NoSQLArgumentError(\"Could not determine rounding mode set by configuration property dbNumber.roundingMode with value \".concat(util.inspect(cfg.dbNumber.roundingMode), \", please check configuration properties dbNumber.roundingMode and dbNumber.RoundingModes\"), cfg);\n      }\n      return;\n    }\n    if (this._getRoundingMode != null) {\n      this._roundingMode = this._getRoundingMode(this._cons);\n    } else {\n      //if rounding mode cannot be found, use default ROUND_HALF_UP\n      this._roundingMode = RoundingModes.HALF_UP;\n    }\n  }\n  _initPrecision(cfg) {\n    if (cfg.dbNumber.precision != null) {\n      if (!isPosInt32(cfg.dbNumber.precision)) {\n        throw new NoSQLArgumentError(\"Invalid value of dbNumber.precision: \".concat(cfg.dbNumber.precision), cfg);\n      }\n      this._precision = cfg.dbNumber.precision;\n    } else if (this._getPrecision != null) {\n      this._precision = this._getPrecision(this._cons);\n    } else {\n      this._precision = DEFAULT_PRECISION;\n    }\n  }\n}\nmodule.exports = NumberTypeHandler;","map":{"version":3,"names":["assert","require","util","NoSQLArgumentError","propertyByString","isPosInt32","requireNoWP","RoundingModes","UP","DOWN","CEILING","FLOOR","HALF_UP","HALF_DOWN","HALF_EVEN","UNNECESSARY","DEFAULT_PRECISION","NumberTypeHandler","constructor","cfg","dbNumber","_initCons","isInstance","val","_cons","create","_initMethod","valuesEqual","v1","v2","compare","numberValue","v","Number","stringValue","_initRoundingModesMap","_initGetRoundingMode","_initGetPrecision","_initRoundingMode","_initPrecision","err","precision","_precision","roundingMode","_roundingMode","module","_mod","Constructor","_findFuncByProp","name","isStatic","subName","sub","concat","obj","prototype","func","_findFunc","cands","staticCands","retNull","cand","numArgs","isSoft","meth","bind","call","inst","_len","arguments","length","args","Array","_key","_findRoundingModes","candObjs","push","candObj","roundingModes","inspect","candProps","candProp","_roundingModes","_roundingModesMap","Map","ent","Object","entries","set","rm","rmFunc","getRoundingMode","cons","size","_getRoundingMode","rmVal","get","prec","precFunc","getPrecision","_getPrecision","startsWith","substring","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/db_number.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst propertyByString = require('./utils').propertyByString;\nconst isPosInt32 = require('./utils').isPosInt32;\nconst requireNoWP = require('./utils').requireNoWP;\n\nconst RoundingModes = {\n    UP: 0,\n    DOWN: 1,\n    CEILING: 2,\n    FLOOR: 3,\n    HALF_UP: 4,\n    HALF_DOWN: 5,\n    HALF_EVEN: 6,\n    UNNECESSARY: 7\n};\n\nconst DEFAULT_PRECISION = 20;\n\nclass NumberTypeHandler {\n\n    constructor(cfg) {\n        assert(cfg.dbNumber != null);\n        try {\n            this._initCons(cfg);\n\n            //These can be customized in future to allow creation of number\n            //instances by callable functions (instead of constructor). \n            this.isInstance = val => val instanceof this._cons;\n            this.create = val => new this._cons(val);\n            \n            this._initMethod(cfg, 'stringValue', 1, [ 'toString' ], []);\n            this._initMethod(cfg, 'compare', 2,\n                [ 'comparedTo', 'compareTo', 'cmp', 'compare' ]);\n            this._initMethod(cfg, 'valuesEqual', 2,\n                [ 'equals', 'isEqualTo', 'eq' ], [], true);\n            if (this.valuesEqual == null) {\n                this.valuesEqual = (v1, v2) => this.compare(v1, v2) === 0;\n            }\n            this._initMethod(cfg, 'numberValue', 1, [ 'toNumber' ], [], true);\n            if (this.numberValue == null) {\n                this.numberValue = v => Number(this.stringValue(v));\n            }\n            this._initMethod(cfg, 'add', 2, [ 'plus', 'add' ]);\n            this._initMethod(cfg, 'subtract', 2,\n                [ 'minus', 'sub', 'subtract' ]);\n            this._initMethod(cfg, 'multiply', 2,\n                [ 'times', 'multipliedBy', 'multiply', 'mul' ]);\n            this._initMethod(cfg, 'divide', 2,\n                [ 'dividedBy', 'divide', 'div' ]);\n            this._initRoundingModesMap(cfg);\n            this._initGetRoundingMode(cfg);\n            this._initGetPrecision(cfg);\n            this._initRoundingMode(cfg);\n            this._initPrecision(cfg);\n        } catch(err) {\n            throw new NoSQLArgumentError('Failed to initialize dbNumber \\\nconfiguration', cfg, err);\n        }\n    }\n\n    get precision() {\n        return this._precision;\n    }\n\n    get roundingMode() {\n        return this._roundingMode;\n    }\n\n    _initCons(cfg) {\n        switch(typeof cfg.dbNumber) {\n        case 'function':\n            this._cons = cfg.dbNumber;\n            return;\n        case 'string':\n            this._cons = requireNoWP(cfg.dbNumber);\n            break;\n        case 'object':\n            if (cfg.dbNumber.module != null) {\n                if (typeof cfg.dbNumber.module !== 'string') {\n                    throw new NoSQLArgumentError('Invalid dbNumber.module \\\nproperty, must be string', cfg);\n                }\n                this._mod = requireNoWP(cfg.dbNumber.module);\n                if (cfg.dbNumber.Constructor == null) {\n                    this._cons = this._mod;\n                    break;\n                } else if (typeof cfg.dbNumber.Constructor === 'string') {\n                    this._cons = this._mod[cfg.dbNumber.Constructor];\n                    break;\n                }\n            }\n            this._cons = typeof cfg.dbNumber.Constructor === 'string' ?\n                requireNoWP(cfg.dbNumber.Constructor) :\n                cfg.dbNumber.Constructor;\n            break;\n        default:\n            throw new NoSQLArgumentError('Invalid dbNumber property', cfg);\n        }\n        if (this._cons == null) {\n            throw new NoSQLArgumentError('Missing dbNumber constructor', cfg);\n        }\n        if (typeof this._cons !== 'function') {\n            throw new NoSQLArgumentError('Invalid dbNumber constructor', cfg);\n        }\n    }\n\n    _findFuncByProp(cfg, name, isStatic) {\n        if (typeof cfg.dbNumber !== 'object') {\n            return null;\n        }\n        const subName = isStatic ? 'static' : 'instance';\n        const sub = cfg.dbNumber[subName];\n        if (sub == null) {\n            return null;\n        }\n        if (typeof sub !== 'object') {\n            throw new NoSQLArgumentError(\n                `Invalid dbNumber.${subName} property`, cfg);\n        }\n        const obj = isStatic ? this._cons : this._cons.prototype;\n        let func = sub[name];\n        if (func == null) {\n            return null;\n        }\n        if (typeof func === 'string') {\n            func = obj[func];\n        }\n        if (typeof func !== 'function') {\n            throw new NoSQLArgumentError(`Property \\\ndbNumber.${subName}.${name} points to missing or invalid method of \\\n${this._cons.name}`, cfg);\n        }\n        return func;\n    }\n\n    _findFunc(cfg, name, cands, staticCands, retNull) {\n        let func = this._findFuncByProp(cfg, name, false);\n        if (func != null) {\n            return { isStatic: false, func };\n        }\n        func = this._findFuncByProp(cfg, name, true);\n        if (func != null) {\n            return { isStatic: true, func };\n        }\n        if (cands != null) {\n            for(let cand of cands) {\n                func = this._cons.prototype[cand];\n                if (typeof func === 'function') {\n                    return { isStatic: false, func };\n                }\n            }\n        }\n        if (staticCands == null) {\n            staticCands = cands;\n        }\n        if (staticCands != null) {\n            for(let cand of staticCands) {\n                func = this._cons[cand];\n                if (typeof func === 'function') {\n                    return { isStatic: true, func };\n                }\n            }\n        }\n        if (retNull) {\n            return null;\n        }\n        throw new NoSQLArgumentError(`Could not find dbNumber method for \\\n${name}`, cfg);\n    }\n\n    _initMethod(cfg, name, numArgs, cands, staticCands, isSoft) {\n        const meth = this._findFunc(cfg, name, cands, staticCands, isSoft);\n        if (meth == null) {\n            return;\n        }\n        if (meth.isStatic) {\n            this[name] = meth.func.bind(this._cons);\n        } else {\n            //not certain if this optimization is needed or the default case\n            //is sufficient\n            switch(numArgs) {\n            case 1:\n                this[name] = v => meth.func.call(v);\n                break;\n            case 2:\n                this[name] = (v1, v2) => meth.func.call(v1, v2);\n                break;\n            default:\n                this[name] = (inst, ...args) => meth.func.call(inst, ...args);\n                break;\n            }\n        }\n    }\n\n    _findRoundingModes(cfg) {\n        const candObjs = [ this._cons ];\n        if (this._mod != null) {\n            candObjs.push(this._mod);\n        }\n        //First look at dbNumber.RoundingModes which should be either a\n        //property name of rounding modes object or that object itself\n        if (cfg.dbNumber.RoundingModes != null) {\n            if (typeof cfg.dbNumber.RoundingModes === 'string') {\n                for(let candObj of candObjs) {\n                    const roundingModes = propertyByString(candObj,\n                        cfg.dbNumber.RoundingModes);\n                    if (roundingModes !== null &&\n                        typeof roundingModes === 'object' ||\n                        typeof roundingModes === 'function') {\n                        return roundingModes;\n                    }\n                }\n                throw new NoSQLArgumentError(`Missing or invalid value for \\\ndbNumber.RoundingModes property ${cfg.dbNumber.RoundingModes}`);\n            }\n            if (typeof cfg.dbNumber.RoundingModes !== 'object' &&\n                typeof cfg.dbNumber.RoundingModes !== 'function') {\n                throw new NoSQLArgumentError(`Invalid \\\ndbNumber.RoundingModes: ${util.inspect(cfg.dbNumber.RoundingModes)}`, cfg);\n            }\n            return cfg.dbNumber.RoundingModes;\n        }\n        //Otherwise check candidate property names on module or\n        //constructor\n        const candProps = [ 'RoundingModes', 'RoundingMode' ];\n        for(let candObj of candObjs) {\n            for(let candProp of candProps) {\n                const roundingModes = candObj[candProp];\n                if (roundingModes !== null &&\n                    typeof roundingModes === 'object' ||\n                    typeof roundingModes === 'function') {\n                    return roundingModes;\n                }\n            }\n        }\n        //If still not found, assume that constructor itself contains rounding\n        //mode constants\n        return this._cons;\n    }\n\n    //create a Map mapping 3rd party rounding mode constants to Java's\n    _initRoundingModesMap(cfg) {\n        this._roundingModes = this._findRoundingModes(cfg);\n        //Create a mapping from 3rd party rounding mode values to Java's\n        this._roundingModesMap = new Map();\n        for(let ent of Object.entries(RoundingModes)) {\n            //Look for properties with and without ROUND_ prefix\n            let val = this._roundingModes['ROUND_' + ent[0]];\n            if (val == null) {\n                val = this._roundingModes[ent[0]];\n            }\n            if (val != null) {\n                this._roundingModesMap.set(val, ent[1]);\n            }\n        }\n    }\n\n    _initGetRoundingMode(cfg) {\n        let rm;\n        let rmFunc;\n        if (cfg.dbNumber.getRoundingMode != null) {\n            switch(typeof cfg.dbNumber.getRoundingMode) {\n            case 'function':\n                rmFunc = cfg.dbNumber.getRoundingMode;\n                break;\n            case 'string':\n                rm = propertyByString(this._cons,\n                    cfg.dbNumber.getRoundingMode);\n                if (rm == null) {\n                    throw new NoSQLArgumentError(`Missing value for \\\n    dbNumber.getRoundingMode property ${cfg.dbNumber.getRoundingMode}`, cfg);\n                }\n                rmFunc = cons => propertyByString(cons,\n                    cfg.dbNumber.getRoundingMode);\n                break;\n            default:\n                throw new NoSQLArgumentError(`Invalid \\\ndbNumber.getRoundingMode: ${util.inspect(cfg.dbNumber.getRoundingMode)}`);\n            }\n        } else {\n            //If dbNumber.getRoundingMode is not set and rounding modes\n            //mapping is not available, assume that the user just wants to set\n            //dbNumber.roundingMode explicitly or use default\n            if (this._roundingModesMap.size === 0) {\n                return;\n            }\n            //Otherwise check candidate names\n            let cands = [ 'rounding', 'roundingMode', 'ROUNDING_MODE',\n                'RM' ];\n            for(let cand of cands) {\n                rm = this._cons[cand];\n                if (rm != null) {\n                    rmFunc = cons => cons[cand];\n                    break;\n                }\n            }\n            //If not found any way to get rounding mode, let the user set\n            //dbNumber.roundingMode explicitly or use default\n            if (rmFunc == null) {\n                return;\n            }\n        }\n\n        this._getRoundingMode = cons => {\n            const rmVal = rmFunc(cons);\n            const rm = this._roundingModesMap.get(rmVal);\n            if (rm == null) {\n                throw new NoSQLArgumentError(`Could not determine rounding \\\nmode with value ${util.inspect(rmVal)}, please check configuration \\\nproperties dbNumber.RoundingModes and dbNumber.getRoundingMode`, cfg);\n            }\n            return rm;\n        };\n    }\n\n    _initGetPrecision(cfg) {\n        let prec;\n        let precFunc;\n        if (cfg.dbNumber.getPrecision != null) {\n            switch(typeof cfg.dbNumber.getPrecision) {\n            case 'function':\n                precFunc = cfg.dbNumber.getPrecision;\n                break;\n            case 'string':\n                prec = propertyByString(this._cons,\n                    cfg.dbNumber.getPrecision);\n                if (!isPosInt32(prec)) {\n                    throw new NoSQLArgumentError(`Missing or invalid value \\\nfor dbNumber.getRoundingMode property ${cfg.dbNumber.getPrecision}`, cfg);\n                }\n                precFunc = cons => propertyByString(cons,\n                    cfg.dbNumber.getPrecision);\n                break;\n            default:\n                throw new NoSQLArgumentError(`Invalid \\\ndbNumber.getPrecision: ${util.inspect(cfg.dbNumber.getPrecision)}`);\n            }\n        }\n\n        if (precFunc == null) {\n            const cands = [ 'precision', 'PRECISION' ];\n            for(let cand of cands) {\n                prec = this._cons[cand];\n                if (isPosInt32(prec)) {\n                    precFunc = cons => cons[cand];\n                    break;\n                }\n            }\n            if (precFunc == null) {\n                return;\n            }\n        }\n\n        this._getPrecision = cons => {\n            let prec = precFunc(cons);\n            if (!isPosInt32(prec)) {\n                throw new NoSQLArgumentError(`Got invalid precision value: \\\n${util.inspect(prec)}, please check configuration property \\\ndbNumber.getPrecision`, cfg);\n            }\n            return prec;\n        };\n    }\n\n    //get rounding mode constant in Java's format via _roundingModesMap\n    _initRoundingMode(cfg) {\n        if (cfg.dbNumber.roundingMode != null) {\n            if (typeof cfg.dbNumber.roundingMode === 'string') {\n                //check if dbNumber.roundingMode could be just a name of\n                //the rounding mode enumeration constant (with or without\n                //ROUND_ prefix)\n                const rm = cfg.dbNumber.roundingMode.startsWith('ROUND_') ?\n                    cfg.dbNumber.roundingMode.substring(6) :\n                    cfg.dbNumber.roundingMode;\n                if (rm in RoundingModes) {\n                    this._roundingMode = RoundingModes[rm];\n                    return;\n                }\n            }\n            this._roundingMode = this._roundingModesMap.get(\n                cfg.dbNumber.roundingMode);\n            if (this._roundingMode == null) {\n                throw new NoSQLArgumentError(`Could not determine rounding \\\nmode set by configuration property dbNumber.roundingMode with value \\\n${util.inspect(cfg.dbNumber.roundingMode)}, please check configuration \\\nproperties dbNumber.roundingMode and dbNumber.RoundingModes`, cfg);\n            }\n            return;\n        }\n        if (this._getRoundingMode != null) {\n            this._roundingMode = this._getRoundingMode(this._cons);\n        } else {\n            //if rounding mode cannot be found, use default ROUND_HALF_UP\n            this._roundingMode = RoundingModes.HALF_UP;\n        }\n    }\n\n    _initPrecision(cfg) {\n        if (cfg.dbNumber.precision != null) {\n            if (!isPosInt32(cfg.dbNumber.precision)) {\n                throw new NoSQLArgumentError(`Invalid value of \\\ndbNumber.precision: ${cfg.dbNumber.precision}`, cfg);\n            }\n            this._precision = cfg.dbNumber.precision;\n        } else if (this._getPrecision != null) {\n            this._precision = this._getPrecision(this._cons);\n        } else {\n            this._precision = DEFAULT_PRECISION;\n        }\n    }\n\n}\n\nmodule.exports = NumberTypeHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}