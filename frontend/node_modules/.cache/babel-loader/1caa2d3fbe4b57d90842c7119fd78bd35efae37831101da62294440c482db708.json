{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Type = require('../binary_protocol/constants').Type;\nconst DataReader = require('../binary_protocol/reader');\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\n\n//To prevent an infinite loop for bad serialization.\nconst MAX_ELEM_COUNT = 1000000000;\nclass NsonReader {\n  constructor(buf) {\n    this._dr = new DataReader(buf);\n    this._stack = [];\n  }\n\n  //for error reporting\n  _typeStr(type) {\n    if (type == undefined) {\n      type = this._type;\n    }\n    const str = Object.keys(Type).find(key => Type[key] === type);\n    return str ? str : `(unknown type code ${type})`;\n  }\n  _stackTop() {\n    return this._stack.length ? this._stack[this._stack.length - 1] : undefined;\n  }\n  _chkNsonType(type) {\n    if (this._type !== type) {\n      throw new NoSQLProtocolError(`Cannot read value of type ${this._typeStr()} as type \\\n${this._typeStr(type)}`);\n    }\n  }\n  _skipBytes(len) {\n    if (this._dr.offset + len > this._dr.buffer.length) {\n      throw new NoSQLProtocolError(`End of stream reached trying to skip ${len} byte(s) while \\\nskipping ${this._typeStr()}, stream length: ${this._dr.buffer.length}, \\\nposition: ${this._dr.offset}`);\n    }\n    this._dr.offset += len;\n  }\n  get dataReader() {\n    return this._dr;\n  }\n\n  //Last Nson type read, undefined if nothing is read yet.\n  get type() {\n    return this._type;\n  }\n\n  //Total number of elements or entries in the current array or map, or 0 if\n  //none. This lets the caller know how many entries to read. Note that this\n  //value is only guaranteed to be correct right after the call to Next()\n  //that finds the map or array.  Later this value may change when reading\n  //nested maps or arrays.\n  get count() {\n    const top = this._stackTop();\n    return top ? top.count : 0;\n  }\n\n  //Field name last read. If map entry is just read, the stream is\n  //positioned to get the field value.  For atomic values, the caller\n  //should call one of the read...() methods to read the value.\n  //For array or map, the caller should call next() again to start reading\n  //elements or entries, up to the value of count.\n  //Note that this is just last field name read, and is not saved on the\n  //stack, so the parent map field name will not be available even after\n  //the child map has been read. For now, we expect the caller to keep\n  //track of this if needed.\n  get field() {\n    return this._field;\n  }\n  reset() {\n    this._field = undefined;\n    this._type = undefined;\n    this._stack.length = 0;\n    this._dr.reset();\n    return this;\n  }\n\n  //Start reading the next element and return its Nson type.  For atomic\n  //values, the stream will be positioned to call one of read...() methods\n  //to get the value.  For array or map, the caller will need to call next()\n  //again to read the elements or entries. Note that if currently inside\n  //the map, this function will also consume the field name, which will be\n  //available as \"field\" property.\n  next() {\n    var top = this._stackTop();\n    //Check if we are done with current array or map, this can be\n    //multi-level.\n    while (top && top.numRead === top.count) {\n      const bytesRead = this._dr.offset - top.startPos;\n      if (top.len != bytesRead) {\n        // Or should we just log this instead?\n        throw new NoSQLProtocolError(`Read invalid ${this._typeStr()} length: expected \\\n${top.len}, got ${bytesRead}`);\n      }\n      this._stack.pop();\n      top = this._stackTop();\n    }\n    if (top != null) {\n      //If inside map, we must first read the field name.\n      if (top.type == Type.MAP) {\n        this._field = this._dr.readString();\n      }\n      top.numRead++;\n    }\n    this._type = this._dr.readByte();\n\n    //Start array or map.\n    if (this._type == Type.ARRAY || this._type == Type.MAP) {\n      const elem = {\n        type: this._type,\n        len: this._dr.readInt32BE(),\n        //byte length of array or map\n        startPos: this._dr.offset,\n        //starts after byte length is read\n        //number of array or map elements\n        count: this._dr.readInt32BE(),\n        numRead: 0\n      };\n      if (elem.count < 0 || elem.count > MAX_ELEM_COUNT) {\n        throw new NoSQLProtocolError(`Invalid number of elements for type ${this._typeStr()}: \\\n${elem.count}`);\n      }\n      this._stack.push(elem);\n    }\n  }\n  expectType(type) {\n    //Different error message than in _chkNsonType().\n    if (this._type !== type) {\n      throw new NoSQLProtocolError(`Expecting type ${this._typeStr(type)}, got type \\\n${this._typeStr()}`);\n    }\n  }\n  readBinary() {\n    this._chkNsonType(Type.BINARY);\n    return this._dr.readBinary();\n  }\n  readBoolean() {\n    this._chkNsonType(Type.BOOLEAN);\n    return this._dr.readBoolean();\n  }\n  readDouble() {\n    this._chkNsonType(Type.DOUBLE);\n    return this._dr.readDouble();\n  }\n  readInt() {\n    this._chkNsonType(Type.INTEGER);\n    return this._dr.readInt();\n  }\n  readLong(asBigInt = false) {\n    this._chkNsonType(Type.LONG);\n    return this._dr.readLong(asBigInt);\n  }\n  readString() {\n    this._chkNsonType(Type.STRING);\n    return this._dr.readString();\n  }\n  readDate() {\n    this._chkNsonType(Type.TIMESTAMP);\n    return this._dr.readDate();\n  }\n  readNumberAsString() {\n    this._chkNsonType(Type.NUMBER);\n    return this._dr.readString();\n  }\n\n  //Skip current value, assumes the type code has already been read.\n  skipValue() {\n    switch (this._type) {\n      case Type.ARRAY:\n      case Type.MAP:\n        {\n          const top = this._stackTop();\n          assert(top);\n          this._dr.offset = top.startPos + top.len;\n          this._stack.pop();\n          break;\n        }\n      // Timestamp and Number are written as strings.  Both string\n      // and binary use length-prefixed encoding.\n      case Type.STRING:\n      case Type.BINARY:\n      case Type.TIMESTAMP:\n      case Type.NUMBER:\n        {\n          const len = this._dr.readInt();\n          if (len > 0) {\n            this._skipBytes(len);\n          }\n          break;\n        }\n      // fixed 1 byte length\n      case Type.BOOLEAN:\n        this._skipBytes(1);\n        break;\n      // fixed 8 byte length\n      case Type.DOUBLE:\n        this._skipBytes(8);\n        break;\n      // variable length integer\n      case Type.INTEGER:\n        this._dr.readInt();\n        break;\n      // variable length long\n      case Type.LONG:\n        this._dr.readLong();\n        break;\n      default:\n        throw new NoSQLProtocolError(`Trying to skip unknown Nson type code: ${this._type}`);\n    }\n  }\n}\nmodule.exports = NsonReader;","map":{"version":3,"names":["assert","require","Type","DataReader","NoSQLProtocolError","MAX_ELEM_COUNT","NsonReader","constructor","buf","_dr","_stack","_typeStr","type","undefined","_type","str","Object","keys","find","key","_stackTop","length","_chkNsonType","_skipBytes","len","offset","buffer","dataReader","count","top","field","_field","reset","next","numRead","bytesRead","startPos","pop","MAP","readString","readByte","ARRAY","elem","readInt32BE","push","expectType","readBinary","BINARY","readBoolean","BOOLEAN","readDouble","DOUBLE","readInt","INTEGER","readLong","asBigInt","LONG","STRING","readDate","TIMESTAMP","readNumberAsString","NUMBER","skipValue","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/nson_protocol/reader.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Type = require('../binary_protocol/constants').Type;\nconst DataReader = require('../binary_protocol/reader');\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\n\n//To prevent an infinite loop for bad serialization.\nconst MAX_ELEM_COUNT = 1000000000;\n\nclass NsonReader {\n\n    constructor(buf) {\n        this._dr = new DataReader(buf);\n        this._stack = [];\n    }\n\n    //for error reporting\n    _typeStr(type) {\n        if (type == undefined) {\n            type = this._type;\n        }\n        const str = Object.keys(Type).find(key => Type[key] === type);\n        return str ? str : `(unknown type code ${type})`;\n    }\n\n    _stackTop() {\n        return this._stack.length ?\n            this._stack[this._stack.length - 1] : undefined;\n    }\n\n    _chkNsonType(type) {\n        if (this._type !== type) {\n            throw new NoSQLProtocolError(\n                `Cannot read value of type ${this._typeStr()} as type \\\n${this._typeStr(type)}`);\n        }\n    }\n\n    _skipBytes(len) {\n        if (this._dr.offset + len > this._dr.buffer.length) {\n            throw new NoSQLProtocolError(\n                `End of stream reached trying to skip ${len} byte(s) while \\\nskipping ${this._typeStr()}, stream length: ${this._dr.buffer.length}, \\\nposition: ${this._dr.offset}`);\n        }\n        this._dr.offset += len;\n    }\n\n    get dataReader() {\n        return this._dr;\n    }\n\n    //Last Nson type read, undefined if nothing is read yet.\n    get type() {\n        return this._type;\n    }\n\n    //Total number of elements or entries in the current array or map, or 0 if\n    //none. This lets the caller know how many entries to read. Note that this\n    //value is only guaranteed to be correct right after the call to Next()\n    //that finds the map or array.  Later this value may change when reading\n    //nested maps or arrays.\n    get count() {\n        const top = this._stackTop();\n        return top ? top.count : 0;\n    }\n\n    //Field name last read. If map entry is just read, the stream is\n    //positioned to get the field value.  For atomic values, the caller\n    //should call one of the read...() methods to read the value.\n    //For array or map, the caller should call next() again to start reading\n    //elements or entries, up to the value of count.\n    //Note that this is just last field name read, and is not saved on the\n    //stack, so the parent map field name will not be available even after\n    //the child map has been read. For now, we expect the caller to keep\n    //track of this if needed.\n    get field() { return this._field; }\n\n    reset() {\n        this._field = undefined;\n        this._type = undefined;\n        this._stack.length = 0;\n        this._dr.reset();\n        return this;\n    }\n\n    //Start reading the next element and return its Nson type.  For atomic\n    //values, the stream will be positioned to call one of read...() methods\n    //to get the value.  For array or map, the caller will need to call next()\n    //again to read the elements or entries. Note that if currently inside\n    //the map, this function will also consume the field name, which will be\n    //available as \"field\" property.\n    next() {\n        var top = this._stackTop();\n        //Check if we are done with current array or map, this can be\n        //multi-level.\n        while (top && top.numRead === top.count) {\n            const bytesRead = this._dr.offset - top.startPos;\n            if (top.len != bytesRead) {\n                // Or should we just log this instead?\n                throw new NoSQLProtocolError(\n                    `Read invalid ${this._typeStr()} length: expected \\\n${top.len}, got ${bytesRead}`);\n            }\n\n            this._stack.pop();\n            top = this._stackTop();\n        }\n\n        if (top != null) {\n            //If inside map, we must first read the field name.\n            if (top.type == Type.MAP) {\n                this._field = this._dr.readString();\n            }\n            top.numRead++;\n        }\n\n        this._type = this._dr.readByte();\n\n        //Start array or map.\n        if (this._type == Type.ARRAY || this._type == Type.MAP) {\n            const elem = {\n                type: this._type,\n                len: this._dr.readInt32BE(), //byte length of array or map\n                startPos: this._dr.offset, //starts after byte length is read\n                //number of array or map elements\n                count: this._dr.readInt32BE(),\n                numRead: 0\n            };\n\n            if (elem.count < 0 || elem.count > MAX_ELEM_COUNT) {\n                throw new NoSQLProtocolError(\n                    `Invalid number of elements for type ${this._typeStr()}: \\\n${elem.count}`);\n            }\n\n            this._stack.push(elem);\n        }\n    }\n\n    expectType(type) {\n        //Different error message than in _chkNsonType().\n        if (this._type !== type) {\n            throw new NoSQLProtocolError(\n                `Expecting type ${this._typeStr(type)}, got type \\\n${this._typeStr()}`);\n        }\n    }\n\n    readBinary() {\n        this._chkNsonType(Type.BINARY);\n        return this._dr.readBinary();\n    }\n\n    readBoolean() {\n        this._chkNsonType(Type.BOOLEAN);\n        return this._dr.readBoolean();\n    }\n\n    readDouble() {\n        this._chkNsonType(Type.DOUBLE);\n        return this._dr.readDouble();\n    }\n\n    readInt() {\n        this._chkNsonType(Type.INTEGER);\n        return this._dr.readInt();\n    }\n\n    readLong(asBigInt = false) {\n        this._chkNsonType(Type.LONG);\n        return this._dr.readLong(asBigInt);\n    }\n\n    readString() {\n        this._chkNsonType(Type.STRING);\n        return this._dr.readString();\n    }\n\n    readDate() {\n        this._chkNsonType(Type.TIMESTAMP);\n        return this._dr.readDate();\n    }\n\n    readNumberAsString() {\n        this._chkNsonType(Type.NUMBER);\n        return this._dr.readString();\n    }\n\n    //Skip current value, assumes the type code has already been read.\n    skipValue() {\n        switch (this._type) {\n        case Type.ARRAY:\n        case Type.MAP: {\n            const top = this._stackTop();\n            assert(top);\n            this._dr.offset = top.startPos + top.len;\n            this._stack.pop();\n            break;\n        }\n        // Timestamp and Number are written as strings.  Both string\n        // and binary use length-prefixed encoding.\n        case Type.STRING:\n        case Type.BINARY:\n        case Type.TIMESTAMP:\n        case Type.NUMBER: {\n            const len = this._dr.readInt();\n            if (len > 0) {\n                this._skipBytes(len);\n            }\n            break;\n        }\n        // fixed 1 byte length\n        case Type.BOOLEAN:\n            this._skipBytes(1);\n            break;\n        // fixed 8 byte length\n        case Type.DOUBLE:\n            this._skipBytes(8);\n            break;\n        // variable length integer\n        case Type.INTEGER:\n            this._dr.readInt();\n            break;\n        // variable length long\n        case Type.LONG:\n            this._dr.readLong();\n            break;\n        default:\n            throw new NoSQLProtocolError(\n                `Trying to skip unknown Nson type code: ${this._type}`);\n        }\n    }\n\n}\n\nmodule.exports = NsonReader;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,IAAI,GAAGD,OAAO,CAAC,8BAA8B,CAAC,CAACC,IAAI;AACzD,MAAMC,UAAU,GAAGF,OAAO,CAAC,2BAA2B,CAAC;AACvD,MAAMG,kBAAkB,GAAGH,OAAO,CAAC,UAAU,CAAC,CAACG,kBAAkB;;AAEjE;AACA,MAAMC,cAAc,GAAG,UAAU;AAEjC,MAAMC,UAAU,CAAC;EAEbC,WAAWA,CAACC,GAAG,EAAE;IACb,IAAI,CAACC,GAAG,GAAG,IAAIN,UAAU,CAACK,GAAG,CAAC;IAC9B,IAAI,CAACE,MAAM,GAAG,EAAE;EACpB;;EAEA;EACAC,QAAQA,CAACC,IAAI,EAAE;IACX,IAAIA,IAAI,IAAIC,SAAS,EAAE;MACnBD,IAAI,GAAG,IAAI,CAACE,KAAK;IACrB;IACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,IAAI,CAACf,IAAI,CAAC,CAACgB,IAAI,CAACC,GAAG,IAAIjB,IAAI,CAACiB,GAAG,CAAC,KAAKP,IAAI,CAAC;IAC7D,OAAOG,GAAG,GAAGA,GAAG,GAAI,sBAAqBH,IAAK,GAAE;EACpD;EAEAQ,SAASA,CAAA,EAAG;IACR,OAAO,IAAI,CAACV,MAAM,CAACW,MAAM,GACrB,IAAI,CAACX,MAAM,CAAC,IAAI,CAACA,MAAM,CAACW,MAAM,GAAG,CAAC,CAAC,GAAGR,SAAS;EACvD;EAEAS,YAAYA,CAACV,IAAI,EAAE;IACf,IAAI,IAAI,CAACE,KAAK,KAAKF,IAAI,EAAE;MACrB,MAAM,IAAIR,kBAAkB,CACvB,6BAA4B,IAAI,CAACO,QAAQ,CAAC,CAAE;AAC7D,EAAE,IAAI,CAACA,QAAQ,CAACC,IAAI,CAAE,EAAC,CAAC;IAChB;EACJ;EAEAW,UAAUA,CAACC,GAAG,EAAE;IACZ,IAAI,IAAI,CAACf,GAAG,CAACgB,MAAM,GAAGD,GAAG,GAAG,IAAI,CAACf,GAAG,CAACiB,MAAM,CAACL,MAAM,EAAE;MAChD,MAAM,IAAIjB,kBAAkB,CACvB,wCAAuCoB,GAAI;AAC5D,WAAW,IAAI,CAACb,QAAQ,CAAC,CAAE,oBAAmB,IAAI,CAACF,GAAG,CAACiB,MAAM,CAACL,MAAO;AACrE,YAAY,IAAI,CAACZ,GAAG,CAACgB,MAAO,EAAC,CAAC;IACtB;IACA,IAAI,CAAChB,GAAG,CAACgB,MAAM,IAAID,GAAG;EAC1B;EAEA,IAAIG,UAAUA,CAAA,EAAG;IACb,OAAO,IAAI,CAAClB,GAAG;EACnB;;EAEA;EACA,IAAIG,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACE,KAAK;EACrB;;EAEA;EACA;EACA;EACA;EACA;EACA,IAAIc,KAAKA,CAAA,EAAG;IACR,MAAMC,GAAG,GAAG,IAAI,CAACT,SAAS,CAAC,CAAC;IAC5B,OAAOS,GAAG,GAAGA,GAAG,CAACD,KAAK,GAAG,CAAC;EAC9B;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIE,KAAKA,CAAA,EAAG;IAAE,OAAO,IAAI,CAACC,MAAM;EAAE;EAElCC,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACD,MAAM,GAAGlB,SAAS;IACvB,IAAI,CAACC,KAAK,GAAGD,SAAS;IACtB,IAAI,CAACH,MAAM,CAACW,MAAM,GAAG,CAAC;IACtB,IAAI,CAACZ,GAAG,CAACuB,KAAK,CAAC,CAAC;IAChB,OAAO,IAAI;EACf;;EAEA;EACA;EACA;EACA;EACA;EACA;EACAC,IAAIA,CAAA,EAAG;IACH,IAAIJ,GAAG,GAAG,IAAI,CAACT,SAAS,CAAC,CAAC;IAC1B;IACA;IACA,OAAOS,GAAG,IAAIA,GAAG,CAACK,OAAO,KAAKL,GAAG,CAACD,KAAK,EAAE;MACrC,MAAMO,SAAS,GAAG,IAAI,CAAC1B,GAAG,CAACgB,MAAM,GAAGI,GAAG,CAACO,QAAQ;MAChD,IAAIP,GAAG,CAACL,GAAG,IAAIW,SAAS,EAAE;QACtB;QACA,MAAM,IAAI/B,kBAAkB,CACvB,gBAAe,IAAI,CAACO,QAAQ,CAAC,CAAE;AACpD,EAAEkB,GAAG,CAACL,GAAI,SAAQW,SAAU,EAAC,CAAC;MAClB;MAEA,IAAI,CAACzB,MAAM,CAAC2B,GAAG,CAAC,CAAC;MACjBR,GAAG,GAAG,IAAI,CAACT,SAAS,CAAC,CAAC;IAC1B;IAEA,IAAIS,GAAG,IAAI,IAAI,EAAE;MACb;MACA,IAAIA,GAAG,CAACjB,IAAI,IAAIV,IAAI,CAACoC,GAAG,EAAE;QACtB,IAAI,CAACP,MAAM,GAAG,IAAI,CAACtB,GAAG,CAAC8B,UAAU,CAAC,CAAC;MACvC;MACAV,GAAG,CAACK,OAAO,EAAE;IACjB;IAEA,IAAI,CAACpB,KAAK,GAAG,IAAI,CAACL,GAAG,CAAC+B,QAAQ,CAAC,CAAC;;IAEhC;IACA,IAAI,IAAI,CAAC1B,KAAK,IAAIZ,IAAI,CAACuC,KAAK,IAAI,IAAI,CAAC3B,KAAK,IAAIZ,IAAI,CAACoC,GAAG,EAAE;MACpD,MAAMI,IAAI,GAAG;QACT9B,IAAI,EAAE,IAAI,CAACE,KAAK;QAChBU,GAAG,EAAE,IAAI,CAACf,GAAG,CAACkC,WAAW,CAAC,CAAC;QAAE;QAC7BP,QAAQ,EAAE,IAAI,CAAC3B,GAAG,CAACgB,MAAM;QAAE;QAC3B;QACAG,KAAK,EAAE,IAAI,CAACnB,GAAG,CAACkC,WAAW,CAAC,CAAC;QAC7BT,OAAO,EAAE;MACb,CAAC;MAED,IAAIQ,IAAI,CAACd,KAAK,GAAG,CAAC,IAAIc,IAAI,CAACd,KAAK,GAAGvB,cAAc,EAAE;QAC/C,MAAM,IAAID,kBAAkB,CACvB,uCAAsC,IAAI,CAACO,QAAQ,CAAC,CAAE;AAC3E,EAAE+B,IAAI,CAACd,KAAM,EAAC,CAAC;MACH;MAEA,IAAI,CAAClB,MAAM,CAACkC,IAAI,CAACF,IAAI,CAAC;IAC1B;EACJ;EAEAG,UAAUA,CAACjC,IAAI,EAAE;IACb;IACA,IAAI,IAAI,CAACE,KAAK,KAAKF,IAAI,EAAE;MACrB,MAAM,IAAIR,kBAAkB,CACvB,kBAAiB,IAAI,CAACO,QAAQ,CAACC,IAAI,CAAE;AACtD,EAAE,IAAI,CAACD,QAAQ,CAAC,CAAE,EAAC,CAAC;IACZ;EACJ;EAEAmC,UAAUA,CAAA,EAAG;IACT,IAAI,CAACxB,YAAY,CAACpB,IAAI,CAAC6C,MAAM,CAAC;IAC9B,OAAO,IAAI,CAACtC,GAAG,CAACqC,UAAU,CAAC,CAAC;EAChC;EAEAE,WAAWA,CAAA,EAAG;IACV,IAAI,CAAC1B,YAAY,CAACpB,IAAI,CAAC+C,OAAO,CAAC;IAC/B,OAAO,IAAI,CAACxC,GAAG,CAACuC,WAAW,CAAC,CAAC;EACjC;EAEAE,UAAUA,CAAA,EAAG;IACT,IAAI,CAAC5B,YAAY,CAACpB,IAAI,CAACiD,MAAM,CAAC;IAC9B,OAAO,IAAI,CAAC1C,GAAG,CAACyC,UAAU,CAAC,CAAC;EAChC;EAEAE,OAAOA,CAAA,EAAG;IACN,IAAI,CAAC9B,YAAY,CAACpB,IAAI,CAACmD,OAAO,CAAC;IAC/B,OAAO,IAAI,CAAC5C,GAAG,CAAC2C,OAAO,CAAC,CAAC;EAC7B;EAEAE,QAAQA,CAACC,QAAQ,GAAG,KAAK,EAAE;IACvB,IAAI,CAACjC,YAAY,CAACpB,IAAI,CAACsD,IAAI,CAAC;IAC5B,OAAO,IAAI,CAAC/C,GAAG,CAAC6C,QAAQ,CAACC,QAAQ,CAAC;EACtC;EAEAhB,UAAUA,CAAA,EAAG;IACT,IAAI,CAACjB,YAAY,CAACpB,IAAI,CAACuD,MAAM,CAAC;IAC9B,OAAO,IAAI,CAAChD,GAAG,CAAC8B,UAAU,CAAC,CAAC;EAChC;EAEAmB,QAAQA,CAAA,EAAG;IACP,IAAI,CAACpC,YAAY,CAACpB,IAAI,CAACyD,SAAS,CAAC;IACjC,OAAO,IAAI,CAAClD,GAAG,CAACiD,QAAQ,CAAC,CAAC;EAC9B;EAEAE,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAACtC,YAAY,CAACpB,IAAI,CAAC2D,MAAM,CAAC;IAC9B,OAAO,IAAI,CAACpD,GAAG,CAAC8B,UAAU,CAAC,CAAC;EAChC;;EAEA;EACAuB,SAASA,CAAA,EAAG;IACR,QAAQ,IAAI,CAAChD,KAAK;MAClB,KAAKZ,IAAI,CAACuC,KAAK;MACf,KAAKvC,IAAI,CAACoC,GAAG;QAAE;UACX,MAAMT,GAAG,GAAG,IAAI,CAACT,SAAS,CAAC,CAAC;UAC5BpB,MAAM,CAAC6B,GAAG,CAAC;UACX,IAAI,CAACpB,GAAG,CAACgB,MAAM,GAAGI,GAAG,CAACO,QAAQ,GAAGP,GAAG,CAACL,GAAG;UACxC,IAAI,CAACd,MAAM,CAAC2B,GAAG,CAAC,CAAC;UACjB;QACJ;MACA;MACA;MACA,KAAKnC,IAAI,CAACuD,MAAM;MAChB,KAAKvD,IAAI,CAAC6C,MAAM;MAChB,KAAK7C,IAAI,CAACyD,SAAS;MACnB,KAAKzD,IAAI,CAAC2D,MAAM;QAAE;UACd,MAAMrC,GAAG,GAAG,IAAI,CAACf,GAAG,CAAC2C,OAAO,CAAC,CAAC;UAC9B,IAAI5B,GAAG,GAAG,CAAC,EAAE;YACT,IAAI,CAACD,UAAU,CAACC,GAAG,CAAC;UACxB;UACA;QACJ;MACA;MACA,KAAKtB,IAAI,CAAC+C,OAAO;QACb,IAAI,CAAC1B,UAAU,CAAC,CAAC,CAAC;QAClB;MACJ;MACA,KAAKrB,IAAI,CAACiD,MAAM;QACZ,IAAI,CAAC5B,UAAU,CAAC,CAAC,CAAC;QAClB;MACJ;MACA,KAAKrB,IAAI,CAACmD,OAAO;QACb,IAAI,CAAC5C,GAAG,CAAC2C,OAAO,CAAC,CAAC;QAClB;MACJ;MACA,KAAKlD,IAAI,CAACsD,IAAI;QACV,IAAI,CAAC/C,GAAG,CAAC6C,QAAQ,CAAC,CAAC;QACnB;MACJ;QACI,MAAM,IAAIlD,kBAAkB,CACvB,0CAAyC,IAAI,CAACU,KAAM,EAAC,CAAC;IAC/D;EACJ;AAEJ;AAEAiD,MAAM,CAACC,OAAO,GAAG1D,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}