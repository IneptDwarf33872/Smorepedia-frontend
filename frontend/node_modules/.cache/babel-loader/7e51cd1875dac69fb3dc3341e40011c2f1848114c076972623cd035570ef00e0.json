{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl\n *\n * Please see LICENSE.txt file included in the top-level directory of the\n * appropriate download for a copy of the license and additional information.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst BinaryProtocol = require('../binary_protocol/protocol');\nconst DataWriter = require('../binary_protocol/writer');\nconst MinMaxAggregator = require('./value_aggr').MinMaxAggregator;\nconst SumAggregator = require('./value_aggr').SumAggregator;\nconst CountAggregator = require('./value_aggr').CountAggregator;\nconst CollectAggregator = require('./value_aggr').CollectAggregator;\nconst PlanIterator = require('./common').PlanIterator;\nconst SQLFuncCode = require('./common').SQLFuncCode;\nconst normalizeNumeric = require('./utils').normalizeNumeric;\nconst resBuf2MapKey = require('./utils').resBuf2MapKey;\nconst sizeof = require('./utils').sizeof;\n\n//Regarding _writeSortedMaps: for grouping columns of type MAP, RECORD or\n//JSON, received from the server as js objects, we do not consider the order\n//of their properties, so that 2 js objects that differ only in the order of\n//their properties are considered equal and thus should generate identical\n//group keys.  To achieve this, we serialize these objects in sorted order\n//of their property names when creating a group key.\n\nclass GroupIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n    this._inputIter = qpExec.makeIterator(step.input);\n    this._dw = new DataWriter();\n    this._groupMap = new Map();\n    if (step.countMem) {\n      this._mem = 0;\n    }\n    this._serializerOpt = {\n      _dbNumber: qpExec.opt._dbNumber,\n      _writeSortedMaps: true,\n      _replacer: normalizeNumeric\n    };\n    if (this._step.countMem) {\n      this._incMem = mem => {\n        this._mem += mem;\n        this._qpExec.incMem(mem);\n      };\n    }\n  }\n  _createGroupRow(row) {\n    const res = {};\n    let i;\n\n    //initialize grouping columns\n    for (i = 0; i < this._step.gbColCnt; i++) {\n      const colName = this._step.colNames[i];\n      const val = row[colName];\n      //EMPTY_VALUE is only possible here for the distinct case,\n      //otherwise this row will be skipped in next()\n      res[colName] = val !== EMPTY_VALUE ? val : undefined;\n      if (this._incMem) {\n        this._incMem(sizeof(val));\n      }\n    }\n\n    //initialize aggregators for aggregate columns\n    for (; i < this._step.colNames.length; i++) {\n      const colName = this._step.colNames[i];\n      const funcCode = this._step.aggrFuncCodes[i - this._step.gbColCnt];\n      switch (funcCode) {\n        case SQLFuncCode.FN_MIN:\n        case SQLFuncCode.FN_MAX:\n          res[colName] = new MinMaxAggregator(this, this._incMem, funcCode === SQLFuncCode.FN_MIN);\n          break;\n        case SQLFuncCode.FN_SUM:\n          res[colName] = new SumAggregator(this, this._incMem);\n          break;\n        case SQLFuncCode.FN_COUNT_STAR:\n        case SQLFuncCode.FN_COUNT:\n        case SQLFuncCode.FN_COUNT_NUMBERS:\n          res[colName] = new CountAggregator(this, this._incMem, funcCode);\n          break;\n        case SQLFuncCode.FN_ARRAY_COLLECT:\n        case SQLFuncCode.FN_ARRAY_COLLECT_DISTINCT:\n          res[colName] = new CollectAggregator(this, this._incMem, funcCode === SQLFuncCode.FN_ARRAY_COLLECT_DISTINCT, this._qpExec.opt._testMode);\n          break;\n        default:\n          //Validated during deserialization.\n          assert(false);\n          break;\n      }\n    }\n    return res;\n  }\n  _makeGroupKey(row) {\n    this._dw.reset();\n    for (let i = 0; i < this._step.gbColCnt; i++) {\n      let val = row[this._step.colNames[i]];\n      if (val === EMPTY_VALUE) {\n        if (!this._step.isDistinct) {\n          return;\n        }\n        val = undefined;\n      }\n      BinaryProtocol.writeFieldValue(this._dw, val, this._serializerOpt);\n    }\n    return resBuf2MapKey(this._dw.buffer);\n  }\n  _aggregate(groupRow, inputRow) {\n    for (let i = this._step.gbColCnt; i < this._step.colNames.length; i++) {\n      const colName = this._step.colNames[i];\n      groupRow[colName].aggregate(inputRow[colName]);\n    }\n  }\n  async next() {\n    if (this._resIter == null) {\n      while (await this._inputIter.next()) {\n        const inputRow = this._inputIter.result;\n        const key = this._makeGroupKey(inputRow);\n        if (key == null) {\n          continue;\n        }\n        let groupRow = this._groupMap.get(key);\n        if (groupRow == null) {\n          if (this._incMem) {\n            //The memory for the value will be incremented in\n            //_createGroupRow().\n            this._incMem(sizeof(this, key));\n          }\n          groupRow = this._createGroupRow(inputRow);\n          this._groupMap.set(key, groupRow);\n          if (this._step.isDistinct) {\n            this.result = groupRow;\n            return true;\n          }\n        }\n        this._aggregate(groupRow, inputRow);\n      }\n      if (this._qpExec._needUserCont || this._step.isDistinct) {\n        return false;\n      }\n      this._resIter = this._groupMap.entries();\n    }\n    const res = this._resIter.next();\n    if (res.done) {\n      return false;\n    }\n    const key = res.value[0];\n    const val = res.value[1];\n\n    //In the result row, replace value aggregators with their results.\n    for (let i = this._step.gbColCnt; i < this._step.colNames.length; i++) {\n      const colName = this._step.colNames[i];\n      val[colName] = val[colName].result;\n    }\n    this.result = val;\n    if (this._step.removeRes) {\n      this._groupMap.delete(key);\n    }\n    return true;\n  }\n  reset() {\n    this._groupMap.clear();\n    if (this._step.countMem) {\n      this._qpExec.decMem(this._mem);\n      this._mem = 0;\n    }\n    this._resIter = null;\n  }\n}\nGroupIterator._isAsync = true;\nmodule.exports = GroupIterator;","map":{"version":3,"names":["assert","require","EMPTY_VALUE","BinaryProtocol","DataWriter","MinMaxAggregator","SumAggregator","CountAggregator","CollectAggregator","PlanIterator","SQLFuncCode","normalizeNumeric","resBuf2MapKey","sizeof","GroupIterator","constructor","qpExec","step","_inputIter","makeIterator","input","_dw","_groupMap","Map","countMem","_mem","_serializerOpt","_dbNumber","opt","_writeSortedMaps","_replacer","_step","_incMem","mem","_qpExec","incMem","_createGroupRow","row","res","i","gbColCnt","colName","colNames","val","undefined","length","funcCode","aggrFuncCodes","FN_MIN","FN_MAX","FN_SUM","FN_COUNT_STAR","FN_COUNT","FN_COUNT_NUMBERS","FN_ARRAY_COLLECT","FN_ARRAY_COLLECT_DISTINCT","_testMode","_makeGroupKey","reset","isDistinct","writeFieldValue","buffer","_aggregate","groupRow","inputRow","aggregate","next","_resIter","result","key","get","set","_needUserCont","entries","done","value","removeRes","delete","clear","decMem","_isAsync","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/query/group.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl\n *\n * Please see LICENSE.txt file included in the top-level directory of the\n * appropriate download for a copy of the license and additional information.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst BinaryProtocol = require('../binary_protocol/protocol');\nconst DataWriter = require('../binary_protocol/writer');\nconst MinMaxAggregator = require('./value_aggr').MinMaxAggregator;\nconst SumAggregator = require('./value_aggr').SumAggregator;\nconst CountAggregator = require('./value_aggr').CountAggregator;\nconst CollectAggregator = require('./value_aggr').CollectAggregator;\nconst PlanIterator = require('./common').PlanIterator;\nconst SQLFuncCode = require('./common').SQLFuncCode;\nconst normalizeNumeric = require('./utils').normalizeNumeric;\nconst resBuf2MapKey = require('./utils').resBuf2MapKey;\nconst sizeof = require('./utils').sizeof;\n\n//Regarding _writeSortedMaps: for grouping columns of type MAP, RECORD or\n//JSON, received from the server as js objects, we do not consider the order\n//of their properties, so that 2 js objects that differ only in the order of\n//their properties are considered equal and thus should generate identical\n//group keys.  To achieve this, we serialize these objects in sorted order\n//of their property names when creating a group key.\n\nclass GroupIterator extends PlanIterator {\n\n    constructor(qpExec, step) {\n        super(qpExec, step);\n        this._inputIter = qpExec.makeIterator(step.input);\n        this._dw = new DataWriter();\n        this._groupMap = new Map();\n        if (step.countMem) {\n            this._mem = 0;\n        }\n        this._serializerOpt = {\n            _dbNumber: qpExec.opt._dbNumber,\n            _writeSortedMaps: true,\n            _replacer: normalizeNumeric\n        };\n        \n        if (this._step.countMem) {\n            this._incMem = mem => {\n                this._mem += mem;\n                this._qpExec.incMem(mem);\n            };    \n        }\n    }\n\n    _createGroupRow(row) {\n        const res = {};\n        let i;\n\n        //initialize grouping columns\n        for(i = 0; i < this._step.gbColCnt; i++) {\n            const colName = this._step.colNames[i];\n            const val = row[colName];\n            //EMPTY_VALUE is only possible here for the distinct case,\n            //otherwise this row will be skipped in next()\n            res[colName] = val !== EMPTY_VALUE ? val : undefined;\n            if (this._incMem) {\n                this._incMem(sizeof(val));\n            }\n        }\n\n        //initialize aggregators for aggregate columns\n        for(; i < this._step.colNames.length; i++) {\n            const colName = this._step.colNames[i];\n            const funcCode = this._step.aggrFuncCodes[\n                i - this._step.gbColCnt];\n            switch(funcCode) {\n            case SQLFuncCode.FN_MIN:\n            case SQLFuncCode.FN_MAX:\n                res[colName] = new MinMaxAggregator(this, this._incMem,\n                    funcCode === SQLFuncCode.FN_MIN);\n                break;\n            case SQLFuncCode.FN_SUM:\n                res[colName] = new SumAggregator(this, this._incMem);\n                break;\n            case SQLFuncCode.FN_COUNT_STAR:\n            case SQLFuncCode.FN_COUNT:\n            case SQLFuncCode.FN_COUNT_NUMBERS:\n                res[colName] = new CountAggregator(this, this._incMem,\n                    funcCode);\n                break;\n            case SQLFuncCode.FN_ARRAY_COLLECT:\n            case SQLFuncCode.FN_ARRAY_COLLECT_DISTINCT:\n                res[colName] = new CollectAggregator(this, this._incMem,\n                    funcCode === SQLFuncCode.FN_ARRAY_COLLECT_DISTINCT,\n                    this._qpExec.opt._testMode);\n                break;\n            default:\n                //Validated during deserialization.\n                assert(false);\n                break;\n            }\n        }\n\n        return res;\n    }\n\n    _makeGroupKey(row) {\n        this._dw.reset();\n        for(let i = 0; i < this._step.gbColCnt; i++) {\n            let val = row[this._step.colNames[i]];\n            if (val === EMPTY_VALUE) {\n\n                if (!this._step.isDistinct) {\n                    return;\n                }\n                val = undefined;\n            }\n            BinaryProtocol.writeFieldValue(this._dw, val,\n                this._serializerOpt);\n        }\n        return resBuf2MapKey(this._dw.buffer);\n    }\n\n    _aggregate(groupRow, inputRow) {\n        for(let i = this._step.gbColCnt;\n            i < this._step.colNames.length; i++) {\n            const colName = this._step.colNames[i];\n            groupRow[colName].aggregate(inputRow[colName]);\n        }\n    }\n\n    async next() {\n        if (this._resIter == null) {\n            while(await this._inputIter.next()) {\n                const inputRow = this._inputIter.result;\n                const key = this._makeGroupKey(inputRow);\n                if (key == null) {\n                    continue;\n                }\n                let groupRow = this._groupMap.get(key);\n                if (groupRow == null) {\n                    if (this._incMem) {\n                        //The memory for the value will be incremented in\n                        //_createGroupRow().\n                        this._incMem(sizeof(this, key));\n                    }\n                    groupRow = this._createGroupRow(inputRow);\n                    this._groupMap.set(key, groupRow);\n                    if (this._step.isDistinct) {\n                        this.result = groupRow;\n                        return true;\n                    }\n                }\n                this._aggregate(groupRow, inputRow);\n            }\n            if (this._qpExec._needUserCont || this._step.isDistinct) {\n                return false;\n            }\n            this._resIter = this._groupMap.entries();\n        }\n\n        const res = this._resIter.next();\n        if (res.done) {\n            return false;\n        }\n\n        const key = res.value[0];        \n        const val = res.value[1];\n\n        //In the result row, replace value aggregators with their results.\n        for(let i = this._step.gbColCnt; i < this._step.colNames.length;\n            i++) {\n            const colName = this._step.colNames[i];\n            val[colName] = val[colName].result;\n        }\n\n        this.result = val;\n        if (this._step.removeRes) {\n            this._groupMap.delete(key);\n        }\n\n        return true;\n    }\n\n    reset() {\n        this._groupMap.clear();\n        if (this._step.countMem) {\n            this._qpExec.decMem(this._mem);\n            this._mem = 0;\n        }\n        this._resIter = null;\n    }\n\n}\n\nGroupIterator._isAsync = true;\n\nmodule.exports = GroupIterator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}