{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\n\n/**\n * Utility classes to facilitate serialization/deserialization\n *\n * The numeric methods use packed_integer module which uses a format\n * that is always sorted.\n */\n\nclass ResizableBuffer {\n  constructor(arg) {\n    switch (typeof arg) {\n      case 'undefined':\n        this._buf = Buffer.allocUnsafe(1024);\n        this._len = 0;\n        break;\n      case 'number':\n        this._buf = Buffer.allocUnsafe(arg);\n        this._len = 0;\n        break;\n      case 'object':\n        if (arg instanceof Buffer) {\n          this._buf = arg;\n          this._len = arg.length;\n          break;\n        }\n      default:\n        assert(false);\n    }\n  }\n  _checkBound(off) {\n    assert(off >= 0);\n    if (off >= this._len) {\n      throw new RangeError(`Index ${off} out of bounds for length ${this._len}`);\n    }\n  }\n  _checkBounds(start, end) {\n    assert(start >= 0 && end >= 0 && start <= end);\n    if (end > this._len) {\n      throw new RangeError(`[${start}, ${end}] out of bounds for length ${this._len}`);\n    }\n  }\n  _ensureCapacity(cap) {\n    if (this._buf.length < cap) {\n      const newCap = Math.max(this._buf.length * 2, cap);\n      const b = Buffer.allocUnsafe(newCap);\n      this._buf.copy(b, 0, 0, this._len);\n      this._buf = b;\n    }\n  }\n  get buffer() {\n    return this._buf;\n  }\n  get length() {\n    return this._len;\n  }\n  set length(value) {\n    this._ensureCapacity(value);\n    this._len = value;\n  }\n  clear() {\n    this._len = 0;\n    return this;\n  }\n  readUInt8(off) {\n    this._checkBound(off);\n    return this._buf.readUInt8(off);\n  }\n  readInt8(off) {\n    this._checkBound(off);\n    return this._buf.readInt8(off);\n  }\n  writeUInt8(value, off) {\n    const newCap = off + 1;\n    this._ensureCapacity(newCap);\n    this._buf.writeUInt8(value, off);\n    if (this._len < newCap) {\n      this._len = newCap;\n    }\n  }\n  writeInt16BE(value, off) {\n    const newCap = off + 2;\n    this._ensureCapacity(newCap);\n    this._buf.writeInt16BE(value, off);\n    if (this._len < newCap) {\n      this._len = newCap;\n    }\n  }\n  readInt16BE(off) {\n    this._checkBounds(off, off + 2);\n    return this._buf.readInt16BE(off);\n  }\n  readInt32BE(off) {\n    this._checkBounds(off, off + 4);\n    return this._buf.readInt32BE(off);\n  }\n  writeInt32BE(value, off) {\n    const newCap = off + 4;\n    this._ensureCapacity(newCap);\n    this._buf.writeInt32BE(value, off);\n    if (this._len < newCap) {\n      this._len = newCap;\n    }\n  }\n  readDoubleBE(off) {\n    this._checkBounds(off, off + 8);\n    return this._buf.readDoubleBE(off);\n  }\n  slice(start = 0, end = start + this._len) {\n    this._checkBounds(start, end);\n    return this._buf.subarray(start, end);\n  }\n  readBuffer(off, len) {\n    this._checkBounds(off, off + len);\n    const b = Buffer.allocUnsafe(len);\n    this._buf.copy(b, 0, off, off + len);\n    return b;\n  }\n  writeBuffer(buf, off) {\n    const newCap = off + buf.length;\n    this._ensureCapacity(newCap);\n    buf.copy(this._buf, off, 0, buf.length);\n    if (this._len < newCap) {\n      this._len = newCap;\n    }\n  }\n  appendBuffer(value) {\n    this.writeBuffer(value, this._len);\n  }\n  ensureExtraCapacity(extra) {\n    this._ensureCapacity(this._len + extra);\n  }\n  toString(encoding = 'utf8') {\n    return this._buf.toString(encoding, 0, this._len);\n  }\n}\nmodule.exports = ResizableBuffer;","map":{"version":3,"names":["assert","require","ResizableBuffer","constructor","arg","_buf","Buffer","allocUnsafe","_len","length","_checkBound","off","RangeError","_checkBounds","start","end","_ensureCapacity","cap","newCap","Math","max","b","copy","buffer","value","clear","readUInt8","readInt8","writeUInt8","writeInt16BE","readInt16BE","readInt32BE","writeInt32BE","readDoubleBE","slice","subarray","readBuffer","len","writeBuffer","buf","appendBuffer","ensureExtraCapacity","extra","toString","encoding","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/binary_protocol/buffer.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\n\n/**\n * Utility classes to facilitate serialization/deserialization\n *\n * The numeric methods use packed_integer module which uses a format\n * that is always sorted.\n */\n\nclass ResizableBuffer {\n    constructor(arg) {\n        switch(typeof arg) {\n        case 'undefined':\n            this._buf = Buffer.allocUnsafe(1024);\n            this._len = 0;\n            break;\n        case 'number':\n            this._buf = Buffer.allocUnsafe(arg);\n            this._len = 0;\n            break;\n        case 'object':\n            if (arg instanceof Buffer) {\n                this._buf = arg;\n                this._len = arg.length;\n                break;\n            }\n        default:\n            assert(false);\n        }\n    }\n\n    _checkBound(off) {\n        assert(off >= 0);\n        if (off >= this._len) {\n            throw new RangeError(\n                `Index ${off} out of bounds for length ${this._len}`);\n        }\n    }\n\n    _checkBounds(start, end) {\n        assert(start >= 0  && end >= 0 && start <= end);\n        if (end > this._len) {\n            throw new RangeError(\n                `[${start}, ${end}] out of bounds for length ${this._len}`);\n        }\n    }\n\n    _ensureCapacity(cap) {\n        if (this._buf.length < cap) {\n            const newCap = Math.max(this._buf.length * 2, cap);\n            const b = Buffer.allocUnsafe(newCap);\n            this._buf.copy(b, 0, 0, this._len);\n            this._buf = b;\n        }\n    }\n\n    get buffer() {\n        return this._buf;\n    }\n\n    get length() {\n        return this._len;\n    }\n\n    set length(value) {\n        this._ensureCapacity(value);\n        this._len = value;\n    }\n\n    clear() {\n        this._len = 0;\n        return this;\n    }\n\n    readUInt8(off) {\n        this._checkBound(off);\n        return this._buf.readUInt8(off);\n    }\n\n    readInt8(off) {\n        this._checkBound(off);\n        return this._buf.readInt8(off);\n    }\n\n    writeUInt8(value, off) {\n        const newCap = off + 1;\n        this._ensureCapacity(newCap);\n        this._buf.writeUInt8(value, off);\n        if (this._len < newCap) {\n            this._len = newCap;\n        }\n    }\n\n    writeInt16BE(value, off) {\n        const newCap = off + 2;\n        this._ensureCapacity(newCap);\n        this._buf.writeInt16BE(value, off);\n        if (this._len < newCap) {\n            this._len = newCap;\n        }\n    }\n\n    readInt16BE(off) {\n        this._checkBounds(off, off + 2);\n        return this._buf.readInt16BE(off);\n    }\n\n    readInt32BE(off) {\n        this._checkBounds(off, off + 4);\n        return this._buf.readInt32BE(off);\n    }\n\n    writeInt32BE(value, off) {\n        const newCap = off + 4;\n        this._ensureCapacity(newCap);\n        this._buf.writeInt32BE(value, off);\n        if (this._len < newCap) {\n            this._len = newCap;\n        }\n    }\n\n    readDoubleBE(off) {\n        this._checkBounds(off, off + 8);\n        return this._buf.readDoubleBE(off);\n    }\n\n    slice(start = 0, end = start + this._len) {\n        this._checkBounds(start, end);\n        return this._buf.subarray(start, end);\n    }\n\n    readBuffer(off, len) {\n        this._checkBounds(off, off + len);\n        const b = Buffer.allocUnsafe(len);\n        this._buf.copy(b, 0, off, off + len);\n        return b;\n    }\n\n    writeBuffer(buf, off) {\n        const newCap = off + buf.length;\n        this._ensureCapacity(newCap);\n        buf.copy(this._buf, off, 0, buf.length);\n        if (this._len < newCap) {\n            this._len = newCap;\n        }\n    }\n\n    appendBuffer(value) {\n        this.writeBuffer(value, this._len);\n    }\n\n    ensureExtraCapacity(extra) {\n        this._ensureCapacity(this._len + extra);\n    }\n\n    toString(encoding = 'utf8') {\n        return this._buf.toString(encoding, 0, this._len);\n    }\n}\n\nmodule.exports = ResizableBuffer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}