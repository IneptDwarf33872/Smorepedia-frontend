{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst PackedInteger = require('./packed_integer');\nconst ResizableBuffer = require('./buffer');\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\nconst stringToUTCDate = require('../utils').stringToUTCDate;\nclass DataReader {\n  constructor(buf) {\n    this._buf = buf instanceof ResizableBuffer ? buf : new ResizableBuffer(buf);\n    this._off = 0;\n  }\n  _readByte() {\n    return this._buf.readInt8(this._off++);\n  }\n  _handleEOF(e, ...args) {\n    if (e.name == 'RangeError') {\n      let msg = 'End of stream reached';\n      if (args.length > 0) {\n        msg += ` while reading ${args[0]}`;\n        if (args.length > 1) {\n          msg += ` of length ${args[1]}`;\n        }\n      }\n      throw new NoSQLProtocolError(msg);\n    } else {\n      throw e;\n    }\n  }\n  _readBuffer(len) {\n    try {\n      const ret = this._buf.readBuffer(this._off, len);\n      this._off += len;\n      return ret;\n    } catch (e) {\n      this._handleEOF(e, 'binary', len);\n    }\n  }\n  get buffer() {\n    return this._buf;\n  }\n  get offset() {\n    return this._off;\n  }\n  set offset(val) {\n    assert(val >= 0);\n    if (val > this._buf.length) {\n      throw new NoSQLProtocolError(`End of stream reached: offset \\\n${val} is past length ${this._buf.length}`);\n    }\n    this._off = val;\n  }\n\n  /**\n   * Reads a packed integer from the buffer and returns it.\n   *\n   * @return the integer that was read\n   * @throws NoSQLError if the input format is invalid or end of input is\n   * reached\n   */\n  readInt() {\n    try {\n      //We pass ResizableBuffer instead of Buffer so that EOF checking\n      //is performed when reading bytes.\n      let {\n        value,\n        off\n      } = PackedInteger.readSortedInt(this._buf, this._off);\n      this._off = off;\n      return value;\n    } catch (e) {\n      this._handleEOF(e, 'packed int');\n    }\n  }\n\n  /**\n   * Reads a packed long from the buffer and returns it.\n   *\n   * @param asBigInt Whether to read the value as bigint\n   * @return the long that was read\n   * @throws NoSQLError if the input format is invalid or end of input is\n   * reached\n   */\n  readLong(asBigInt = false) {\n    try {\n      let {\n        value,\n        off\n      } = PackedInteger.readSortedLong(this._buf, this._off, asBigInt);\n      this._off = off;\n      return value;\n    } catch (e) {\n      this._handleEOF(e, 'packed long');\n    }\n  }\n\n  /**\n   * Reads a packed long from the buffer as bigint and returns it.\n   *\n   * @return bigint value of the long that was read\n   * @throws NoSQLError if the input format is invalid or end of input is\n   * reached\n   */\n  readLongAsBigInt() {\n    return this._readLong(true);\n  }\n\n  /**\n   * Reads a string written by {@link #writeString}, using standard UTF-8\n   *\n   * @return a string or null\n   * @throws NoSQLError if the input format is invalid or end of input is\n   * reached\n   */\n  readString() {\n    const len = this.readInt();\n    if (len < -1) {\n      throw new NoSQLProtocolError(`Invalid string length: ${len}`);\n    }\n    if (len == -1) {\n      return null;\n    }\n    if (len == 0) {\n      return '';\n    }\n    try {\n      const nextOff = this._off + len;\n      const ret = this._buf.slice(this._off, nextOff).toString('utf8');\n      this._off = nextOff;\n      return ret;\n    } catch (e) {\n      this._handleEOF(e, 'string', len);\n    }\n  }\n  readArray(readItem) {\n    const len = this.readInt();\n    if (len < -1) {\n      throw new NoSQLProtocolError(`Invalid array length: ${len}`);\n    }\n    if (len == -1) {\n      return null;\n    }\n    const a = new Array(len);\n    for (let i = 0; i < len; i++) {\n      a[i] = readItem();\n    }\n    return a;\n  }\n  readStringArray() {\n    return this.readArray(this.readString.bind(this));\n  }\n\n  /**\n   * Reads a possibly null binary as a {@link #readPackedInt\n   * sequence length} followed by the array contents.\n   *\n   * @return array the array or null\n   * @throws NoSQLError if the input format is invalid or end of input is\n   * reached\n   */\n  readBinary() {\n    const len = this.readInt();\n    if (len < -1) {\n      throw new NoSQLProtocolError(`Invalid binary length: ${len}`);\n    }\n    if (len == -1) {\n      return null;\n    }\n    if (len == 0) {\n      return Buffer.allocUnsafe(0);\n    }\n    return this._readBuffer(len);\n  }\n\n  //Equivalent to readByteArrayWithInt() in BinaryProtocol.java\n  readBinary2() {\n    const len = this.readInt32BE();\n    if (len <= 0) {\n      return Buffer.allocUnsafe(0);\n    }\n    return this._readBuffer(len);\n  }\n  readIntArray() {\n    return this.readArray(this.readInt.bind(this));\n  }\n  readByte() {\n    try {\n      return this._readByte();\n    } catch (e) {\n      this._handleEOF(e, 'byte');\n    }\n  }\n  readBoolean() {\n    try {\n      return Boolean(this._readByte());\n    } catch (e) {\n      this._handleEOF(e, 'boolean');\n    }\n  }\n  readDouble() {\n    try {\n      const ret = this._buf.readDoubleBE(this._off);\n      this._off += 8;\n      return ret;\n    } catch (e) {\n      this._handleEOF(e, 'double');\n    }\n  }\n  readDate() {\n    const s = this.readString();\n    if (s === null) {\n      return null;\n    }\n    return stringToUTCDate(s);\n  }\n  readInt16BE() {\n    try {\n      const ret = this._buf.readInt16BE(this._off);\n      this._off += 2;\n      return ret;\n    } catch (e) {\n      this._handleEOF(e, 'short');\n    }\n  }\n  readInt32BE() {\n    try {\n      const ret = this._buf.readInt32BE(this._off);\n      this._off += 4;\n      return ret;\n    } catch (e) {\n      this._handleEOF(e, 'integer');\n    }\n  }\n  reset() {\n    this._off = 0;\n    return this;\n  }\n  toString(encoding = 'utf8') {\n    return this._buf.toString(encoding);\n  }\n}\nmodule.exports = DataReader;","map":{"version":3,"names":["assert","require","PackedInteger","ResizableBuffer","NoSQLProtocolError","stringToUTCDate","DataReader","constructor","buf","_buf","_off","_readByte","readInt8","_handleEOF","e","args","name","msg","length","_readBuffer","len","ret","readBuffer","buffer","offset","val","readInt","value","off","readSortedInt","readLong","asBigInt","readSortedLong","readLongAsBigInt","_readLong","readString","nextOff","slice","toString","readArray","readItem","a","Array","i","readStringArray","bind","readBinary","Buffer","allocUnsafe","readBinary2","readInt32BE","readIntArray","readByte","readBoolean","Boolean","readDouble","readDoubleBE","readDate","s","readInt16BE","reset","encoding","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/binary_protocol/reader.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst PackedInteger = require('./packed_integer');\nconst ResizableBuffer = require('./buffer');\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\nconst stringToUTCDate = require('../utils').stringToUTCDate;\n\nclass DataReader {\n    constructor(buf) {\n        this._buf = (buf instanceof ResizableBuffer) ? buf :\n            new ResizableBuffer(buf);\n        this._off = 0;\n    }\n\n    _readByte() {\n        return this._buf.readInt8(this._off++);\n    }\n\n    _handleEOF(e, ...args) {\n        if (e.name == 'RangeError') {\n            let msg = 'End of stream reached';\n            if (args.length > 0) {\n                msg += ` while reading ${args[0]}`;\n                if (args.length > 1) {\n                    msg += ` of length ${args[1]}`;\n                }\n            }\n            throw new NoSQLProtocolError(msg);\n        } else {\n            throw e;\n        }\n    }\n\n    _readBuffer(len) {\n        try {\n            const ret = this._buf.readBuffer(this._off, len);\n            this._off += len;\n            return ret;\n        } catch(e) {\n            this._handleEOF(e, 'binary', len);\n        }\n    }\n\n    get buffer() {\n        return this._buf;\n    }\n\n    get offset() {\n        return this._off;\n    }\n\n    set offset(val) {\n        assert(val >= 0);\n        if (val > this._buf.length) {\n            throw new NoSQLProtocolError(`End of stream reached: offset \\\n${val} is past length ${this._buf.length}`);\n        }\n        this._off = val;\n    }\n\n    /**\n     * Reads a packed integer from the buffer and returns it.\n     *\n     * @return the integer that was read\n     * @throws NoSQLError if the input format is invalid or end of input is\n     * reached\n     */\n    readInt() {\n        try {\n            //We pass ResizableBuffer instead of Buffer so that EOF checking\n            //is performed when reading bytes.\n            let { value, off } = PackedInteger.readSortedInt(\n                this._buf, this._off);\n            this._off = off;\n            return value;\n        } catch(e) {\n            this._handleEOF(e, 'packed int');\n        }\n    }\n\n    /**\n     * Reads a packed long from the buffer and returns it.\n     *\n     * @param asBigInt Whether to read the value as bigint\n     * @return the long that was read\n     * @throws NoSQLError if the input format is invalid or end of input is\n     * reached\n     */\n    readLong(asBigInt = false) {\n        try {\n            let { value, off } = PackedInteger.readSortedLong(\n                this._buf, this._off, asBigInt);\n            this._off = off;\n            return value;\n        } catch(e) {\n            this._handleEOF(e, 'packed long');\n        }\n    }\n\n    /**\n     * Reads a packed long from the buffer as bigint and returns it.\n     *\n     * @return bigint value of the long that was read\n     * @throws NoSQLError if the input format is invalid or end of input is\n     * reached\n     */\n    readLongAsBigInt() {\n        return this._readLong(true);\n    }\n\n    /**\n     * Reads a string written by {@link #writeString}, using standard UTF-8\n     *\n     * @return a string or null\n     * @throws NoSQLError if the input format is invalid or end of input is\n     * reached\n     */\n    readString() {\n        const len = this.readInt();\n        if (len < -1) {\n            throw new NoSQLProtocolError(`Invalid string length: ${len}`);\n        }\n        if (len == -1) {\n            return null;\n        }\n        if (len == 0) {\n            return '';\n        }\n        try {\n            const nextOff = this._off + len;\n            const ret = this._buf.slice(this._off, nextOff).toString('utf8');\n            this._off = nextOff;\n            return ret;\n            \n        } catch(e) {\n            this._handleEOF(e, 'string', len);\n        }\n    }\n\n    readArray(readItem) {\n        const len = this.readInt();\n        if (len < -1) {\n            throw new NoSQLProtocolError(`Invalid array length: ${len}`);\n        }\n        if (len == -1) {\n            return null;\n        }\n        const a = new Array(len);\n        for(let i = 0; i < len; i++) {\n            a[i] = readItem();\n        }\n        return a;\n    }\n\n    readStringArray() {\n        return this.readArray(this.readString.bind(this));\n    }\n\n    /**\n     * Reads a possibly null binary as a {@link #readPackedInt\n     * sequence length} followed by the array contents.\n     *\n     * @return array the array or null\n     * @throws NoSQLError if the input format is invalid or end of input is\n     * reached\n     */\n    readBinary() {\n        const len = this.readInt();\n        if (len < -1) {\n            throw new NoSQLProtocolError(`Invalid binary length: ${len}`);\n        }\n        if (len == -1) {\n            return null;\n        }\n        if (len == 0) {\n            return Buffer.allocUnsafe(0);\n        }\n        return this._readBuffer(len);\n    }\n\n    //Equivalent to readByteArrayWithInt() in BinaryProtocol.java\n    readBinary2() {\n        const len = this.readInt32BE();\n        if (len <= 0) {\n            return Buffer.allocUnsafe(0);\n        }\n        return this._readBuffer(len);\n    }\n\n    readIntArray() {\n        return this.readArray(this.readInt.bind(this));\n    }\n\n    readByte() {\n        try {\n            return this._readByte();\n        } catch(e) {\n            this._handleEOF(e, 'byte');\n        }\n    }\n\n    readBoolean() {\n        try {\n            return Boolean(this._readByte());\n        } catch(e) {\n            this._handleEOF(e, 'boolean');\n        }\n    }\n\n    readDouble() {\n        try {\n            const ret = this._buf.readDoubleBE(this._off);\n            this._off += 8;\n            return ret;\n        } catch(e) {\n            this._handleEOF(e, 'double');\n        }\n    }\n\n    readDate() {\n        const s = this.readString();\n        if (s === null) {\n            return null;\n        }\n        return stringToUTCDate(s);\n    }\n\n    readInt16BE() {\n        try {\n            const ret = this._buf.readInt16BE(this._off);\n            this._off += 2;\n            return ret;\n        } catch(e) {\n            this._handleEOF(e, 'short');\n        }\n    }\n\n    readInt32BE() {\n        try {\n            const ret = this._buf.readInt32BE(this._off);\n            this._off += 4;\n            return ret;\n        } catch(e) {\n            this._handleEOF(e, 'integer');\n        }\n    }\n\n    reset() {\n        this._off = 0;\n        return this;\n    }\n\n    toString(encoding = 'utf8') {\n        return this._buf.toString(encoding);\n    }\n}\n\nmodule.exports = DataReader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}