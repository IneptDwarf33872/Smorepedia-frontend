{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\n/**\n * NOTE: this is cut/paste/edited from JE's class of the same name. An\n * important difference is that the packed values returned are ALWAYS\n * sorted. The unsorted methods supported by JE for compatibility are not\n * included.\n *\n * Static methods for reading and writing packed integers.\n */\nconst assert = require('assert');\nconst isInt32 = require('../utils').isInt32;\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\n\n//Avoid ReferenceError(s) below in case bigint is not supported.\nconst BigIntCons = typeof BigInt === 'function' ? BigInt : Number;\n\n//We are not using bigint literals to avoid syntax errors if bigint is not\n//supported.\nconst INT32_MIN = -2147483648; // -2^31\nconst INT32_MAX = 2147483647; // 2^31 - 1\nconst INT32_RANGE = 0x100000000; // 2^32\nconst INT32_RANGE_BIGINT = BigIntCons(0x100000000); // 2^32n\nconst INT64_BIGINT_MIN = BigIntCons('-9223372036854775808'); // -2^63\nconst INT64_BIGINT_MAX = BigIntCons('9223372036854775807'); // 2^63 - 1\n\n//Saving these instead of instantiating every time does improve performance\n//according to benchmark.\nconst BIGINT_119 = BigIntCons(119);\nconst BIGINT_121 = BigIntCons(121);\n\n/**\n * In JavaScript, number can represent integer up to 53 bits long (not\n * including the sign).  These numbers are called safe integers since they\n * can be represented without loss of precision.  The number is in double\n * precision format and thus cannot directly serialize to 2-complement\n * integer or long format.  Bitwise operations on number will treat it as\n * signed 32-bit integer and thus it would be truncated accordingly.\n * The functions below allow to split safe integer into 2 numbers, each of\n * which is a signed 32-bit integer such that if each of these integers is\n * represented in 2-complement format, their combined (appended)\n * representation would be that of a 2-complement format of 64-bit signed\n * long integer representing original number.  This will allow us to\n * perform bitwise operations on the number as if it was 64-bit signed long\n * integer, by performing these operations on each of 2 constituent parts.\n * The results can be combined to represent resulting long integer as number\n * (as long as it is within the safe integer range).\n */\nclass Int64 {\n  static _to2sComplement(valueL, valueR, isNegative) {\n    if (!isNegative) {\n      assert(isInt32(valueL));\n      valueR = ~~valueR;\n    } else {\n      valueL = ~valueL;\n      valueR = ~valueR + 1;\n      if (valueR === 0) {\n        //if ~valueR was -1 we have to carry 1 to the left side\n        valueL++;\n      }\n    }\n    return {\n      valueL,\n      valueR\n    };\n  }\n  static _splitNumber(value) {\n    const isNegative = value < 0;\n    if (isInt32(value)) {\n      return {\n        valueL: isNegative ? -1 : 0,\n        valueR: value\n      };\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    const valueL = Math.floor(value / INT32_RANGE);\n    const valueR = value % INT32_RANGE;\n    return Int64._to2sComplement(valueL, valueR, isNegative);\n  }\n  static _splitBigInt(value) {\n    const isNegative = value < 0;\n    if (value >= INT32_MIN && value <= INT32_MAX) {\n      return {\n        valueL: isNegative ? -1 : 0,\n        valueR: Number(value)\n      };\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    const valueL = Number(value / INT32_RANGE_BIGINT);\n    const valueR = Number(value % INT32_RANGE_BIGINT);\n    return Int64._to2sComplement(valueL, valueR, isNegative);\n  }\n  static split(value) {\n    return typeof value === 'bigint' ? Int64._splitBigInt(value) : Int64._splitNumber(value);\n  }\n  static combine(valueL, valueR, toBigInt = false) {\n    assert(isInt32(valueL));\n    assert(isInt32(valueR));\n    if (valueL < 0) {\n      //negative\n      valueL++;\n      if (valueR > 0) {\n        valueR -= INT32_RANGE;\n      }\n    } else if (valueR < 0) {\n      //positive, adjust valueR to unsigned\n      valueR += INT32_RANGE;\n    }\n    return toBigInt ? BigIntCons(valueL) * INT32_RANGE_BIGINT + BigIntCons(valueR) : valueL * INT32_RANGE + valueR;\n  }\n}\nclass PackedInteger {\n  /**\n   * The maximum number of bytes needed to store an int value (5).\n   */\n  static get MAX_LENGTH() {\n    return 5;\n  }\n\n  /**\n   * The maximum number of bytes needed to store a long value (9).\n   */\n  static get MAX_LONG_LENGTH() {\n    return 9;\n  }\n\n  /**\n   * Reads a sorted packed integer at the given buffer offset and returns it.\n   *\n   * @param buf the buffer to read from.\n   *\n   * @param off the offset in the buffer at which to start reading.\n   *\n   * @return the integer that was read.\n   */\n  static readSortedInt(buf, off) {\n    let byteLen;\n    let negative;\n\n    /* The first byte of the buf stores the length of the value part. */\n    let b1 = buf.readUInt8(off++);\n    /* Adjust the byteLen to the real length of the value part. */\n    if (b1 < 0x08) {\n      byteLen = 0x08 - b1;\n      negative = true;\n    } else if (b1 > 0xf7) {\n      byteLen = b1 - 0xf7;\n      negative = false;\n    } else {\n      return {\n        value: b1 - 127,\n        off\n      };\n    }\n\n    /*\n    * The following bytes on the buf store the value as a big endian\n    * integer. We extract the significant bytes from the buf and put them\n    * into the value in big endian order.\n    *\n    * Note that unlike in Java, we don't need to do (buf[off++] & 0xff)\n    * if we read the byte as unsigned 8-bit integer.\n    */\n    let value;\n    if (negative) {\n      value = -1;\n    } else {\n      value = 0;\n    }\n    if (byteLen > 3) {\n      value = value << 8 | buf.readUInt8(off++);\n    }\n    if (byteLen > 2) {\n      value = value << 8 | buf.readUInt8(off++);\n    }\n    if (byteLen > 1) {\n      value = value << 8 | buf.readUInt8(off++);\n    }\n    value = value << 8 | buf.readUInt8(off++);\n\n    /*\n        * After get the adjusted value, we have to adjust it back to the\n        * original value.\n        */\n    if (negative) {\n      value -= 119;\n    } else {\n      value += 121;\n    }\n    return {\n      value,\n      off\n    };\n  }\n\n  /**\n   * Reads a sorted packed long at the given buffer offset and\n   * returns it.  The long should be max of 53 bits (not including sign),\n   * which is max allowed by JavaScript Number type.\n   *\n   * @param buf the buffer to read from.\n   *\n   * @param off the offset in the buffer at which to start reading.\n   *\n   * @return tuple containing the resulting value and resulting offset\n   */\n  static readSortedLong(buf, off, toBigInt = false) {\n    let byteLen;\n    let negative;\n\n    /* The first byte of the buf stores the length of the value part. */\n    let b1 = buf.readUInt8(off++);\n    /* Adjust the byteLen to the real length of the value part. */\n    if (b1 < 0x08) {\n      byteLen = 0x08 - b1;\n      negative = true;\n    } else if (b1 > 0xf7) {\n      byteLen = b1 - 0xf7;\n      negative = false;\n    } else {\n      return {\n        value: toBigInt ? BigIntCons(b1 - 127) : b1 - 127,\n        off\n      };\n    }\n\n    /*\n    * The following bytes on the buf store the value as a big endian\n    * integer. We extract the significant bytes from the buf and put them\n    * into the value in big endian order.\n    *\n    * Note that unlike in Java, we don't need to do (buf[off++] & 0xff)\n    * if we read the byte as unsigned 8-bit integer.\n    */\n    let valueL, valueR;\n    if (negative) {\n      valueL = -1;\n      valueR = -1;\n    } else {\n      valueL = 0;\n      valueR = 0;\n    }\n\n    //64 bit int overflow will be detected in Int64.combine()\n    if (byteLen > 7) {\n      valueL = valueL << 8 | buf.readUInt8(off++);\n    }\n    if (byteLen > 6) {\n      valueL = valueL << 8 | buf.readUInt8(off++);\n    }\n    if (byteLen > 5) {\n      valueL = valueL << 8 | buf.readUInt8(off++);\n    }\n    if (byteLen > 4) {\n      valueL = valueL << 8 | buf.readUInt8(off++);\n    }\n    if (byteLen > 3) {\n      valueR = valueR << 8 | buf.readUInt8(off++);\n    }\n    if (byteLen > 2) {\n      valueR = valueR << 8 | buf.readUInt8(off++);\n    }\n    if (byteLen > 1) {\n      valueR = valueR << 8 | buf.readUInt8(off++);\n    }\n    valueR = valueR << 8 | buf.readUInt8(off++);\n    let value = Int64.combine(valueL, valueR, toBigInt);\n\n    /*\n    * After obtaining the adjusted value, we have to adjust it back to the\n    * original value.\n    */\n    if (negative) {\n      value -= toBigInt ? BIGINT_119 : 119;\n    } else {\n      value += toBigInt ? BIGINT_121 : 121;\n    }\n    return {\n      value,\n      off\n    };\n  }\n\n  /**\n   * In the functions below we assume that Buffer has enough space for\n   * the result.\n   */\n\n  /**\n   * Writes a packed sorted integer starting at the given buffer offset and\n   * returns the next offset to be written.\n   *\n   * @param buf the buffer to write to.\n   *\n   * @param off the offset in the buffer at which to start writing.\n   *\n   * @param value the integer to be written.\n   *\n   * @return the offset past the bytes written.\n   */\n  static writeSortedInt(buf, off, value) {\n    if (!isInt32(value)) {\n      throw new NoSQLArgumentError(`Value ${value} out of range for type INTEGER`);\n    }\n\n    /*\n    * Values in the inclusive range [-119,120] are stored in a single\n    * byte. For values outside that range, the first byte stores the\n    * number of additional bytes. The additional bytes store\n    * (value + 119 for negative and value - 121 for positive) as an\n    * unsigned big endian integer.\n    */\n    const byte1Off = off++;\n    if (value < -119) {\n      /*\n      * If the value < -119, then first adjust the value by adding 119.\n      * Then the adjusted value is stored as an unsigned big endian\n      * integer.\n      */\n      value += 119;\n\n      /*\n      * Store the adjusted value as an unsigned big endian integer.\n      * For an negative integer, from left to right, the first\n      * significant byte is the byte which is not equal to 0xFF. Also\n      * please note that, because the adjusted value is stored in big\n      * endian integer, we extract the significant byte from left to\n      * right.\n      *\n      * In the left to right order, if the first byte of the adjusted\n      * value is a significant byte, it will be stored in the 2nd byte\n      * of the buf. Then we will look at the 2nd byte of the adjusted\n      * value to see if this byte is the significant byte, if yes, this\n      * byte will be stored in the 3rd byte of the buf, and the like.\n      *\n      * It seems that Buffer converts number to byte automatically, but\n      * I haven't seen this stated explicitly in the doc, so adding\n      * (& 0xFF) just in case.\n      */\n      if ((value | 0x00FFFFFF) != -1) {\n        buf.writeUInt8(value >> 24 & 0xFF, off++);\n      }\n      if ((value | 0x0000FFFF) != -1) {\n        buf.writeUInt8(value >> 16 & 0xFF, off++);\n      }\n      if ((value | 0x000000FF) != -1) {\n        buf.writeUInt8(value >> 8 & 0xFF, off++);\n      }\n      buf.writeUInt8(value & 0xFF, off++);\n\n      /*\n      * valueLen is the length of the value part stored in buf. Because\n      * the first byte of buf is used to stored the length, we need\n      * to subtract one.\n      */\n      const valueLen = off - byte1Off - 1;\n\n      /*\n      * The first byte stores the number of additional bytes. Here we\n      * store the result of 0x08 - valueLen, rather than directly store\n      * valueLen. The reason is to implement natural sort order for\n      * byte-by-byte comparison.\n      */\n      buf.writeUInt8(0x08 - valueLen, byte1Off);\n    } else if (value > 120) {\n      /*\n      * If the value > 120, then first adjust the value by subtracting\n      * 121. Then the adjusted value is stored as an unsigned big endian\n      * integer.\n      */\n      value -= 121;\n\n      /*\n      * Store the adjusted value as an unsigned big endian integer.\n      * For a positive integer, from left to right, the first\n      * significant byte is the byte which is not equal to 0x00.\n      *\n      * In the left to right order, if the first byte of the adjusted\n      * value is a significant byte, it will be stored in the 2nd byte\n      * of the buf. Then we will look at the 2nd byte of the adjusted\n      * value to see if this byte is the significant byte, if yes, this\n      * byte will be stored in the 3rd byte of the buf, and the like.\n      */\n      if ((value & 0xFF000000) != 0) {\n        buf.writeUInt8(value >> 24 & 0xFF, off++);\n      }\n      if ((value & 0xFFFF0000) != 0) {\n        buf.writeUInt8(value >> 16 & 0xFF, off++);\n      }\n      if ((value & 0xFFFFFF00) != 0) {\n        buf.writeUInt8(value >> 8 & 0xFF, off++);\n      }\n      buf.writeUInt8(value & 0xFF, off++);\n\n      /*\n      * valueLen is the length of the value part stored in buf. Because\n      * the first byte of buf is used to stored the length, we need to\n      * subtract one.\n      */\n      const valueLen = off - byte1Off - 1;\n\n      /*\n      * The first byte stores the number of additional bytes. Here we\n      * store the result of 0xF7 + valueLen, rather than directly store\n      * valueLen. The reason is to implement natural sort order for\n      * byte-by-byte comparison.\n      */\n      buf.writeUInt8(0xF7 + valueLen, byte1Off);\n    } else {\n      /*\n      * If -119 <= value <= 120, only one byte is needed to store the\n      * value. The stored value is the original value plus 127.\n      */\n      buf.writeUInt8(value + 127, byte1Off);\n    }\n    return off;\n  }\n\n  /**\n   * Writes a packed sorted long integer starting at the given buffer offset\n   * and returns the next offset to be written.\n   *\n   * @param buf the buffer to write to.\n   *\n   * @param off the offset in the buffer at which to start writing.\n   *\n   * @param value the long integer to be written.\n   *\n   * @return the offset past the bytes written.\n   */\n  static writeSortedLong(buf, off, value) {\n    if (typeof value === 'number') {\n      //See Protocol.writeFieldValue().\n      assert(Number.isSafeInteger(value));\n    } else {\n      assert(typeof value === 'bigint');\n      if (value < INT64_BIGINT_MIN || value > INT64_BIGINT_MAX) {\n        throw new NoSQLArgumentError(`Value ${value} out of range for type LONG`);\n      }\n    }\n\n    /*\n    * Values in the inclusive range [-119,120] are stored in a single\n    * byte. For values outside that range, the first byte stores the\n    * number of additional bytes. The additional bytes store\n    * (value + 119 for negative and value - 121 for positive) as an\n    * unsigned big endian integer.\n    */\n    const byte1Off = off++;\n    if (value < -119) {\n      /*\n      * If the value < -119, then first adjust the value by adding 119.\n      * Then the adjusted value is stored as an unsigned big endian\n      * integer.\n      */\n      value += typeof value === 'bigint' ? BIGINT_119 : 119;\n      const {\n        valueL,\n        valueR\n      } = Int64.split(value);\n\n      /*\n      * Store the adjusted value as an unsigned big endian integer.\n      * For an negative integer, from left to right, the first\n      * significant byte is the byte which is not equal to 0xFF. Also\n      * please note that, because the adjusted value is stored in big\n      * endian integer, we extract the significant byte from left to\n      * right.\n      *\n      * In the left to right order, if the first byte of the adjusted\n      * value is a significant byte, it will be stored in the 2nd byte\n      * of the buf. Then we will look at the 2nd byte of the adjusted\n      * value to see if this byte is the significant byte, if yes, this\n      * byte will be stored in the 3rd byte of the buf, and the like.\n      *\n      * It seems that Buffer converts number to byte automatically, but\n      * I haven't seen this stated explicitly in the doc, so adding\n      * (& 0xFF) just in case.\n      */\n      if ((valueL | 0x00FFFFFF) != -1) {\n        buf.writeUInt8(valueL >> 24 & 0xFF, off++);\n      }\n      if ((valueL | 0x0000FFFF) != -1) {\n        buf.writeUInt8(valueL >> 16 & 0xFF, off++);\n      }\n      if ((valueL | 0x000000FF) != -1) {\n        buf.writeUInt8(valueL >> 8 & 0xFF, off++);\n      }\n      if (valueL != -1) {\n        buf.writeUInt8(valueL & 0xFF, off++);\n      }\n      if (valueL != -1 || (valueR | 0x00FFFFFF) != -1) {\n        buf.writeUInt8(valueR >> 24 & 0xFF, off++);\n      }\n      if (valueL != -1 || (valueR | 0x0000FFFF) != -1) {\n        buf.writeUInt8(valueR >> 16 & 0xFF, off++);\n      }\n      if (valueL != -1 || (valueR | 0x000000FF) != -1) {\n        buf.writeUInt8(valueR >> 8 & 0xFF, off++);\n      }\n      buf.writeUInt8(valueR & 0xFF, off++);\n\n      /*\n      * valueLen is the length of the value part stored in buf. Because\n      * the first byte of buf is used to stored the length, so we need\n      * to minus one.\n      */\n      const valueLen = off - byte1Off - 1;\n\n      /*\n      * The first byte stores the number of additional bytes. Here we\n      * store the result of 0x08 - valueLen, rather than directly store\n      * valueLen. The reason is to implement nature sort order for\n      * byte-by-byte comparison.\n      */\n      buf.writeUInt8(0x08 - valueLen, byte1Off);\n    } else if (value > 120) {\n      /*\n      * If the value > 120, then first adjust the value by subtracting\n      * 119. Then the adjusted value is stored as an unsigned big endian\n      * integer.\n      */\n      value -= typeof value === 'bigint' ? BIGINT_121 : 121;\n      const {\n        valueL,\n        valueR\n      } = Int64.split(value);\n\n      /*\n      * Store the adjusted value as an unsigned big endian integer.\n      * For a positive integer, from left to right, the first\n      * significant byte is the byte which is not equal to 0x00.\n      *\n      * In the left to right order, if the first byte of the adjusted\n      * value is a significant byte, it will be stored in the 2nd byte\n      * of the buf. Then we will look at the 2nd byte of the adjusted\n      * value to see if this byte is the significant byte, if yes, this\n      * byte will be stored in the 3rd byte of the buf, and the like.\n      */\n      if ((valueL & 0xFF000000) != 0) {\n        buf.writeUInt8(valueL >> 24 & 0xFF, off++);\n      }\n      if ((valueL & 0xFFFF0000) != 0) {\n        buf.writeUInt8(valueL >> 16 & 0xFF, off++);\n      }\n      if ((valueL & 0xFFFFFF00) != 0) {\n        buf.writeUInt8(valueL >> 8 & 0xFF, off++);\n      }\n      if (valueL != 0) {\n        buf.writeUInt8(valueL & 0xFF, off++);\n      }\n      if (valueL || (valueR & 0xFF000000) != 0) {\n        buf.writeUInt8(valueR >> 24 & 0xFF, off++);\n      }\n      if (valueL || (valueR & 0xFFFF0000) != 0) {\n        buf.writeUInt8(valueR >> 16 & 0xFF, off++);\n      }\n      if (valueL || (valueR & 0xFFFFFF00) != 0) {\n        buf.writeUInt8(valueR >> 8 & 0xFF, off++);\n      }\n      buf.writeUInt8(valueR & 0xFF, off++);\n      const valueLen = off - byte1Off - 1;\n\n      /*\n      * The first byte stores the number of additional bytes. Here we\n      * store the result of 0xF7 + valueLen, rather than directly store\n      * valueLen. The reason is to implement nature sort order for\n      * byte-by-byte comparison.\n      */\n      buf.writeUInt8(0xF7 + valueLen, byte1Off);\n    } else {\n      /*\n      * If -119 <= value <= 120, only one byte is needed to store the\n      * value. The stored value is the original value adds 127.\n      */\n      buf.writeUInt8(Number(value) + 127, byte1Off);\n    }\n    return off;\n  }\n}\nmodule.exports = PackedInteger;","map":{"version":3,"names":["assert","require","isInt32","NoSQLArgumentError","BigIntCons","BigInt","Number","INT32_MIN","INT32_MAX","INT32_RANGE","INT32_RANGE_BIGINT","INT64_BIGINT_MIN","INT64_BIGINT_MAX","BIGINT_119","BIGINT_121","Int64","_to2sComplement","valueL","valueR","isNegative","_splitNumber","value","Math","floor","_splitBigInt","split","combine","toBigInt","PackedInteger","MAX_LENGTH","MAX_LONG_LENGTH","readSortedInt","buf","off","byteLen","negative","b1","readUInt8","readSortedLong","writeSortedInt","byte1Off","writeUInt8","valueLen","writeSortedLong","isSafeInteger","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/binary_protocol/packed_integer.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\n/**\n * NOTE: this is cut/paste/edited from JE's class of the same name. An\n * important difference is that the packed values returned are ALWAYS\n * sorted. The unsorted methods supported by JE for compatibility are not\n * included.\n *\n * Static methods for reading and writing packed integers.\n */\n\nconst assert = require('assert');\nconst isInt32 = require('../utils').isInt32;\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\n\n//Avoid ReferenceError(s) below in case bigint is not supported.\nconst BigIntCons = typeof BigInt === 'function' ? BigInt : Number;\n\n//We are not using bigint literals to avoid syntax errors if bigint is not\n//supported.\nconst INT32_MIN = -2147483648; // -2^31\nconst INT32_MAX = 2147483647; // 2^31 - 1\nconst INT32_RANGE = 0x100000000; // 2^32\nconst INT32_RANGE_BIGINT = BigIntCons(0x100000000); // 2^32n\nconst INT64_BIGINT_MIN = BigIntCons('-9223372036854775808'); // -2^63\nconst INT64_BIGINT_MAX = BigIntCons('9223372036854775807'); // 2^63 - 1\n\n//Saving these instead of instantiating every time does improve performance\n//according to benchmark.\nconst BIGINT_119 = BigIntCons(119);\nconst BIGINT_121 = BigIntCons(121);\n\n/**\n * In JavaScript, number can represent integer up to 53 bits long (not\n * including the sign).  These numbers are called safe integers since they\n * can be represented without loss of precision.  The number is in double\n * precision format and thus cannot directly serialize to 2-complement\n * integer or long format.  Bitwise operations on number will treat it as\n * signed 32-bit integer and thus it would be truncated accordingly.\n * The functions below allow to split safe integer into 2 numbers, each of\n * which is a signed 32-bit integer such that if each of these integers is\n * represented in 2-complement format, their combined (appended)\n * representation would be that of a 2-complement format of 64-bit signed\n * long integer representing original number.  This will allow us to\n * perform bitwise operations on the number as if it was 64-bit signed long\n * integer, by performing these operations on each of 2 constituent parts.\n * The results can be combined to represent resulting long integer as number\n * (as long as it is within the safe integer range).\n */\nclass Int64 {\n\n    static _to2sComplement(valueL, valueR, isNegative) {\n        if (!isNegative) {\n            assert(isInt32(valueL));\n            valueR = ~~valueR;\n        } else {\n            valueL = ~valueL;\n            valueR = ~valueR + 1;\n            if (valueR === 0) {\n                //if ~valueR was -1 we have to carry 1 to the left side\n                valueL++;\n            }\n        }\n        return { valueL, valueR };\n    }\n\n    static _splitNumber(value) {\n        const isNegative = value < 0;\n        if (isInt32(value)) {\n            return {\n                valueL: isNegative ? -1 : 0,\n                valueR: value\n            };\n        }\n\n        if (isNegative) {\n            value = -value;\n        }\n\n        const valueL = Math.floor(value / INT32_RANGE);\n        const valueR = value % INT32_RANGE;\n\n        return Int64._to2sComplement(valueL, valueR, isNegative);\n    }\n\n    static _splitBigInt(value) {\n        const isNegative = value < 0;\n        if (value >= INT32_MIN && value <= INT32_MAX) {\n            return {\n                valueL: isNegative ? -1 : 0,\n                valueR: Number(value)\n            };\n        }\n\n        if (isNegative) {\n            value = -value;\n        }\n\n        const valueL = Number(value / INT32_RANGE_BIGINT);\n        const valueR = Number(value % INT32_RANGE_BIGINT);\n\n        return Int64._to2sComplement(valueL, valueR, isNegative);\n    }\n\n    static split(value) {\n        return typeof value === 'bigint' ?\n            Int64._splitBigInt(value) : Int64._splitNumber(value);\n    }\n\n    static combine(valueL, valueR, toBigInt = false) {\n        assert(isInt32(valueL));\n        assert(isInt32(valueR));\n\n        if (valueL < 0) { //negative\n            valueL++;\n            if (valueR > 0) {\n                valueR -= INT32_RANGE;\n            }\n        } else if (valueR < 0) { //positive, adjust valueR to unsigned\n            valueR += INT32_RANGE;\n        }\n\n        return toBigInt ?\n            BigIntCons(valueL) * INT32_RANGE_BIGINT + BigIntCons(valueR) :\n            valueL * INT32_RANGE + valueR;\n    }\n}\n\nclass PackedInteger {\n\n    /**\n     * The maximum number of bytes needed to store an int value (5).\n     */\n    static get MAX_LENGTH() { return 5; }\n\n    /**\n     * The maximum number of bytes needed to store a long value (9).\n     */\n    static get MAX_LONG_LENGTH() { return 9; }\n\n    /**\n     * Reads a sorted packed integer at the given buffer offset and returns it.\n     *\n     * @param buf the buffer to read from.\n     *\n     * @param off the offset in the buffer at which to start reading.\n     *\n     * @return the integer that was read.\n     */\n    static readSortedInt(buf, off) {\n\n        let byteLen;\n        let negative;\n\n        /* The first byte of the buf stores the length of the value part. */\n        let b1 = buf.readUInt8(off++);\n        /* Adjust the byteLen to the real length of the value part. */\n        if (b1 < 0x08) {\n            byteLen = 0x08 - b1;\n            negative = true;\n        } else if (b1 > 0xf7) {\n            byteLen = b1 - 0xf7;\n            negative = false;\n        } else {\n            return { value: b1 - 127, off };\n        }\n\n        /*\n        * The following bytes on the buf store the value as a big endian\n        * integer. We extract the significant bytes from the buf and put them\n        * into the value in big endian order.\n        *\n        * Note that unlike in Java, we don't need to do (buf[off++] & 0xff)\n        * if we read the byte as unsigned 8-bit integer.\n        */\n        let value;\n        if (negative) {\n            value = -1;\n        } else {\n            value = 0;\n        }\n        if (byteLen > 3) {\n            value = (value << 8) | buf.readUInt8(off++);\n        }\n        if (byteLen > 2) {\n            value = (value << 8) | buf.readUInt8(off++);\n        }\n        if (byteLen > 1) {\n            value = (value << 8) | buf.readUInt8(off++);\n        }\n        value = (value << 8) | buf.readUInt8(off++);\n\n        /*\n            * After get the adjusted value, we have to adjust it back to the\n            * original value.\n            */\n        if (negative) {\n            value -= 119;\n        } else {\n            value += 121;\n        }\n        return { value, off };\n    }\n\n    /**\n     * Reads a sorted packed long at the given buffer offset and\n     * returns it.  The long should be max of 53 bits (not including sign),\n     * which is max allowed by JavaScript Number type.\n     *\n     * @param buf the buffer to read from.\n     *\n     * @param off the offset in the buffer at which to start reading.\n     *\n     * @return tuple containing the resulting value and resulting offset\n     */\n    static readSortedLong(buf, off, toBigInt = false) {\n\n        let byteLen;\n        let negative;\n\n        /* The first byte of the buf stores the length of the value part. */\n        let b1 = buf.readUInt8(off++);\n        /* Adjust the byteLen to the real length of the value part. */\n        if (b1 < 0x08) {\n            byteLen = 0x08 - b1;\n            negative = true;\n        } else if (b1 > 0xf7) {\n            byteLen = b1 - 0xf7;\n            negative = false;\n        } else {\n            return {\n                value: toBigInt ? BigIntCons(b1 - 127) : b1 - 127,\n                off\n            };\n        }\n\n        /*\n        * The following bytes on the buf store the value as a big endian\n        * integer. We extract the significant bytes from the buf and put them\n        * into the value in big endian order.\n        *\n        * Note that unlike in Java, we don't need to do (buf[off++] & 0xff)\n        * if we read the byte as unsigned 8-bit integer.\n        */\n        let valueL, valueR;\n        if (negative) {\n            valueL = -1;\n            valueR = -1;\n        } else {\n            valueL = 0;\n            valueR = 0;\n        }\n\n        //64 bit int overflow will be detected in Int64.combine()\n        if (byteLen > 7) {\n            valueL = (valueL << 8) | buf.readUInt8(off++);\n        }\n        if (byteLen > 6) {\n            valueL = (valueL << 8) | buf.readUInt8(off++);\n        }\n        if (byteLen > 5) {\n            valueL = (valueL << 8) | buf.readUInt8(off++);\n        }\n        if (byteLen > 4) {\n            valueL = (valueL << 8) | buf.readUInt8(off++);\n        }\n        if (byteLen > 3) {\n            valueR = (valueR << 8) | buf.readUInt8(off++);\n        }\n        if (byteLen > 2) {\n            valueR = (valueR << 8) | buf.readUInt8(off++);\n        }\n        if (byteLen > 1) {\n            valueR = (valueR << 8) | buf.readUInt8(off++);\n        }\n        valueR = (valueR << 8) | buf.readUInt8(off++);\n\n        let value = Int64.combine(valueL, valueR, toBigInt);\n\n        /*\n        * After obtaining the adjusted value, we have to adjust it back to the\n        * original value.\n        */\n        if (negative) {\n            value -= toBigInt ? BIGINT_119 : 119;\n        } else {\n            value += toBigInt ? BIGINT_121 : 121;\n        }\n        return { value, off };\n    }\n\n    /**\n     * In the functions below we assume that Buffer has enough space for\n     * the result.\n     */\n\n    /**\n     * Writes a packed sorted integer starting at the given buffer offset and\n     * returns the next offset to be written.\n     *\n     * @param buf the buffer to write to.\n     *\n     * @param off the offset in the buffer at which to start writing.\n     *\n     * @param value the integer to be written.\n     *\n     * @return the offset past the bytes written.\n     */\n    static writeSortedInt(buf, off, value) {\n\n        if (!isInt32(value)) {\n            throw new NoSQLArgumentError(\n                `Value ${value} out of range for type INTEGER`);\n        }\n\n        /*\n        * Values in the inclusive range [-119,120] are stored in a single\n        * byte. For values outside that range, the first byte stores the\n        * number of additional bytes. The additional bytes store\n        * (value + 119 for negative and value - 121 for positive) as an\n        * unsigned big endian integer.\n        */\n        const byte1Off = off++;\n\n        if (value < -119) {\n\n            /*\n            * If the value < -119, then first adjust the value by adding 119.\n            * Then the adjusted value is stored as an unsigned big endian\n            * integer.\n            */\n            value += 119;\n\n            /*\n            * Store the adjusted value as an unsigned big endian integer.\n            * For an negative integer, from left to right, the first\n            * significant byte is the byte which is not equal to 0xFF. Also\n            * please note that, because the adjusted value is stored in big\n            * endian integer, we extract the significant byte from left to\n            * right.\n            *\n            * In the left to right order, if the first byte of the adjusted\n            * value is a significant byte, it will be stored in the 2nd byte\n            * of the buf. Then we will look at the 2nd byte of the adjusted\n            * value to see if this byte is the significant byte, if yes, this\n            * byte will be stored in the 3rd byte of the buf, and the like.\n            *\n            * It seems that Buffer converts number to byte automatically, but\n            * I haven't seen this stated explicitly in the doc, so adding\n            * (& 0xFF) just in case.\n            */\n            if ((value | 0x00FFFFFF) != -1) {\n                buf.writeUInt8((value >> 24) & 0xFF, off++);\n            }\n            if ((value | 0x0000FFFF) != -1) {\n                buf.writeUInt8((value >> 16) & 0xFF, off++);\n            }\n            if ((value | 0x000000FF) != -1) {\n                buf.writeUInt8((value >> 8) & 0xFF, off++);\n            }\n            buf.writeUInt8(value & 0xFF, off++);\n\n            /*\n            * valueLen is the length of the value part stored in buf. Because\n            * the first byte of buf is used to stored the length, we need\n            * to subtract one.\n            */\n            const valueLen = off - byte1Off - 1;\n\n            /*\n            * The first byte stores the number of additional bytes. Here we\n            * store the result of 0x08 - valueLen, rather than directly store\n            * valueLen. The reason is to implement natural sort order for\n            * byte-by-byte comparison.\n            */\n            buf.writeUInt8(0x08 - valueLen, byte1Off);\n        } else if (value > 120) {\n\n            /*\n            * If the value > 120, then first adjust the value by subtracting\n            * 121. Then the adjusted value is stored as an unsigned big endian\n            * integer.\n            */\n            value -= 121;\n\n            /*\n            * Store the adjusted value as an unsigned big endian integer.\n            * For a positive integer, from left to right, the first\n            * significant byte is the byte which is not equal to 0x00.\n            *\n            * In the left to right order, if the first byte of the adjusted\n            * value is a significant byte, it will be stored in the 2nd byte\n            * of the buf. Then we will look at the 2nd byte of the adjusted\n            * value to see if this byte is the significant byte, if yes, this\n            * byte will be stored in the 3rd byte of the buf, and the like.\n            */\n            if ((value & 0xFF000000) != 0) {\n                buf.writeUInt8((value >> 24) & 0xFF, off++);\n            }\n            if ((value & 0xFFFF0000) != 0) {\n                buf.writeUInt8((value >> 16) & 0xFF, off++);\n            }\n            if ((value & 0xFFFFFF00) != 0) {\n                buf.writeUInt8((value >> 8) & 0xFF, off++);\n            }\n            buf.writeUInt8(value & 0xFF, off++);\n\n            /*\n            * valueLen is the length of the value part stored in buf. Because\n            * the first byte of buf is used to stored the length, we need to\n            * subtract one.\n            */\n            const valueLen = off - byte1Off - 1;\n\n            /*\n            * The first byte stores the number of additional bytes. Here we\n            * store the result of 0xF7 + valueLen, rather than directly store\n            * valueLen. The reason is to implement natural sort order for\n            * byte-by-byte comparison.\n            */\n            buf.writeUInt8(0xF7 + valueLen, byte1Off);\n        } else {\n\n            /*\n            * If -119 <= value <= 120, only one byte is needed to store the\n            * value. The stored value is the original value plus 127.\n            */\n            buf.writeUInt8(value + 127, byte1Off);\n        }\n\n        return off;\n    }\n\n    /**\n     * Writes a packed sorted long integer starting at the given buffer offset\n     * and returns the next offset to be written.\n     *\n     * @param buf the buffer to write to.\n     *\n     * @param off the offset in the buffer at which to start writing.\n     *\n     * @param value the long integer to be written.\n     *\n     * @return the offset past the bytes written.\n     */\n    static writeSortedLong(buf, off, value) {\n        if (typeof value === 'number') {\n            //See Protocol.writeFieldValue().\n            assert(Number.isSafeInteger(value));\n        } else {\n            assert(typeof value === 'bigint');\n            if (value < INT64_BIGINT_MIN || value > INT64_BIGINT_MAX) {\n                throw new NoSQLArgumentError(\n                    `Value ${value} out of range for type LONG`);\n            }\n        }\n\n        /*\n        * Values in the inclusive range [-119,120] are stored in a single\n        * byte. For values outside that range, the first byte stores the\n        * number of additional bytes. The additional bytes store\n        * (value + 119 for negative and value - 121 for positive) as an\n        * unsigned big endian integer.\n        */\n        const byte1Off = off++;\n\n        if (value < -119) {\n\n            /*\n            * If the value < -119, then first adjust the value by adding 119.\n            * Then the adjusted value is stored as an unsigned big endian\n            * integer.\n            */\n            value += typeof value === 'bigint' ? BIGINT_119 : 119;\n\n            const { valueL, valueR } = Int64.split(value);\n\n            /*\n            * Store the adjusted value as an unsigned big endian integer.\n            * For an negative integer, from left to right, the first\n            * significant byte is the byte which is not equal to 0xFF. Also\n            * please note that, because the adjusted value is stored in big\n            * endian integer, we extract the significant byte from left to\n            * right.\n            *\n            * In the left to right order, if the first byte of the adjusted\n            * value is a significant byte, it will be stored in the 2nd byte\n            * of the buf. Then we will look at the 2nd byte of the adjusted\n            * value to see if this byte is the significant byte, if yes, this\n            * byte will be stored in the 3rd byte of the buf, and the like.\n            *\n            * It seems that Buffer converts number to byte automatically, but\n            * I haven't seen this stated explicitly in the doc, so adding\n            * (& 0xFF) just in case.\n            */\n            if ((valueL | 0x00FFFFFF) != -1) {\n                buf.writeUInt8((valueL >> 24) & 0xFF, off++);\n            }\n            if ((valueL | 0x0000FFFF) != -1) {\n                buf.writeUInt8((valueL >> 16) & 0xFF, off++);\n            }\n            if ((valueL | 0x000000FF) != -1) {\n                buf.writeUInt8((valueL >> 8) & 0xFF, off++);\n            }\n            if (valueL != -1) {\n                buf.writeUInt8(valueL & 0xFF, off++);\n            }\n            if (valueL != -1 || (valueR | 0x00FFFFFF) != -1) {\n                buf.writeUInt8((valueR >> 24) & 0xFF, off++);\n            }\n            if (valueL != -1 || (valueR | 0x0000FFFF) != -1) {\n                buf.writeUInt8((valueR >> 16) & 0xFF, off++);\n            }\n            if (valueL != -1 || (valueR | 0x000000FF) != -1) {\n                buf.writeUInt8((valueR >> 8) & 0xFF, off++);\n            }\n            buf.writeUInt8(valueR & 0xFF, off++);\n\n            /*\n            * valueLen is the length of the value part stored in buf. Because\n            * the first byte of buf is used to stored the length, so we need\n            * to minus one.\n            */\n            const valueLen = off - byte1Off - 1;\n\n            /*\n            * The first byte stores the number of additional bytes. Here we\n            * store the result of 0x08 - valueLen, rather than directly store\n            * valueLen. The reason is to implement nature sort order for\n            * byte-by-byte comparison.\n            */\n            buf.writeUInt8(0x08 - valueLen, byte1Off);\n        } else if (value > 120) {\n\n            /*\n            * If the value > 120, then first adjust the value by subtracting\n            * 119. Then the adjusted value is stored as an unsigned big endian\n            * integer.\n            */\n            value -= typeof value === 'bigint' ? BIGINT_121 : 121;\n\n            const { valueL, valueR } = Int64.split(value);\n\n            /*\n            * Store the adjusted value as an unsigned big endian integer.\n            * For a positive integer, from left to right, the first\n            * significant byte is the byte which is not equal to 0x00.\n            *\n            * In the left to right order, if the first byte of the adjusted\n            * value is a significant byte, it will be stored in the 2nd byte\n            * of the buf. Then we will look at the 2nd byte of the adjusted\n            * value to see if this byte is the significant byte, if yes, this\n            * byte will be stored in the 3rd byte of the buf, and the like.\n            */\n            if ((valueL & 0xFF000000) != 0) {\n                buf.writeUInt8((valueL >> 24) & 0xFF, off++);\n            }\n            if ((valueL & 0xFFFF0000) != 0) {\n                buf.writeUInt8((valueL >> 16) & 0xFF, off++);\n            }\n            if ((valueL & 0xFFFFFF00) != 0) {\n                buf.writeUInt8((valueL >> 8) & 0xFF, off++);\n            }\n            if (valueL != 0) {\n                buf.writeUInt8(valueL & 0xFF, off++);\n            }\n            if (valueL || (valueR & 0xFF000000) != 0) {\n                buf.writeUInt8((valueR >> 24) & 0xFF, off++);\n            }\n            if (valueL || (valueR & 0xFFFF0000) != 0) {\n                buf.writeUInt8((valueR >> 16) & 0xFF, off++);\n            }\n            if (valueL || (valueR & 0xFFFFFF00) != 0) {\n                buf.writeUInt8((valueR >> 8) & 0xFF, off++);\n            }\n            buf.writeUInt8(valueR & 0xFF, off++);\n\n            const valueLen = off - byte1Off - 1;\n\n            /*\n            * The first byte stores the number of additional bytes. Here we\n            * store the result of 0xF7 + valueLen, rather than directly store\n            * valueLen. The reason is to implement nature sort order for\n            * byte-by-byte comparison.\n            */\n            buf.writeUInt8(0xF7 + valueLen, byte1Off);\n        } else {\n\n            /*\n            * If -119 <= value <= 120, only one byte is needed to store the\n            * value. The stored value is the original value adds 127.\n            */\n            buf.writeUInt8(Number(value) + 127, byte1Off);\n        }\n        return off;\n    }\n\n}\n\nmodule.exports = PackedInteger;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}