{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst isPosInt = require('./utils').isPosInt;\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\n\n/**\n * Defines classes related to SQL statement and query execution such as\n * {@link PreparedStatement}.\n */\n\n/**\n * @classdesc  A class encapsulating a prepared query statement. It includes\n * state that can be sent to a server and executed without re-parsing the\n * query. It includes bind variables which may be set for each successive use\n * of the query.  PreparedStatement object is returned as a result of\n * {@link NoSQLClient#prepare} method.  It can be passed to\n * {@link NoSQLClient#query} and {@link NoSQLClient#queryIterable} methods for\n * execution and be reused for multiple queries, potentially with different\n * values of bind variables.\n * <p>\n * You may share an instance of {@link PreparedStatements} by queries running\n * async-concurrently, e.g. queries invoked concurrently by different async\n * functions.  This is referred to as async-safety:\n * <br>\n * An instance of {@link PreparedStatement} is async-safe if bind variables\n * are not used.  If bind variables are used, it is not async-safe.  In this\n * case, you can construct additional instances of {@link PreparedStatement}\n * using {@link PreparedStatement#copyStatement} method in order to share it\n * among async-concurrent queries.\n * @extends {PrepareResult}\n * @hideconstructor\n */\nclass PreparedStatement {\n  /**\n   * Sets and gets the bindings object explicitly.  Bindings object is an\n   * object which properties contain the bind variables for this prepared\n   * statement.  For each variable, binding object has property which name\n   * is the variable name and the value is the variable value.  Note that\n   * \"$\" in the variable name is included in its property name.  For\n   * positional variables, the names are determined by the query engine.\n   * @type {object}\n   * @example //Setting bindings\n   * prepStmt.bindings = {\n   *     $id: 100,\n   *     $name: 'John'\n   * };\n   * //This is equivalent to:\n   * prepStmt.set('$id', 100);\n   * prepStmt.set('$name', 'John');\n   */\n  set bindings(value) {\n    this._bindings = value;\n  }\n  get bindings() {\n    return this._bindings;\n  }\n\n  /**\n   * Binds a variable to use for the query.  The variable can be identified\n   * either by its name or its position.\n   * <p>\n   * To bind by name, pass a name of the variable as it was declared in\n   * <em>DECLARE</em> statement of the query.\n   * <p>\n   * You can also bind a variable by its position within the query string.\n   * The positions start at 1. The variable that appears first in the query\n   * text has position 1, the variable that appears second has position 2\n   * and so on.  Binding by position is useful for queries where bind\n   * variables identified by \"?\" are used instead of named variables (but it\n   * can be used for both types of variables).\n   * <p>\n   * Existing variables with the same name or position are silently\n   * overwritten. The names, positions and types are validated when the\n   * query is executed.\n   * \n   * @example // Using PreparedStatement, binding variables by name.\n   * let client = new NoSQLClient(//.....\n   * let prepStmt = await client.prepare(\n   *     'DECLARE $id INTEGER; $sal DOUBLE;  SELECT id, firstName, lastName ' +\n   *     'FROM Emp WHERE id <= $id AND salary <= $sal');\n   * ps.set('$id', 1100);\n   *   .set('$sal', 100500);\n   * for await(const res of client.queryIterable(stmt)) {\n   * //.....\n   * }\n   * ps.set('$id', 2000);\n   * for await(const res of client.queryIterable(stmt)) {\n   * //.....\n   * }\n   * //.....\n   * @example // Binding variables by position.\n   * let prepStmt = await client.prepare(\n   *     'SELECT id, firstName, lastName FROM Emp WHERE ' + \n   *     'id <= ? AND salary <= ?');\n   * ps.set(1, 1100)\n   *   .set(2, 100500);\n   * //.....\n   * @param {string|number} nameOrPosition Name or position of the variable\n   * @param {FieldValue} val Value of the variable of the appropriate type\n   * @returns {PreparedStatement} This instance for chaining\n   * @throws {NoSQLArgumentError} If binding by position and the position is\n   * invalid.\n   */\n  set(nameOrPosition, val) {\n    if (!this._bindings) {\n      this._bindings = {};\n    }\n    let key = nameOrPosition;\n    if (typeof key === 'number') {\n      if (!isPosInt(key)) {\n        throw new NoSQLArgumentError(\"Invalid bind variable position: \".concat(key));\n      }\n      if (this._varNames == null) {\n        key = '#' + key;\n      } else {\n        if (key > this._varNames.length) {\n          throw new NoSQLArgumentError(\"Invalid bind variable position: \".concat(key, \", exceeds total \").concat(this._varNames.length));\n        }\n        key = this._varNames[key - 1];\n      }\n    }\n    this._bindings[key] = val;\n    return this;\n  }\n\n  /**\n   * Clears all variables in bindings for this prepared statement.\n   * @returns {PreparedStatement} This instance for chaining\n   */\n  clearAll() {\n    delete this._bindings;\n    return this;\n  }\n\n  /**\n   * SQL text of this prepared statement.\n   * @type {string}\n   * @readonly\n   */\n  get sql() {\n    return this._sql;\n  }\n\n  /**\n   * Query execution plan printout if was requested by\n   * {@link NoSQLClient#prepare} (see <em>opt.getQueryPlan</em>), otherwise\n   * undefined.\n   * @type {string}\n   * @readonly\n   */\n  get queryPlan() {\n    return this._queryPlanStr;\n  }\n\n  /**\n   * JSON representation of the query result schema if was requested by\n   * {@link NoSQLClient#prepare} (see <em>opt.getResultSchema</em>),\n   * otherwise undefined.\n   * @type {string}\n   * @readonly\n   */\n  get resultSchema() {\n    return this._schema;\n  }\n\n  /**\n   * Returns a copy of this prepared statement without its variables.\n   * <p>\n   * This method returns a new instance of {@link PreparedStatement} that\n   * shares this object's prepared query, which is immutable, but does not\n   * share its variables.  Use this method when you need to execute the same\n   * prepared query async-concurrently (call this method to create a new copy\n   * for each additional concurrent query).\n   * @returns {PreparedStatement} A copy of this prepared statement without\n   * its variables\n   */\n  copyStatement() {\n    const res = Object.assign({\n      __proto__: PreparedStatement.prototype\n    }, this);\n    delete res._bindings;\n    return res;\n  }\n}\nmodule.exports = {\n  PreparedStatement\n};","map":{"version":3,"names":["isPosInt","require","NoSQLArgumentError","PreparedStatement","bindings","value","_bindings","set","nameOrPosition","val","key","concat","_varNames","length","clearAll","sql","_sql","queryPlan","_queryPlanStr","resultSchema","_schema","copyStatement","res","Object","assign","__proto__","prototype","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/stmt.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst isPosInt = require('./utils').isPosInt;\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\n\n/**\n * Defines classes related to SQL statement and query execution such as\n * {@link PreparedStatement}.\n */\n\n/**\n * @classdesc  A class encapsulating a prepared query statement. It includes\n * state that can be sent to a server and executed without re-parsing the\n * query. It includes bind variables which may be set for each successive use\n * of the query.  PreparedStatement object is returned as a result of\n * {@link NoSQLClient#prepare} method.  It can be passed to\n * {@link NoSQLClient#query} and {@link NoSQLClient#queryIterable} methods for\n * execution and be reused for multiple queries, potentially with different\n * values of bind variables.\n * <p>\n * You may share an instance of {@link PreparedStatements} by queries running\n * async-concurrently, e.g. queries invoked concurrently by different async\n * functions.  This is referred to as async-safety:\n * <br>\n * An instance of {@link PreparedStatement} is async-safe if bind variables\n * are not used.  If bind variables are used, it is not async-safe.  In this\n * case, you can construct additional instances of {@link PreparedStatement}\n * using {@link PreparedStatement#copyStatement} method in order to share it\n * among async-concurrent queries.\n * @extends {PrepareResult}\n * @hideconstructor\n */\nclass PreparedStatement {\n\n    /**\n     * Sets and gets the bindings object explicitly.  Bindings object is an\n     * object which properties contain the bind variables for this prepared\n     * statement.  For each variable, binding object has property which name\n     * is the variable name and the value is the variable value.  Note that\n     * \"$\" in the variable name is included in its property name.  For\n     * positional variables, the names are determined by the query engine.\n     * @type {object}\n     * @example //Setting bindings\n     * prepStmt.bindings = {\n     *     $id: 100,\n     *     $name: 'John'\n     * };\n     * //This is equivalent to:\n     * prepStmt.set('$id', 100);\n     * prepStmt.set('$name', 'John');\n     */\n    set bindings(value) {\n        this._bindings = value;\n    }\n\n    get bindings() {\n        return this._bindings;\n    }\n\n    /**\n     * Binds a variable to use for the query.  The variable can be identified\n     * either by its name or its position.\n     * <p>\n     * To bind by name, pass a name of the variable as it was declared in\n     * <em>DECLARE</em> statement of the query.\n     * <p>\n     * You can also bind a variable by its position within the query string.\n     * The positions start at 1. The variable that appears first in the query\n     * text has position 1, the variable that appears second has position 2\n     * and so on.  Binding by position is useful for queries where bind\n     * variables identified by \"?\" are used instead of named variables (but it\n     * can be used for both types of variables).\n     * <p>\n     * Existing variables with the same name or position are silently\n     * overwritten. The names, positions and types are validated when the\n     * query is executed.\n     * \n     * @example // Using PreparedStatement, binding variables by name.\n     * let client = new NoSQLClient(//.....\n     * let prepStmt = await client.prepare(\n     *     'DECLARE $id INTEGER; $sal DOUBLE;  SELECT id, firstName, lastName ' +\n     *     'FROM Emp WHERE id <= $id AND salary <= $sal');\n     * ps.set('$id', 1100);\n     *   .set('$sal', 100500);\n     * for await(const res of client.queryIterable(stmt)) {\n     * //.....\n     * }\n     * ps.set('$id', 2000);\n     * for await(const res of client.queryIterable(stmt)) {\n     * //.....\n     * }\n     * //.....\n     * @example // Binding variables by position.\n     * let prepStmt = await client.prepare(\n     *     'SELECT id, firstName, lastName FROM Emp WHERE ' + \n     *     'id <= ? AND salary <= ?');\n     * ps.set(1, 1100)\n     *   .set(2, 100500);\n     * //.....\n     * @param {string|number} nameOrPosition Name or position of the variable\n     * @param {FieldValue} val Value of the variable of the appropriate type\n     * @returns {PreparedStatement} This instance for chaining\n     * @throws {NoSQLArgumentError} If binding by position and the position is\n     * invalid.\n     */\n    set(nameOrPosition, val) {\n        if (!this._bindings) {\n            this._bindings = {};\n        }\n\n        let key = nameOrPosition;\n        if (typeof key === 'number') {\n            if (!isPosInt(key)) {\n                throw new NoSQLArgumentError(\n                    `Invalid bind variable position: ${key}`);\n            }\n            if (this._varNames == null) {\n                key = '#' + key;\n            } else {\n                if (key > this._varNames.length) {\n                    throw new NoSQLArgumentError(`Invalid bind variable \\\nposition: ${key}, exceeds total ${this._varNames.length}`);\n                }\n                key = this._varNames[key - 1];\n            }\n        }\n\n        this._bindings[key] = val;\n        return this;\n    }\n\n    /**\n     * Clears all variables in bindings for this prepared statement.\n     * @returns {PreparedStatement} This instance for chaining\n     */\n    clearAll() {\n        delete this._bindings;\n        return this;\n    }\n\n    /**\n     * SQL text of this prepared statement.\n     * @type {string}\n     * @readonly\n     */\n    get sql() {\n        return this._sql;\n    }\n\n    /**\n     * Query execution plan printout if was requested by\n     * {@link NoSQLClient#prepare} (see <em>opt.getQueryPlan</em>), otherwise\n     * undefined.\n     * @type {string}\n     * @readonly\n     */\n    get queryPlan() {\n        return this._queryPlanStr;\n    }\n\n    /**\n     * JSON representation of the query result schema if was requested by\n     * {@link NoSQLClient#prepare} (see <em>opt.getResultSchema</em>),\n     * otherwise undefined.\n     * @type {string}\n     * @readonly\n     */\n    get resultSchema() {\n        return this._schema;\n    }\n\n    /**\n     * Returns a copy of this prepared statement without its variables.\n     * <p>\n     * This method returns a new instance of {@link PreparedStatement} that\n     * shares this object's prepared query, which is immutable, but does not\n     * share its variables.  Use this method when you need to execute the same\n     * prepared query async-concurrently (call this method to create a new copy\n     * for each additional concurrent query).\n     * @returns {PreparedStatement} A copy of this prepared statement without\n     * its variables\n     */\n    copyStatement() {\n        const res = Object.assign({ __proto__: PreparedStatement.prototype },\n            this);\n        delete res._bindings;\n        return res;\n    }\n}\n\nmodule.exports = {\n    PreparedStatement\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,QAAQ,GAAGC,OAAO,CAAC,SAAS,CAAC,CAACD,QAAQ;AAC5C,MAAME,kBAAkB,GAAGD,OAAO,CAAC,SAAS,CAAC,CAACC,kBAAkB;;AAEhE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,CAAC;EAEpB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,QAAQA,CAACC,KAAK,EAAE;IAChB,IAAI,CAACC,SAAS,GAAGD,KAAK;EAC1B;EAEA,IAAID,QAAQA,CAAA,EAAG;IACX,OAAO,IAAI,CAACE,SAAS;EACzB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,GAAGA,CAACC,cAAc,EAAEC,GAAG,EAAE;IACrB,IAAI,CAAC,IAAI,CAACH,SAAS,EAAE;MACjB,IAAI,CAACA,SAAS,GAAG,CAAC,CAAC;IACvB;IAEA,IAAII,GAAG,GAAGF,cAAc;IACxB,IAAI,OAAOE,GAAG,KAAK,QAAQ,EAAE;MACzB,IAAI,CAACV,QAAQ,CAACU,GAAG,CAAC,EAAE;QAChB,MAAM,IAAIR,kBAAkB,oCAAAS,MAAA,CACWD,GAAG,CAAE,CAAC;MACjD;MACA,IAAI,IAAI,CAACE,SAAS,IAAI,IAAI,EAAE;QACxBF,GAAG,GAAG,GAAG,GAAGA,GAAG;MACnB,CAAC,MAAM;QACH,IAAIA,GAAG,GAAG,IAAI,CAACE,SAAS,CAACC,MAAM,EAAE;UAC7B,MAAM,IAAIX,kBAAkB,oCAAAS,MAAA,CACpCD,GAAG,sBAAAC,MAAA,CAAmB,IAAI,CAACC,SAAS,CAACC,MAAM,CAAE,CAAC;QAC1C;QACAH,GAAG,GAAG,IAAI,CAACE,SAAS,CAACF,GAAG,GAAG,CAAC,CAAC;MACjC;IACJ;IAEA,IAAI,CAACJ,SAAS,CAACI,GAAG,CAAC,GAAGD,GAAG;IACzB,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;AACA;EACIK,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACR,SAAS;IACrB,OAAO,IAAI;EACf;;EAEA;AACJ;AACA;AACA;AACA;EACI,IAAIS,GAAGA,CAAA,EAAG;IACN,OAAO,IAAI,CAACC,IAAI;EACpB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,aAAa;EAC7B;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,YAAYA,CAAA,EAAG;IACf,OAAO,IAAI,CAACC,OAAO;EACvB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,aAAaA,CAAA,EAAG;IACZ,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAM,CAAC;MAAEC,SAAS,EAAEtB,iBAAiB,CAACuB;IAAU,CAAC,EAChE,IAAI,CAAC;IACT,OAAOJ,GAAG,CAAChB,SAAS;IACpB,OAAOgB,GAAG;EACd;AACJ;AAEAK,MAAM,CAACC,OAAO,GAAG;EACbzB;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}