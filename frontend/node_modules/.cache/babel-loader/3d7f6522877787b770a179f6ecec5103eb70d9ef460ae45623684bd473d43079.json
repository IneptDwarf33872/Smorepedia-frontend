{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst assert = require('assert');\nconst HttpClient = require('./http_client');\nconst ops = require('./ops');\nconst TableState = require('./constants').TableState;\nconst AdminState = require('./constants').AdminState;\nconst ServiceType = require('./constants').ServiceType;\nconst ErrorCode = require('./error_code');\nconst NoSQLTimeoutError = require('./error').NoSQLTimeoutError;\nconst NoSQLProtocolError = require('./error').NoSQLProtocolError;\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst Config = require('./config');\nconst sleep = require('./utils').sleep;\nconst replaceObject = require('./utils').replaceObject;\nconst PreparedStatement = require('./stmt').PreparedStatement;\nconst QueryPlanExecutor = require('./query/common').QueryPlanExecutor;\nconst NoSQLError = require('./error').NoSQLError;\n\n//Default timeout for admin list operations such as listNamespaces, listUsers,\n//listRoles.\nconst DEF_ADMIN_LIST_TIMEOUT = 30000;\n\n//Default limit for table usage iterable. The value is set to 24 hours of\n//1-minute usage records.\nconst DEF_TABLE_USAGE_LIMIT = 1440;\nclass NoSQLClientImpl extends EventEmitter {\n  constructor(config) {\n    super();\n    this._config = Config.create(config);\n    this._client = new HttpClient(this._config);\n    //Forward all events from the _client.\n    this.on('newListener', (event, listener) => {\n      this._client.on(event, listener);\n    });\n    this.on('removeListener', (event, listener) => {\n      this._client.removeListener(event, listener);\n    });\n    //To prevent throwing if no error events are registered.\n    //We should log the error in this listener.\n    this.on('error', () => {});\n  }\n  _assignOpt(opt, addOpt) {\n    if (opt == null) {\n      return addOpt;\n    }\n    //We don't throw here because we want the error to be handled\n    //asynchronously.  If a user passes invalid opt which is not\n    //an object, we just return it and pass it to asynchronous code\n    //for validation.\n    if (typeof opt !== 'object') {\n      return opt;\n    }\n    return Object.assign({}, opt, addOpt);\n  }\n\n  //Used by _forTableState, _forLocalReplicaInit and _forAdminCompletion.\n  _doPollOpDelay(req, poReq, startTime) {\n    if (req.opt.timeout !== Infinity) {\n      const remaining = startTime + req.opt.timeout - (Date.now() + req.opt.delay);\n      //Fail if we are less than opt.delay ahead of timing out.\n      if (remaining <= 0) {\n        throw new NoSQLTimeoutError(req.opt.timeout, null, req);\n      }\n      //Make sure timeout of poll op request (poReq) does not go past\n      //total poll timeout.\n      if (poReq.opt.timeout > remaining) {\n        poReq.opt.timeout = remaining;\n      }\n    }\n    return sleep(req.opt.delay);\n  }\n  async _forTableState(table, tableState, opt, skipInit) {\n    const req = {\n      api: typeof table === 'string' ? this.forTableState : this.forCompletion,\n      table,\n      tableState,\n      opt\n    };\n\n    //If called from _withCompletion, the work below was already done on\n    //the original request.  In addition this check avoids throwing wrong\n    //error if remaining timeout < pollDelay.  Same applies to\n    //_forAdminCompletion().\n    if (!skipInit) {\n      ops.PollTableStateOp.applyDefaults(req, this._config);\n      ops.PollTableStateOp.validate(req);\n    }\n\n    // Should be set by PollTableStateOp.applyDefaults() above or from\n    // _withCompletion().\n    assert(req.opt != null);\n\n    //For forCompletion(), when table is TableResult, return if already\n    //reached desired state.\n    if (req.api === this.forCompletion && table.tableState === tableState) {\n      return table;\n    }\n\n    //Request for GetTableOp.\n    const gtReq = {\n      api: req.api,\n      table,\n      opt: {\n        compartment: req.opt.compartment,\n        timeout: Math.min(this._config.timeout, req.opt.timeout)\n      }\n    };\n    const startTime = Date.now();\n    for (;;) {\n      try {\n        const res = await this._execute(ops.GetTableOp, gtReq);\n        if (res.tableState === req.tableState) {\n          return res;\n        }\n      } catch (err) {\n        if (err.errorCode === ErrorCode.TABLE_NOT_FOUND && req.tableState === TableState.DROPPED) {\n          const res = {\n            tableName: gtReq.tableName,\n            tableState: TableState.DROPPED\n          };\n          //In this case onResult was not called by _execute above.\n          ops.PollTableStateOp.onResult(this, req, res);\n          return res;\n        }\n        throw err;\n      }\n      await this._doPollOpDelay(req, gtReq, startTime);\n    }\n  }\n  async _forLocalReplicaInit(table, opt) {\n    const req = {\n      api: this.forLocalReplicaInit,\n      table,\n      opt\n    };\n    if (this._config.serviceType !== ServiceType.CLOUD) {\n      throw NoSQLError.create(ErrorCode.OPERATION_NOT_SUPPORTED, `forLocalReplicaInit is not supported for service type \\\n${this._config.serviceType} (requires Cloud Service)`, null, req);\n    }\n    ops.PollTableOp.applyDefaults(req, this._config);\n    ops.PollTableOp.validate(req);\n    assert(req.opt != null);\n\n    //Request for GetTableOp.\n    const gtReq = {\n      api: req.api,\n      table,\n      opt: {\n        compartment: req.opt.compartment,\n        timeout: Math.min(this._config.timeout, req.opt.timeout)\n      }\n    };\n    const startTime = Date.now();\n    for (;;) {\n      const res = await this._execute(ops.GetTableOp, gtReq);\n      if (res.isLocalReplicaInitialized) {\n        return res;\n      }\n      await this._doPollOpDelay(req, gtReq, startTime);\n    }\n  }\n  async *_tableUsageIterable(tableName, opt) {\n    if (opt == null) {\n      opt = {};\n    } else if (typeof opt === 'object') {\n      opt = Object.assign({}, opt);\n      opt.startIndex = undefined;\n    }\n    if (opt.limit == null) {\n      opt.limit = DEF_TABLE_USAGE_LIMIT;\n    }\n    let res;\n    do {\n      res = await this.getTableUsage(tableName, opt);\n      if (!res.usageRecords.length) {\n        break;\n      }\n      opt.startIndex = res.nextIndex;\n      yield res;\n    } while (res.usageRecords.length === opt.limit);\n  }\n  async _getIndex(tableName, indexName, opt) {\n    const req = {\n      api: this.getIndex,\n      tableName,\n      opt\n    };\n    req.opt = this._assignOpt(opt, {\n      indexName\n    });\n    const res = await this._client.execute(ops.GetIndexesOp, req);\n    if (res.length != 1) {\n      throw new NoSQLProtocolError(`Unexpected number of index results: ${res.length}`, null, req);\n    }\n    return res[0];\n  }\n\n  //Note: This function is only used if opt.all is set to true and is not\n  //fully implemented yet to account for throttling errors.  Reserved for\n  //future use.\n  async _deleteRangeAll(tableName, key, opt) {\n    const req = {\n      api: this.deleteRange,\n      tableName,\n      key,\n      opt\n    };\n    //Accumulate deletedCount and consumedCapacity\n    const total = {\n      deletedCount: 0,\n      consumedCapacity: this._config.serviceType !== ServiceType.KVSTORE ? {\n        readKB: 0,\n        readUnits: 0,\n        writeKB: 0,\n        writeUnits: 0\n      } : null\n    };\n    for (;;) {\n      const res = await this._client.execute(ops.MultiDeleteOp, req);\n      assert(res.deletedCount != null);\n      assert(res.consumedCapacity != null || total.consumedCapacity == null);\n      total.deletedCount += res.deletedCount;\n      if (total.consumedCapacity) {\n        for (let key in total.consumedCapacity) {\n          total.consumedCapacity[key] += res.consumedCapacity[key];\n        }\n      }\n      if (!res.continuationKey) {\n        res.deletedCount = total.deletedCount;\n        if (total.consumedCapacity) {\n          Object.assign(res.consumedCapacity, total.consumedCapacity);\n        }\n        return res;\n      }\n      opt.continuationKey = res.continuationKey;\n    }\n  }\n  async _prepare(stmt, opt) {\n    const res = await this._client.execute(ops.PrepareOp, {\n      api: this.prepare,\n      stmt,\n      opt\n    });\n    res.__proto__ = PreparedStatement.prototype;\n    return res;\n  }\n  async _query(stmt, opt) {\n    const req = {\n      api: this.query,\n      opt\n    };\n    let ck = opt ? opt.continuationKey : null;\n    if (ck && ck._prepStmt) {\n      req.prepStmt = ck._prepStmt;\n    } else if (typeof stmt !== 'string') {\n      req.prepStmt = stmt;\n    } else {\n      req.stmt = stmt;\n    }\n    if (!req.prepStmt) {\n      const res = await this._client.execute(ops.QueryOp, req);\n      //We always read the prepared statement if the request does not\n      //have it.\n      assert(res._prepStmt);\n      //Simple query may already have results, so we just return them.\n      if (!res._prepStmt._queryPlan) {\n        return res;\n      }\n\n      //Advanced query will have no results in this case, only the\n      //prepared statement. To make it more intuitive for the user, we\n      //execute the first prepared query call.\n      req.prepStmt = res._prepStmt;\n      req.stmt = undefined;\n      ck = res.continuationKey;\n      assert(ck); //see QueryOp.onResult()\n      assert(req.opt); //see Op.applyDefaults()\n      req.opt.continuationKey = ck;\n    }\n\n    //Advanced query.\n    if (req.prepStmt._queryPlan) {\n      let qpExec = ck ? ck._qpExec : null;\n      if (!qpExec) {\n        //First advanced query call, create plan executor.\n        qpExec = new QueryPlanExecutor(this, req.prepStmt);\n      }\n      return qpExec.execute(req);\n    }\n\n    //Simple query.\n    return this._client.execute(ops.QueryOp, req);\n  }\n  async *_queryIterable(stmt, opt) {\n    if (opt == null) {\n      opt = {};\n    } else if (typeof opt === 'object') {\n      opt = Object.assign({}, opt);\n      opt.continuationKey = undefined;\n    }\n    do {\n      const res = await this.query(stmt, opt);\n      opt.continuationKey = res.continuationKey;\n      yield res;\n    } while (opt.continuationKey);\n  }\n  _execute(op, req) {\n    return this._client.execute(op, req);\n  }\n  async _adminStatus(req) {\n    if (req.adminResult != null && req.adminResult.operationId == null) {\n      //still validate options passed for correctness\n      ops.AdminStatusOp.applyDefaults(req, this._config);\n      ops.AdminStatusOp.validate(req);\n      return req.adminResult;\n    }\n    return this._execute(ops.AdminStatusOp, req);\n  }\n  async _forAdminCompletion(adminResult, opt, skipInit) {\n    const req = {\n      api: this.forCompletion,\n      adminResult,\n      opt\n    };\n    if (!skipInit) {\n      ops.AdminPollOp.applyDefaults(req, this._config);\n      ops.AdminPollOp.validate(req);\n    }\n\n    // Should be set by AdminPollOp.applyDefaults() above or from\n    // _withCompletion().\n    assert(req.opt != null);\n    if (adminResult.state === AdminState.COMPLETE) {\n      return adminResult;\n    }\n\n    //Request for AdminStatusOp.\n    const asReq = {\n      api: req.api,\n      adminResult,\n      opt: {\n        timeout: Math.min(this._config.timeout, req.opt.timeout)\n      }\n    };\n    const startTime = Date.now();\n    for (;;) {\n      const res = await this._execute(ops.AdminStatusOp, asReq);\n      if (res.state === AdminState.COMPLETE) {\n        return res;\n      }\n      await this._doPollOpDelay(req, asReq, startTime);\n    }\n  }\n  async _forCompletion(res, opt, skipInit) {\n    let ret;\n    if (res == null) {\n      throw new NoSQLArgumentError('forCompletion: missing result object');\n    }\n    if (res._forAdmin) {\n      ret = await this._forAdminCompletion(res, opt, skipInit);\n    } else {\n      const isDropTable = typeof res._stmt === 'string' && res._stmt.match(/^\\s*DROP\\s+TABLE\\s+/i);\n      ret = await this._forTableState(res, isDropTable ? TableState.DROPPED : TableState.ACTIVE, opt, skipInit);\n    }\n    return replaceObject(res, ret);\n  }\n  async _withCompletion(op, req) {\n    const startTime = Date.now();\n    const res = await this._execute(op, req);\n\n    //This initialization would be done by _execute() above.\n    assert(req.opt != null && req.opt.__proto__ === this._config);\n    let timeOut = req.opt._ownsTimeout ? req.opt.timeout : this._config.tablePollTimeout;\n    if (timeOut !== Infinity) {\n      timeOut -= Date.now() - startTime;\n    }\n    req.opt.timeout = Math.max(timeOut, 1);\n    return this._forCompletion(res, req.opt, true);\n  }\n  async _adminListOp(opName, stmt, req) {\n    const listOpt = {\n      complete: true,\n      timeout: DEF_ADMIN_LIST_TIMEOUT\n    };\n    if (req.opt == null) {\n      req.opt = listOpt;\n    } else if (typeof req.opt === 'object') {\n      //if typeof opt !== 'object', it will be passed to adminDDL\n      //and throw during validation\n      req.opt = Object.assign(listOpt, req.opt);\n    }\n    let res = await this.adminDDL(stmt, req.opt);\n    if (res.output == null) {\n      throw new NoSQLProtocolError(`Missing output for ${opName}`, null, req);\n    }\n    try {\n      res = JSON.parse(res.output);\n    } catch (err) {\n      throw new NoSQLProtocolError(`Error parsing output for \\\n${opName}`, null, req);\n    }\n    if (res == null || typeof res !== 'object') {\n      throw new NoSQLProtocolError(`Invalid output for ${opName}`, null, req);\n    }\n    return res;\n  }\n  async _listNamespaces(opt) {\n    const req = {\n      //will be included in any thrown errors\n      api: this.listNamespaces,\n      opt\n    };\n    const res = await this._adminListOp('listNamespaces', 'SHOW AS JSON NAMESPACES', req);\n    if (res.namespaces == null) {\n      return [];\n    }\n    if (!Array.isArray(res.namespaces) || res.namespaces.findIndex(el => typeof el !== 'string') !== -1) {\n      throw new NoSQLProtocolError('Invalid namespaces array in \\\nthe output for listNamespaces operation', null, req);\n    }\n    return res.namespaces;\n  }\n  async _listUsers(opt) {\n    const req = {\n      //will be included in any thrown errors\n      api: this.listUsers,\n      opt\n    };\n    const res = await this._adminListOp('listUsers', 'SHOW AS JSON USERS', req);\n    if (res.users == null) {\n      return [];\n    }\n    if (!Array.isArray(res.users)) {\n      throw new NoSQLProtocolError('Invalid users array in the output \\\nfor listUsers operation', null, req);\n    }\n    return res.users.map(user => {\n      if (user == null || typeof user !== 'object' || typeof user.id !== 'string' || typeof user.name !== 'string') {\n        throw new NoSQLProtocolError('Invalid value in the users \\\narray in the output for listUsers operation', null, req);\n      }\n      return {\n        id: user.id,\n        name: user.name\n      };\n    });\n  }\n  async _listRoles(opt) {\n    const req = {\n      //will be included in any thrown errors\n      api: this.listRoles,\n      opt\n    };\n    const res = await this._adminListOp('listRoles', 'SHOW AS JSON ROLES', req);\n    if (res.roles == null) {\n      return [];\n    }\n    if (!Array.isArray(res.roles)) {\n      throw new NoSQLProtocolError('Invalid roles array in the output \\\nfor listRoles operation', null, req);\n    }\n    return res.roles.map(role => {\n      if (role == null || typeof role !== 'object' || typeof role.name !== 'string') {\n        throw new NoSQLProtocolError('Invalid value in the roles \\\narray in the output for listRoles operation', null, req);\n      }\n      return role.name;\n    });\n  }\n\n  //used for testing\n  get _serialVersion() {\n    return this._client.serialVersion;\n  }\n  close() {\n    this._client.shutdown();\n    return Promise.resolve(Config.destroy(this._config));\n  }\n  async _precacheAuth() {\n    await this._config.auth.provider.getAuthorization({\n      opt: {\n        __proto__: this._config\n      },\n      lastError: new NoSQLError(ErrorCode.INVALID_AUTHORIZATION),\n      _op: ops.GetTableOp\n    });\n    return this;\n  }\n}\nmodule.exports = NoSQLClientImpl;","map":{"version":3,"names":["EventEmitter","require","assert","HttpClient","ops","TableState","AdminState","ServiceType","ErrorCode","NoSQLTimeoutError","NoSQLProtocolError","NoSQLArgumentError","Config","sleep","replaceObject","PreparedStatement","QueryPlanExecutor","NoSQLError","DEF_ADMIN_LIST_TIMEOUT","DEF_TABLE_USAGE_LIMIT","NoSQLClientImpl","constructor","config","_config","create","_client","on","event","listener","removeListener","_assignOpt","opt","addOpt","Object","assign","_doPollOpDelay","req","poReq","startTime","timeout","Infinity","remaining","Date","now","delay","_forTableState","table","tableState","skipInit","api","forTableState","forCompletion","PollTableStateOp","applyDefaults","validate","gtReq","compartment","Math","min","res","_execute","GetTableOp","err","errorCode","TABLE_NOT_FOUND","DROPPED","tableName","onResult","_forLocalReplicaInit","forLocalReplicaInit","serviceType","CLOUD","OPERATION_NOT_SUPPORTED","PollTableOp","isLocalReplicaInitialized","_tableUsageIterable","startIndex","undefined","limit","getTableUsage","usageRecords","length","nextIndex","_getIndex","indexName","getIndex","execute","GetIndexesOp","_deleteRangeAll","key","deleteRange","total","deletedCount","consumedCapacity","KVSTORE","readKB","readUnits","writeKB","writeUnits","MultiDeleteOp","continuationKey","_prepare","stmt","PrepareOp","prepare","__proto__","prototype","_query","query","ck","_prepStmt","prepStmt","QueryOp","_queryPlan","qpExec","_qpExec","_queryIterable","op","_adminStatus","adminResult","operationId","AdminStatusOp","_forAdminCompletion","AdminPollOp","state","COMPLETE","asReq","_forCompletion","ret","_forAdmin","isDropTable","_stmt","match","ACTIVE","_withCompletion","timeOut","_ownsTimeout","tablePollTimeout","max","_adminListOp","opName","listOpt","complete","adminDDL","output","JSON","parse","_listNamespaces","listNamespaces","namespaces","Array","isArray","findIndex","el","_listUsers","listUsers","users","map","user","id","name","_listRoles","listRoles","roles","role","_serialVersion","serialVersion","close","shutdown","Promise","resolve","destroy","_precacheAuth","auth","provider","getAuthorization","lastError","INVALID_AUTHORIZATION","_op","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/nosql_client_impl.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst assert = require('assert');\nconst HttpClient = require('./http_client');\n\nconst ops = require('./ops');\n\nconst TableState = require('./constants').TableState;\nconst AdminState = require('./constants').AdminState;\nconst ServiceType = require('./constants').ServiceType;\nconst ErrorCode = require('./error_code');\nconst NoSQLTimeoutError = require('./error').NoSQLTimeoutError;\nconst NoSQLProtocolError = require('./error').NoSQLProtocolError;\nconst NoSQLArgumentError = require('./error').NoSQLArgumentError;\nconst Config = require('./config');\nconst sleep = require('./utils').sleep;\nconst replaceObject = require('./utils').replaceObject;\nconst PreparedStatement = require('./stmt').PreparedStatement;\nconst QueryPlanExecutor = require('./query/common').QueryPlanExecutor;\nconst NoSQLError = require('./error').NoSQLError;\n\n//Default timeout for admin list operations such as listNamespaces, listUsers,\n//listRoles.\nconst DEF_ADMIN_LIST_TIMEOUT = 30000;\n\n//Default limit for table usage iterable. The value is set to 24 hours of\n//1-minute usage records.\nconst DEF_TABLE_USAGE_LIMIT = 1440;\n\nclass NoSQLClientImpl extends EventEmitter {\n\n    constructor(config) {\n        super();\n        this._config = Config.create(config);\n        this._client = new HttpClient(this._config);\n        //Forward all events from the _client.\n        this.on('newListener', (event, listener) => {\n            this._client.on(event, listener);\n        });\n        this.on('removeListener', (event, listener) => {\n            this._client.removeListener(event, listener);\n        });\n        //To prevent throwing if no error events are registered.\n        //We should log the error in this listener.\n        this.on('error', () => {});\n    }\n\n    _assignOpt(opt, addOpt) {\n        if (opt == null) {\n            return addOpt;\n        }\n        //We don't throw here because we want the error to be handled\n        //asynchronously.  If a user passes invalid opt which is not\n        //an object, we just return it and pass it to asynchronous code\n        //for validation.\n        if (typeof opt !== 'object') {\n            return opt;\n        }\n        return Object.assign({}, opt, addOpt);\n    }\n\n    //Used by _forTableState, _forLocalReplicaInit and _forAdminCompletion.\n    _doPollOpDelay(req, poReq, startTime) {\n        if (req.opt.timeout !== Infinity) {\n            const remaining = startTime + req.opt.timeout -\n                (Date.now() + req.opt.delay);\n            //Fail if we are less than opt.delay ahead of timing out.\n            if (remaining <= 0) {\n                throw new NoSQLTimeoutError(req.opt.timeout, null, req);\n            }\n            //Make sure timeout of poll op request (poReq) does not go past\n            //total poll timeout.\n            if (poReq.opt.timeout > remaining) {\n                poReq.opt.timeout = remaining;\n            }\n        }\n        return sleep(req.opt.delay);\n    }\n\n    async _forTableState(table, tableState, opt, skipInit) {\n        const req = {\n            api: typeof table === 'string' ? this.forTableState :\n                this.forCompletion,\n            table,\n            tableState,\n            opt\n        };\n\n        //If called from _withCompletion, the work below was already done on\n        //the original request.  In addition this check avoids throwing wrong\n        //error if remaining timeout < pollDelay.  Same applies to\n        //_forAdminCompletion().\n        if (!skipInit) {\n            ops.PollTableStateOp.applyDefaults(req, this._config);\n            ops.PollTableStateOp.validate(req);\n        }\n\n        // Should be set by PollTableStateOp.applyDefaults() above or from\n        // _withCompletion().\n        assert(req.opt != null);\n\n        //For forCompletion(), when table is TableResult, return if already\n        //reached desired state.\n        if (req.api === this.forCompletion &&\n            table.tableState === tableState) {\n            return table;\n        }\n\n        //Request for GetTableOp.\n        const gtReq = {\n            api: req.api,\n            table,\n            opt: {\n                compartment: req.opt.compartment,\n                timeout: Math.min(this._config.timeout, req.opt.timeout)\n            }\n        };\n        \n        const startTime = Date.now();\n        for(;;) {\n            try {\n                const res = await this._execute(ops.GetTableOp, gtReq);\n                if (res.tableState === req.tableState) {\n                    return res;\n                }\n            } catch(err) {\n                if (err.errorCode === ErrorCode.TABLE_NOT_FOUND &&\n                    req.tableState === TableState.DROPPED) {\n                    const res = {\n                        tableName: gtReq.tableName,\n                        tableState: TableState.DROPPED\n                    };\n                    //In this case onResult was not called by _execute above.\n                    ops.PollTableStateOp.onResult(this, req, res);\n                    return res;\n                }\n                throw err;\n            }\n            await this._doPollOpDelay(req, gtReq, startTime);\n        }\n    }\n\n    async _forLocalReplicaInit(table, opt) {\n        const req = {\n            api: this.forLocalReplicaInit,\n            table,\n            opt\n        };\n\n        if (this._config.serviceType !== ServiceType.CLOUD) {\n            throw NoSQLError.create(ErrorCode.OPERATION_NOT_SUPPORTED,\n                `forLocalReplicaInit is not supported for service type \\\n${this._config.serviceType} (requires Cloud Service)`, null, req);\n        }\n\n        ops.PollTableOp.applyDefaults(req, this._config);\n        ops.PollTableOp.validate(req);\n        assert(req.opt != null);\n\n        //Request for GetTableOp.\n        const gtReq = {\n            api: req.api,\n            table,\n            opt: {\n                compartment: req.opt.compartment,\n                timeout: Math.min(this._config.timeout, req.opt.timeout)\n            }\n        };\n        \n        const startTime = Date.now();\n        for(;;) {\n            const res = await this._execute(ops.GetTableOp, gtReq);\n            if (res.isLocalReplicaInitialized) {\n                return res;\n            }\n            await this._doPollOpDelay(req, gtReq, startTime);\n        }\n    }\n\n    async * _tableUsageIterable(tableName, opt) {\n        if (opt == null) {\n            opt = {};\n        } else if (typeof opt === 'object') {\n            opt = Object.assign({}, opt);\n            opt.startIndex = undefined;\n        }\n        if (opt.limit == null) {\n            opt.limit = DEF_TABLE_USAGE_LIMIT;\n        }\n        let res;\n        do {\n            res = await this.getTableUsage(tableName, opt);\n            if (!res.usageRecords.length) {\n                break;\n            }\n            opt.startIndex = res.nextIndex;\n            yield res;\n        } while(res.usageRecords.length === opt.limit);\n    }\n\n    async _getIndex(tableName, indexName, opt) {\n        const req = {\n            api: this.getIndex,\n            tableName,\n            opt\n        };\n        req.opt = this._assignOpt(opt, { indexName });\n        const res = await this._client.execute(ops.GetIndexesOp, req);\n        if (res.length != 1) {\n            throw new NoSQLProtocolError(\n                `Unexpected number of index results: ${res.length}`,\n                null, req);\n        }\n        return res[0];\n    }\n\n    //Note: This function is only used if opt.all is set to true and is not\n    //fully implemented yet to account for throttling errors.  Reserved for\n    //future use.\n    async _deleteRangeAll(tableName, key, opt) {\n        const req = {\n            api: this.deleteRange,\n            tableName,\n            key,\n            opt\n        };\n        //Accumulate deletedCount and consumedCapacity\n        const total = {\n            deletedCount: 0,\n            consumedCapacity: \n                this._config.serviceType !== ServiceType.KVSTORE ? {\n                    readKB: 0,\n                    readUnits: 0,\n                    writeKB: 0,\n                    writeUnits: 0\n                } : null\n        };\n\n        for(;;) {\n            const res = await this._client.execute(ops.MultiDeleteOp, req);\n            assert(res.deletedCount != null);\n            assert(res.consumedCapacity != null ||\n                total.consumedCapacity == null);\n            total.deletedCount += res.deletedCount;\n            if (total.consumedCapacity) {\n                for(let key in total.consumedCapacity) {\n                    total.consumedCapacity[key] += res.consumedCapacity[key];\n                }\n            }\n            if (!res.continuationKey) {\n                res.deletedCount = total.deletedCount;\n                if (total.consumedCapacity) {\n                    Object.assign(res.consumedCapacity,\n                        total.consumedCapacity);\n                }\n                return res;\n            }\n            opt.continuationKey = res.continuationKey;\n        }\n    }\n\n    async _prepare(stmt, opt) {\n        const res = await this._client.execute(ops.PrepareOp, {\n            api: this.prepare,\n            stmt,\n            opt\n        });\n        res.__proto__ = PreparedStatement.prototype;\n        return res;\n    }\n\n    async _query(stmt, opt) {\n        const req = {\n            api: this.query,\n            opt\n        };\n\n        let ck = opt ? opt.continuationKey : null;\n        if (ck && ck._prepStmt) {\n            req.prepStmt = ck._prepStmt;\n        } else if (typeof stmt !== 'string') {\n            req.prepStmt = stmt;\n        } else {\n            req.stmt = stmt;\n        }\n\n        if (!req.prepStmt) {\n            const res = await this._client.execute(ops.QueryOp, req);\n            //We always read the prepared statement if the request does not\n            //have it.\n            assert(res._prepStmt);\n            //Simple query may already have results, so we just return them.\n            if (!res._prepStmt._queryPlan) {\n                return res;\n            }\n\n            //Advanced query will have no results in this case, only the\n            //prepared statement. To make it more intuitive for the user, we\n            //execute the first prepared query call.\n            req.prepStmt = res._prepStmt;\n            req.stmt = undefined;\n            ck = res.continuationKey;\n            assert(ck); //see QueryOp.onResult()\n            assert(req.opt); //see Op.applyDefaults()\n            req.opt.continuationKey = ck;\n        }\n\n        //Advanced query.\n        if (req.prepStmt._queryPlan) {\n            let qpExec = ck ? ck._qpExec : null;\n            if (!qpExec) {\n                //First advanced query call, create plan executor.\n                qpExec = new QueryPlanExecutor(this, req.prepStmt);\n            }\n            return qpExec.execute(req);\n        }\n\n        //Simple query.\n        return this._client.execute(ops.QueryOp, req);\n    }\n\n    async * _queryIterable(stmt, opt) {\n        if (opt == null) {\n            opt = {};\n        } else if (typeof opt === 'object') {\n            opt = Object.assign({}, opt);\n            opt.continuationKey = undefined;\n        }\n        \n        do {\n            const res = await this.query(stmt, opt);\n            opt.continuationKey = res.continuationKey;\n            yield res;\n        } while(opt.continuationKey);\n    }\n\n    _execute(op, req) {\n        return this._client.execute(op, req);\n    }\n\n    async _adminStatus(req) {\n        if (req.adminResult != null && req.adminResult.operationId == null) {\n            //still validate options passed for correctness\n            ops.AdminStatusOp.applyDefaults(req, this._config);\n            ops.AdminStatusOp.validate(req);\n            return req.adminResult;\n        }\n        return this._execute(ops.AdminStatusOp, req);\n    }\n\n    async _forAdminCompletion(adminResult, opt, skipInit) {\n        const req = {\n            api: this.forCompletion,\n            adminResult,\n            opt\n        };\n\n        if (!skipInit) {\n            ops.AdminPollOp.applyDefaults(req, this._config);\n            ops.AdminPollOp.validate(req);\n        }\n\n        // Should be set by AdminPollOp.applyDefaults() above or from\n        // _withCompletion().\n        assert(req.opt != null);\n\n        if (adminResult.state === AdminState.COMPLETE) {\n            return adminResult;\n        }\n\n        //Request for AdminStatusOp.\n        const asReq = {\n            api: req.api,\n            adminResult,\n            opt: {\n                timeout: Math.min(this._config.timeout, req.opt.timeout)\n            }\n        };\n\n        const startTime = Date.now();\n        for(;;) {\n            const res = await this._execute(ops.AdminStatusOp, asReq);\n            if (res.state === AdminState.COMPLETE) {\n                return res;\n            }\n            await this._doPollOpDelay(req, asReq, startTime);\n        }\n    }\n\n    async _forCompletion(res, opt, skipInit) {\n        let ret;\n        if (res == null) {\n            throw new NoSQLArgumentError(\n                'forCompletion: missing result object');\n        }\n        if (res._forAdmin) {\n            ret = await this._forAdminCompletion(res, opt, skipInit);\n        } else {\n            const isDropTable = typeof res._stmt === 'string' &&\n                res._stmt.match(/^\\s*DROP\\s+TABLE\\s+/i);\n            ret = await this._forTableState(res, isDropTable ?\n                TableState.DROPPED : TableState.ACTIVE, opt, skipInit);\n        }\n        return replaceObject(res, ret);\n    }\n\n    async _withCompletion(op, req) {\n        const startTime = Date.now();\n        const res = await this._execute(op, req);\n\n        //This initialization would be done by _execute() above.\n        assert(req.opt != null && req.opt.__proto__ === this._config);\n        \n        let timeOut = req.opt._ownsTimeout ?\n            req.opt.timeout : this._config.tablePollTimeout;\n        if (timeOut !== Infinity) {\n            timeOut -= (Date.now() - startTime);\n        }\n\n        req.opt.timeout = Math.max(timeOut, 1);\n        return this._forCompletion(res, req.opt, true);\n    }\n\n    async _adminListOp(opName, stmt, req) {\n        const listOpt = {\n            complete: true,\n            timeout: DEF_ADMIN_LIST_TIMEOUT\n        };\n        if (req.opt == null) {\n            req.opt = listOpt;\n        } else if (typeof req.opt === 'object') {\n            //if typeof opt !== 'object', it will be passed to adminDDL\n            //and throw during validation\n            req.opt = Object.assign(listOpt, req.opt);\n        }\n        let res = await this.adminDDL(stmt, req.opt);\n        if (res.output == null) {\n            throw new NoSQLProtocolError(`Missing output for ${opName}`, null,\n                req);\n        }\n        try {\n            res = JSON.parse(res.output);\n        } catch(err) {\n            throw new NoSQLProtocolError(`Error parsing output for \\\n${opName}`, null, req);\n        }\n        if (res == null || typeof res !== 'object') {\n            throw new NoSQLProtocolError(`Invalid output for ${opName}`, null,\n                req);\n        }\n        return res;\n    }\n\n    async _listNamespaces(opt) {\n        const req = { //will be included in any thrown errors\n            api: this.listNamespaces,\n            opt\n        };\n        const res = await this._adminListOp('listNamespaces',\n            'SHOW AS JSON NAMESPACES', req);\n        if (res.namespaces == null) {\n            return [];\n        }\n        if (!Array.isArray(res.namespaces) || res.namespaces.findIndex(\n            el => typeof el !== 'string') !== -1) {\n            throw new NoSQLProtocolError('Invalid namespaces array in \\\nthe output for listNamespaces operation', null, req);\n        }\n        return res.namespaces;\n    }\n\n    async _listUsers(opt) {\n        const req = { //will be included in any thrown errors\n            api: this.listUsers,\n            opt\n        };\n        const res = await this._adminListOp('listUsers', 'SHOW AS JSON USERS',\n            req);\n        if (res.users == null) {\n            return [];\n        }\n        if (!Array.isArray(res.users)) {\n            throw new NoSQLProtocolError('Invalid users array in the output \\\nfor listUsers operation', null, req);\n        }\n        return res.users.map(user => {\n            if (user == null || typeof user !== 'object' ||\n            typeof user.id !== 'string' || typeof user.name !== 'string') {\n                throw new NoSQLProtocolError('Invalid value in the users \\\narray in the output for listUsers operation', null, req);\n            }\n            return {\n                id: user.id,\n                name: user.name\n            };\n        });\n    }\n\n    async _listRoles(opt) {\n        const req = { //will be included in any thrown errors\n            api: this.listRoles,\n            opt\n        };\n        const res = await this._adminListOp('listRoles', 'SHOW AS JSON ROLES',\n            req);\n        if (res.roles == null) {\n            return [];\n        }\n        if (!Array.isArray(res.roles)) {\n            throw new NoSQLProtocolError('Invalid roles array in the output \\\nfor listRoles operation', null, req);\n        }\n        return res.roles.map(role => {\n            if (role == null || typeof role !== 'object' ||\n            typeof role.name !== 'string') {\n                throw new NoSQLProtocolError('Invalid value in the roles \\\narray in the output for listRoles operation', null, req);\n            }\n            return role.name;\n        });\n    }\n\n    //used for testing\n    get _serialVersion() {\n        return this._client.serialVersion;\n    }\n\n    close() {\n        this._client.shutdown();\n        return Promise.resolve(Config.destroy(this._config));\n    }\n\n    async _precacheAuth() {\n        await this._config.auth.provider.getAuthorization({\n            opt: {\n                __proto__: this._config\n            },\n            lastError: new NoSQLError(ErrorCode.INVALID_AUTHORIZATION),\n            _op: ops.GetTableOp\n        });\n        return this;\n    }\n    \n}\n\nmodule.exports = NoSQLClientImpl;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}