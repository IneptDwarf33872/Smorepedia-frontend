{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst path = require('path');\nconst ErrorCode = require('../error').ErrorCode;\nconst NoSQLTimeoutError = require('../error').NoSQLTimeoutError;\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\nconst TableState = require('../constants').TableState;\nconst GetTableOp = require('../ops').GetTableOp;\nconst ServiceType = require('../constants').ServiceType;\nconst SimpleRateLimiter = require('./simple_rate_limiter');\nconst requireNoWP = require('../utils').requireNoWP;\nconst isChildTable = require('../utils').isChildTable;\nconst topTableName = require('../utils').topTableName;\n\n//Check table limits in background every 10 minutes\nconst BG_CHECK_INTERVAL = 600000;\n\n//Timeout over multiple retries for getTable in background\nconst BG_GETTABLE_TIMEOUT = 300000;\n\n//It seems that clearTimeout already ignores invalid values, this is just\n//in case this behavior changes in future\nfunction _clearTimeout(tm) {\n  if (tm != null && typeof tm === 'object') {\n    clearTimeout(tm);\n  }\n}\nclass RateLimiterClient {\n  constructor(client) {\n    this._client = client;\n    let rl = client._config.rateLimiter;\n    switch (typeof rl) {\n      case 'undefined':\n      case 'null':\n        assert(false);\n        break;\n      case 'function':\n        this._limiterCls = rl;\n        break;\n      case 'boolean':\n        assert(rl === true);\n        this._limiterCls = SimpleRateLimiter;\n        break;\n      case 'string':\n        try {\n          rl = requireNoWP(path.resolve(rl));\n          this._limiterCls = rl;\n          break;\n        } catch (err) {\n          throw new NoSQLArgumentError(`Error loading rate limiter \\\nclass from module ${rl}`, client._config, err);\n        }\n      case 'object':\n        assert(rl != null);\n        this._limiterCls = SimpleRateLimiter;\n        if (rl.maxBurstSeconds != null) {\n          if (typeof rl.maxBurstSeconds !== 'number' || rl.maxBurstSeconds < 0) {\n            throw new NoSQLArgumentError('Invalid value of rateLimiter.maxBurstSeconds: ' + rl.maxBurstSeconds, client._config);\n          }\n          this._maxBurstSecs = rl.maxBurstSeconds;\n        }\n        break;\n      default:\n        throw new NoSQLArgumentError(`Invalid value of rateLimiter: ${rl}`, client._config);\n    }\n    const limiterPercent = client._config.rateLimiterPercent;\n    if (limiterPercent != null) {\n      if (typeof limiterPercent !== 'number' || limiterPercent <= 0 || limiterPercent > 100) {\n        throw new NoSQLArgumentError(`Invalid value of rateLimiterPercent: ${limiterPercent}`);\n      }\n      this._limiterRatio = limiterPercent / 100;\n    }\n    this._rlMap = new Map();\n    this._rlUpdateMap = new Map();\n  }\n  _doUpdateLimiters(tblNameLower, tblRes) {\n    if (tblRes.tableState === TableState.DROPPED) {\n      this._rlMap.delete(tblNameLower);\n      return;\n    }\n    if (tblRes.tableState !== TableState.ACTIVE) {\n      return;\n    }\n\n    //special case for table with no limits\n    if (tblRes.tableLimits == null) {\n      this._rlMap.set(tblNameLower, {\n        noLimits: true\n      });\n      return;\n    }\n    let ent = this._rlMap.get(tblNameLower);\n    if (ent == null) {\n      //we store readUnits and writeUnits in ent to allow precise\n      //integer comparsion in order to update the limiters\n      //(see the else... clause below)\n      ent = {\n        readUnits: tblRes.tableLimits.readUnits,\n        readRL: this._createLimiter(tblRes.tableLimits.readUnits),\n        writeUnits: tblRes.tableLimits.writeUnits,\n        writeRL: this._createLimiter(tblRes.tableLimits.writeUnits)\n      };\n      this._rlMap.set(tblNameLower, ent);\n    } else {\n      if (ent.readUnits !== tblRes.tableLimits.readUnits) {\n        ent.readUnits = tblRes.tableLimits.readUnits;\n        this._setLimit(ent.readRL, tblRes.tableLimits.readUnits);\n      }\n      if (ent.writeUnits !== tblRes.tableLimits.writeUnits) {\n        ent.writeUnits = tblRes.tableLimits.writeUnits;\n        this._setLimit(ent.writeRL, tblRes.tableLimits.writeUnits);\n      }\n    }\n  }\n\n  //tblRes is undefined in case of error during getTable\n  _updateLimiters(tblNameLower, tblRes) {\n    _clearTimeout(this._rlUpdateMap.get(tblNameLower));\n    if (tblRes != null) {\n      this._doUpdateLimiters(tblNameLower, tblRes);\n    }\n\n    //keep checking table limits at regular interval BG_CHECK_INTERVAL\n    //if was not successful or if using multiple clients each using\n    //portion of table limits (this._limiterRatio)\n    if (tblRes == null || this._limiterRatio != null) {\n      this._rlUpdateMap.set(tblNameLower, setTimeout(() => this._doBackgroundUpdate(tblNameLower), BG_CHECK_INTERVAL));\n    } else {\n      //just so that we don't launch background update again\n      this._rlUpdateMap.set(tblNameLower, true);\n    }\n  }\n  async _doBackgroundUpdate(tblNameLower) {\n    let res;\n    try {\n      res = await this._client.execute(GetTableOp, {\n        tableName: tblNameLower,\n        opt: {\n          //allow enough for retries if necessary\n          timeout: BG_GETTABLE_TIMEOUT\n        }\n      });\n    } catch (err) {\n      if (err.errorCode === ErrorCode.TABLE_NOT_FOUND) {\n        res = {\n          tableName: tblNameLower,\n          tableState: TableState.DROPPED\n        };\n      }\n    }\n    this._updateLimiters(tblNameLower, res);\n  }\n  _backgroundUpdateLimiters(tblNameLower) {\n    if (this._rlUpdateMap.get(tblNameLower) != null) {\n      return;\n    }\n    this._rlUpdateMap.set(tblNameLower, setTimeout(() => this._doBackgroundUpdate(tblNameLower), 0));\n  }\n  _setRLEnt(req, res) {\n    let tblName = req._op.getTableName(req, res);\n    if (tblName == null) {\n      return;\n    }\n    tblName = topTableName(tblName).toLowerCase();\n    req._rlEnt = this._rlMap.get(tblName);\n    if (req._rlEnt != null) {\n      //initialize rate limit delays to be computed later\n      if (req._doesReads) {\n        req._rrlDelay = 0;\n      }\n      if (req._doesWrites) {\n        req._wrlDelay = 0;\n      }\n    } else {\n      //initiate getting table limits in the background\n      this._backgroundUpdateLimiters(tblName);\n    }\n  }\n  _createLimiter(units) {\n    let res;\n    if (this._maxBurstSecs != null) {\n      assert(this._limiterCls === SimpleRateLimiter);\n      res = new SimpleRateLimiter(this._maxBurstSecs);\n    } else {\n      res = new this._limiterCls();\n    }\n    this._setLimit(res, units);\n    return res;\n  }\n  _setLimit(limiter, units) {\n    limiter.setLimit(this._limiterRatio == null ? units : units * this._limiterRatio);\n  }\n  static rateLimitingEnabled(cfg) {\n    return cfg.serviceType != ServiceType.KVSTORE && cfg.rateLimiter;\n  }\n  close() {\n    this._rlUpdateMap.forEach(val => _clearTimeout(val));\n  }\n  updateLimiters(tblRes) {\n    if (tblRes.tableName == null) {\n      throw new NoSQLProtocolError('TableResult is missing table name');\n    }\n    //Table limits are not sent for child tables.\n    if (!isChildTable(tblRes.tableName)) {\n      this._updateLimiters(tblRes.tableName.toLowerCase(), tblRes);\n    }\n  }\n  initRequest(req) {\n    req._doesReads = req._op.doesReads(req);\n    req._doesWrites = req._op.doesWrites(req);\n    this._setRLEnt(req);\n  }\n  async startRequest(req, timeout, totalTimeout, numRetries) {\n    if (req._rlEnt == null || req._rlEnt.noLimits) {\n      return;\n    }\n    try {\n      let startTime;\n      if (req._doesReads) {\n        assert(req._rrlDelay != null);\n        startTime = Date.now();\n        req._rrlDelay += await req._rlEnt.readRL.consumeUnits(0, timeout, false);\n      }\n      if (req._doesWrites) {\n        assert(req._wrlDelay != null);\n        if (startTime) {\n          timeout = Math.max(startTime + timeout - Date.now(), 0);\n        }\n        req._wrlDelay += await req._rlEnt.writeRL.consumeUnits(0, timeout, false);\n      }\n    } catch (err) {\n      throw new NoSQLTimeoutError(totalTimeout, numRetries, req, err);\n    }\n  }\n  async finishRequest(req, res, timeout) {\n    //For un-prepared query request the table name is not known until\n    //the request is processed, so we try again (note that this must be\n    //done after Op.onResult() is called).  May also be called if table\n    //limits were just obtained.\n    if (req._rlEnt == null) {\n      //We have to recompute doesReads and doesWrites since their values\n      //may depend on the result of operation.  This is the case for\n      //doesWrites for query that was just prepared.\n      req._doesReads = req._op.doesReads(req, res);\n      req._doesWrites = req._op.doesWrites(req, res);\n      this._setRLEnt(req, res);\n    }\n    if (req._rlEnt == null || req._rlEnt.noLimits) {\n      return;\n    }\n    assert(res.consumedCapacity != null);\n    if (req._doesReads) {\n      assert(req._rrlDelay != null);\n      res.consumedCapacity.readRateLimitDelay = req._rrlDelay;\n      res.consumedCapacity.readRateLimitDelay += await req._rlEnt.readRL.consumeUnits(res.consumedCapacity.readUnits, timeout, true);\n    }\n    if (req._doesWrites) {\n      assert(req._wrlDelay != null);\n      res.consumedCapacity.writeRateLimitDelay = req._wrlDelay;\n      res.consumedCapacity.writeRateLimitDelay += await req._rlEnt.writeRL.consumeUnits(res.consumedCapacity.writeUnits, timeout, true);\n    }\n  }\n  onError(req, err) {\n    if (req._rlEnt == null || req._rlEnt.noLimits) {\n      return;\n    }\n    if (err.errorCode === ErrorCode.READ_LIMIT_EXCEEDED) {\n      req._doesReads = true;\n      req._rlEnt.readRL.onThrottle(err);\n    } else if (err.errorCode === ErrorCode.WRITE_LIMIT_EXCEEDED) {\n      req._doesWrites = true;\n      req._rlEnt.writeRL.onThrottle(err);\n    }\n  }\n}\nmodule.exports = RateLimiterClient;","map":{"version":3,"names":["assert","require","path","ErrorCode","NoSQLTimeoutError","NoSQLProtocolError","NoSQLArgumentError","TableState","GetTableOp","ServiceType","SimpleRateLimiter","requireNoWP","isChildTable","topTableName","BG_CHECK_INTERVAL","BG_GETTABLE_TIMEOUT","_clearTimeout","tm","clearTimeout","RateLimiterClient","constructor","client","_client","rl","_config","rateLimiter","_limiterCls","resolve","err","maxBurstSeconds","_maxBurstSecs","limiterPercent","rateLimiterPercent","_limiterRatio","_rlMap","Map","_rlUpdateMap","_doUpdateLimiters","tblNameLower","tblRes","tableState","DROPPED","delete","ACTIVE","tableLimits","set","noLimits","ent","get","readUnits","readRL","_createLimiter","writeUnits","writeRL","_setLimit","_updateLimiters","setTimeout","_doBackgroundUpdate","res","execute","tableName","opt","timeout","errorCode","TABLE_NOT_FOUND","_backgroundUpdateLimiters","_setRLEnt","req","tblName","_op","getTableName","toLowerCase","_rlEnt","_doesReads","_rrlDelay","_doesWrites","_wrlDelay","units","limiter","setLimit","rateLimitingEnabled","cfg","serviceType","KVSTORE","close","forEach","val","updateLimiters","initRequest","doesReads","doesWrites","startRequest","totalTimeout","numRetries","startTime","Date","now","consumeUnits","Math","max","finishRequest","consumedCapacity","readRateLimitDelay","writeRateLimitDelay","onError","READ_LIMIT_EXCEEDED","onThrottle","WRITE_LIMIT_EXCEEDED","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/rate_limiter/client.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst path = require('path');\n\nconst ErrorCode = require('../error').ErrorCode;\nconst NoSQLTimeoutError = require('../error').NoSQLTimeoutError;\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\nconst TableState = require('../constants').TableState;\nconst GetTableOp = require('../ops').GetTableOp;\nconst ServiceType = require('../constants').ServiceType;\nconst SimpleRateLimiter = require('./simple_rate_limiter');\nconst requireNoWP = require('../utils').requireNoWP;\nconst isChildTable = require('../utils').isChildTable;\nconst topTableName = require('../utils').topTableName;\n\n//Check table limits in background every 10 minutes\nconst BG_CHECK_INTERVAL = 600000;\n\n//Timeout over multiple retries for getTable in background\nconst BG_GETTABLE_TIMEOUT = 300000;\n\n//It seems that clearTimeout already ignores invalid values, this is just\n//in case this behavior changes in future\nfunction _clearTimeout(tm) {\n    if (tm != null && typeof tm === 'object') {\n        clearTimeout(tm);\n    }\n}\n\nclass RateLimiterClient {\n\n    constructor(client)\n    {\n        this._client = client;\n\n        let rl = client._config.rateLimiter;\n        switch(typeof rl) {\n        case 'undefined': case 'null':\n            assert(false);\n            break;\n        case 'function':\n            this._limiterCls = rl;\n            break;\n        case 'boolean':\n            assert(rl === true);\n            this._limiterCls = SimpleRateLimiter;\n            break;\n        case 'string':\n            try {\n                rl = requireNoWP(path.resolve(rl));\n                this._limiterCls = rl;\n                break;\n            } catch(err) {\n                throw new NoSQLArgumentError(`Error loading rate limiter \\\nclass from module ${rl}`, client._config, err);\n            }\n        case 'object':\n            assert(rl != null);\n            this._limiterCls = SimpleRateLimiter;\n            if (rl.maxBurstSeconds != null) {\n                if (typeof rl.maxBurstSeconds !== 'number' ||\n                    rl.maxBurstSeconds < 0) {\n                    throw new NoSQLArgumentError(\n                        'Invalid value of rateLimiter.maxBurstSeconds: ' +\n                        rl.maxBurstSeconds, client._config);\n                }\n                this._maxBurstSecs = rl.maxBurstSeconds;\n            }\n            break;\n        default:\n            throw new NoSQLArgumentError(\n                `Invalid value of rateLimiter: ${rl}`, client._config);\n        }\n\n        const limiterPercent = client._config.rateLimiterPercent;\n        if (limiterPercent != null) {\n            if (typeof limiterPercent !== 'number' || limiterPercent <= 0 ||\n                limiterPercent > 100) {\n                throw new NoSQLArgumentError(\n                    `Invalid value of rateLimiterPercent: ${limiterPercent}`);\n            }\n            this._limiterRatio = limiterPercent / 100;\n        }\n\n        this._rlMap = new Map();\n        this._rlUpdateMap = new Map();\n    }\n\n    _doUpdateLimiters(tblNameLower, tblRes) {\n        if (tblRes.tableState === TableState.DROPPED) {\n            this._rlMap.delete(tblNameLower);\n            return;\n        }\n\n        if (tblRes.tableState !== TableState.ACTIVE) {\n            return;\n        }\n\n        //special case for table with no limits\n        if (tblRes.tableLimits == null) {\n            this._rlMap.set(tblNameLower, { noLimits: true });\n            return;\n        }\n\n        let ent = this._rlMap.get(tblNameLower);\n        if (ent == null) {\n            //we store readUnits and writeUnits in ent to allow precise\n            //integer comparsion in order to update the limiters\n            //(see the else... clause below)\n            ent = {\n                readUnits: tblRes.tableLimits.readUnits,\n                readRL: this._createLimiter(tblRes.tableLimits.readUnits),\n                writeUnits: tblRes.tableLimits.writeUnits,\n                writeRL: this._createLimiter(tblRes.tableLimits.writeUnits),\n            };\n            this._rlMap.set(tblNameLower, ent);\n        } else {\n            if (ent.readUnits !== tblRes.tableLimits.readUnits) {\n                ent.readUnits = tblRes.tableLimits.readUnits;\n                this._setLimit(ent.readRL, tblRes.tableLimits.readUnits);\n            }\n            if (ent.writeUnits !== tblRes.tableLimits.writeUnits) {\n                ent.writeUnits = tblRes.tableLimits.writeUnits;\n                this._setLimit(ent.writeRL, tblRes.tableLimits.writeUnits);\n            }\n        }\n    }\n\n    //tblRes is undefined in case of error during getTable\n    _updateLimiters(tblNameLower, tblRes) {\n        _clearTimeout(this._rlUpdateMap.get(tblNameLower));\n        \n        if (tblRes != null) {\n            this._doUpdateLimiters(tblNameLower, tblRes);\n        }\n\n        //keep checking table limits at regular interval BG_CHECK_INTERVAL\n        //if was not successful or if using multiple clients each using\n        //portion of table limits (this._limiterRatio)\n        if (tblRes == null || this._limiterRatio != null) {\n            this._rlUpdateMap.set(tblNameLower, setTimeout(() =>\n                this._doBackgroundUpdate(tblNameLower), BG_CHECK_INTERVAL));\n        } else {\n            //just so that we don't launch background update again\n            this._rlUpdateMap.set(tblNameLower, true);\n        }\n    }\n\n    async _doBackgroundUpdate(tblNameLower) {\n        let res;\n        try {\n            res = await this._client.execute(GetTableOp, {\n                tableName: tblNameLower,\n                opt: {\n                    //allow enough for retries if necessary\n                    timeout: BG_GETTABLE_TIMEOUT\n                }\n            });\n        } catch(err) {\n            if (err.errorCode === ErrorCode.TABLE_NOT_FOUND) {\n                res = {\n                    tableName: tblNameLower,\n                    tableState: TableState.DROPPED\n                };\n            }\n        }\n\n        this._updateLimiters(tblNameLower, res);\n    }\n\n    _backgroundUpdateLimiters(tblNameLower) {\n        if (this._rlUpdateMap.get(tblNameLower) != null) {\n            return;\n        }\n        this._rlUpdateMap.set(tblNameLower, setTimeout(() =>\n            this._doBackgroundUpdate(tblNameLower), 0));\n    }\n\n    _setRLEnt(req, res) {\n        let tblName = req._op.getTableName(req, res);\n        if (tblName == null) {\n            return;\n        }\n\n        tblName = topTableName(tblName).toLowerCase();\n        req._rlEnt = this._rlMap.get(tblName);\n        if (req._rlEnt != null) {\n            //initialize rate limit delays to be computed later\n            if (req._doesReads) {\n                req._rrlDelay = 0;\n            }\n            if (req._doesWrites) {\n                req._wrlDelay = 0;\n            }\n        } else { //initiate getting table limits in the background\n            this._backgroundUpdateLimiters(tblName);\n        }\n    }\n\n    _createLimiter(units) {\n        let res;\n        if (this._maxBurstSecs != null) {\n            assert(this._limiterCls === SimpleRateLimiter);\n            res = new SimpleRateLimiter(this._maxBurstSecs);\n        } else {\n            res = new this._limiterCls();\n        }\n        this._setLimit(res, units);\n        return res;\n    }\n\n    _setLimit(limiter, units) {\n        limiter.setLimit(this._limiterRatio == null ?\n            units : units * this._limiterRatio);\n    }\n\n    static rateLimitingEnabled(cfg) {\n        return cfg.serviceType != ServiceType.KVSTORE && cfg.rateLimiter;\n    }\n\n    close() {\n        this._rlUpdateMap.forEach(val => _clearTimeout(val));\n    }\n\n    updateLimiters(tblRes) {\n        if (tblRes.tableName == null) {\n            throw new NoSQLProtocolError('TableResult is missing table name');\n        }\n        //Table limits are not sent for child tables.\n        if (!isChildTable(tblRes.tableName)) {\n            this._updateLimiters(tblRes.tableName.toLowerCase(), tblRes);\n        }\n    }\n\n    initRequest(req) {\n        req._doesReads = req._op.doesReads(req);\n        req._doesWrites = req._op.doesWrites(req);\n        this._setRLEnt(req);\n    }\n\n    async startRequest(req, timeout, totalTimeout, numRetries) {\n        if (req._rlEnt == null || req._rlEnt.noLimits) {\n            return;\n        }\n        try {\n            let startTime;\n            if (req._doesReads) {\n                assert(req._rrlDelay != null);\n                startTime = Date.now();\n                req._rrlDelay += await req._rlEnt.readRL.consumeUnits(\n                    0, timeout, false);\n            }\n            if (req._doesWrites) {\n                assert(req._wrlDelay != null);\n                if (startTime) {\n                    timeout = Math.max(startTime + timeout - Date.now(), 0);    \n                }\n                req._wrlDelay += await req._rlEnt.writeRL.consumeUnits(\n                    0, timeout, false);\n            }\n        } catch(err) {\n            throw new NoSQLTimeoutError(totalTimeout, numRetries, req, err);\n        }\n    }\n\n    async finishRequest(req, res, timeout) {\n        //For un-prepared query request the table name is not known until\n        //the request is processed, so we try again (note that this must be\n        //done after Op.onResult() is called).  May also be called if table\n        //limits were just obtained.\n        if (req._rlEnt == null) {\n            //We have to recompute doesReads and doesWrites since their values\n            //may depend on the result of operation.  This is the case for\n            //doesWrites for query that was just prepared.\n            req._doesReads = req._op.doesReads(req, res);\n            req._doesWrites = req._op.doesWrites(req, res);\n            this._setRLEnt(req, res);\n        }\n\n        if (req._rlEnt == null || req._rlEnt.noLimits) {\n            return;\n        }\n\n        assert(res.consumedCapacity != null);\n\n        if (req._doesReads) {\n            assert(req._rrlDelay != null);\n            res.consumedCapacity.readRateLimitDelay = req._rrlDelay;\n            res.consumedCapacity.readRateLimitDelay +=\n                await req._rlEnt.readRL.consumeUnits(\n                    res.consumedCapacity.readUnits, timeout, true);\n        }\n        \n        if (req._doesWrites) {\n            assert(req._wrlDelay != null);\n            res.consumedCapacity.writeRateLimitDelay = req._wrlDelay;\n            res.consumedCapacity.writeRateLimitDelay +=\n                await req._rlEnt.writeRL.consumeUnits(\n                    res.consumedCapacity.writeUnits, timeout, true);\n        }\n    }\n\n    onError(req, err) {\n        if (req._rlEnt == null || req._rlEnt.noLimits) {\n            return;\n        }\n\n        if (err.errorCode === ErrorCode.READ_LIMIT_EXCEEDED) {\n            req._doesReads = true;\n            req._rlEnt.readRL.onThrottle(err);\n        } else if (err.errorCode === ErrorCode.WRITE_LIMIT_EXCEEDED) {\n            req._doesWrites = true;\n            req._rlEnt.writeRL.onThrottle(err);\n        }\n    }\n\n}\n\nmodule.exports = RateLimiterClient;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}