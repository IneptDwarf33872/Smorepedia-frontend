{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\nconst assert = require('assert');\nconst util = require('util');\nconst Region = require('../../region');\nconst HttpConstants = require('../../constants').HttpConstants;\nconst NoSQLArgumentError = require('../../error').NoSQLArgumentError;\nconst NoSQLServiceError = require('../../error').NoSQLServiceError;\nconst NoSQLAuthorizationError = require('../../error').NoSQLAuthorizationError;\nconst isPosInt32 = require('../../utils').isPosInt32;\nconst isPosInt32OrZero = require('../../utils').isPosInt32OrZero;\nconst HttpClient = require('../http_client');\nconst Utils = require('./utils');\n\n/* Instance metadata service base URL */\nconst METADATA_SERVICE_BASE_URL = 'http://169.254.169.254/opc/v2/';\nconst FALLBACK_METADATA_SERVICE_URL = 'http://169.254.169.254/opc/v1/';\n\n/* The authorization header need to send to metadata service since V2 */\nconst AUTHORIZATION_HEADER_VALUE = 'Bearer Oracle';\n\n/* The default purpose value in federation requests against IAM */\nconst DEFAULT_PURPOSE = 'DEFAULT';\n\n/* signing headers used to obtain security token */\nconst SIGNING_HEADERS = 'date (request-target) content-length content-type x-content-sha256';\nfunction authHttpError(msg, cause) {\n  return cause instanceof NoSQLServiceError ? NoSQLAuthorizationError.service(msg, cause) : NoSQLAuthorizationError.network(msg, cause);\n}\nclass X509FederationClient {\n  constructor(federationEndpoint, tenantId, purpose, timeout) {\n    this._httpClient = new HttpClient();\n    this._url = new URL('/v1/x509', federationEndpoint);\n    this._tenantId = tenantId;\n    this._purpose = purpose;\n    this._timeout = timeout;\n  }\n  _requestPayload(publicKey, instCert, intermediateCerts) {\n    const pubKeyEnc = publicKey.export({\n      type: 'spki',\n      format: 'der'\n    }).toString('base64');\n    const instCertEnc = Utils.pemCert2derB64(instCert);\n    const intermediateCertsEnc = intermediateCerts.map(cert => Utils.pemCert2derB64(cert));\n    return JSON.stringify({\n      publicKey: pubKeyEnc,\n      certificate: instCertEnc,\n      purpose: this._purpose,\n      intermediateCertificates: intermediateCertsEnc\n    });\n  }\n  _signingContent(dateStr, payload, digest) {\n    return `${HttpConstants.DATE}: ${dateStr}\\n\\\n${HttpConstants.REQUEST_TARGET}: post ${this._url.pathname}\\n\\\n${HttpConstants.CONTENT_LENGTH_LWR}: ${payload.length}\\n\\\n${HttpConstants.CONTENT_TYPE_LWR}: ${HttpConstants.APPLICATION_JSON}\\n\\\n${HttpConstants.CONTENT_SHA256}: ${digest}`;\n  }\n  async _authHeader(instCert, instPrivateKey, dateStr, payload, digest) {\n    const signature = await Utils.sign(this._signingContent(dateStr, payload, digest), instPrivateKey, 'instance principal federation request');\n    const fingerprint = Utils.fingerprintFromPemCert(instCert);\n    let keyId = `${this._tenantId}/fed-x509/${fingerprint}`;\n    return Utils.signatureHeader(SIGNING_HEADERS, keyId, signature);\n  }\n  async _requestHeaders(instCert, instPrivateKey, payload) {\n    const dateStr = new Date().toUTCString();\n    const digest = Utils.sha256digest(payload);\n    const auth = await this._authHeader(instCert, instPrivateKey, dateStr, payload, digest);\n    return {\n      [HttpConstants.CONTENT_TYPE]: HttpConstants.APPLICATION_JSON,\n      [HttpConstants.CONTENT_SHA256]: digest,\n      [HttpConstants.DATE]: dateStr,\n      [HttpConstants.AUTHORIZATION]: auth\n    };\n  }\n  async getSecurityToken(publicKey, instCert, instPrivateKey, intermediateCerts) {\n    const payload = this._requestPayload(publicKey, instCert, intermediateCerts);\n    const requestHeaders = await this._requestHeaders(instCert, instPrivateKey, payload);\n    const req = {\n      url: this._url,\n      method: HttpConstants.POST,\n      headers: requestHeaders,\n      timeout: this._timeout,\n      payload\n    };\n    let res;\n    try {\n      res = await this._httpClient.request(req);\n    } catch (err) {\n      throw authHttpError('Error getting security token from \\\nauthorization server: ' + err.message, err);\n    }\n    try {\n      res = JSON.parse(res);\n    } catch (err) {\n      throw NoSQLAuthorizationError.badProto(`Error parsing security \\\ntoken response \"${res}\" from authorization server: ${err.message}`, err);\n    }\n    if (typeof res.token !== 'string') {\n      throw NoSQLAuthorizationError.badProto('Missing or invalid \\\nsecurity token in authorization server response ' + util.inspect(res));\n    }\n    return res.token;\n  }\n}\nclass InstancePrincipalProvider {\n  constructor(opt, cfg) {\n    assert(opt != null);\n    if (opt.federationEndpoint != null) {\n      this._initUserFederationEndpoint(opt.federationEndpoint, cfg);\n    }\n    if (!isPosInt32(opt.timeout)) {\n      throw new NoSQLArgumentError('Invalid auth.iam.timeout value', cfg);\n    }\n    this._timeout = opt.timeout;\n    this._refreshAheadMs = opt.securityTokenRefreshAheadMs;\n    assert(isPosInt32OrZero(this._refreshAheadMs));\n    this._expireBeforeMs = opt.securityTokenExpireBeforeMs;\n    assert(isPosInt32OrZero(this._expireBeforeMs));\n    this._httpClient = new HttpClient(null, false);\n  }\n  _initUserFederationEndpoint(ep, cfg) {\n    let url;\n    if (typeof ep === 'string') {\n      try {\n        url = new URL(ep);\n      } catch (err) {\n        throw new NoSQLArgumentError('Invalid auth.iam.federationEndpoint URL', cfg, err);\n      }\n    } else if (ep instanceof URL) {\n      url = ep;\n    } else {\n      throw new NoSQLArgumentError('Invalid auth.iam.federationEndpoint value', cfg);\n    }\n    if (!url.href.startsWith('https://auth.') || url.port || url.pathname && url.pathname !== '/' || url.search) {\n      throw new NoSQLArgumentError('Invalid format of \\\nauth.iam.federationEndpoint, the valid format is \\\nhttps://auth.{region-identifier}.{second-level-domain}', cfg);\n    }\n    this._federationEndpoint = url;\n  }\n  async _getInstanceMetadata(path, desc) {\n    let chkFallback;\n    if (this._metadataUrl == null) {\n      this._metadataUrl = METADATA_SERVICE_BASE_URL;\n      chkFallback = true;\n    }\n    const req = {\n      url: this._metadataUrl + path,\n      method: HttpConstants.GET,\n      headers: {\n        [HttpConstants.AUTHORIZATION]: AUTHORIZATION_HEADER_VALUE\n      },\n      timeout: this._timeout\n    };\n    try {\n      return await this._httpClient.request(req);\n    } catch (err) {\n      if (chkFallback && err instanceof NoSQLServiceError && err.statusCode === HttpConstants.HTTP_NOT_FOUND) {\n        this._metadataUrl = FALLBACK_METADATA_SERVICE_URL;\n        req.url = this._metadataUrl + path;\n        try {\n          return await this._httpClient.request(req);\n        } catch (err2) {\n          throw authHttpError(`Unable to get ${desc} from instance \\\nmetadata ${METADATA_SERVICE_BASE_URL}, error: ${err2.message}`, err2);\n        }\n      } else {\n        throw authHttpError(`Unable to get ${desc} from instance \\\nmetadata ${METADATA_SERVICE_BASE_URL} or fall back to \\\n${FALLBACK_METADATA_SERVICE_URL}, error: ${err.message}`, err);\n      }\n    }\n  }\n\n  /*\n  * Auto detects the endpoint that should be used when talking to\n  * IAM, if no endpoint has been configured already.\n  */\n  async _initFederationEndpoint() {\n    if (this._federationEndpoint != null) {\n      return;\n    }\n    const res = await this._getInstanceMetadata('instance/region', 'federation endpoint');\n    const reg = Region.fromRegionCodeOrId(res);\n    if (reg == null) {\n      throw NoSQLAuthorizationError.illegalState(`Missing or unknown \\\ninstance region: ${res}`);\n    }\n    this._federationEndpoint = `https://auth.${reg.regionId}.${reg.secondLevelDomain}`;\n  }\n  async _refreshInstanceCerts() {\n    this._instCert = await this._getInstanceMetadata('identity/cert.pem', 'instance leaf certificate');\n    const tenantId = Utils.getTenantIdFromInstanceCert(Utils.parseCert(this._instCert));\n    if (this._tenantId == null) {\n      this._tenantId = tenantId;\n    } else if (this._tenantId != tenantId) {\n      throw NoSQLAuthorizationError.illegalState(`Tenant id in \\\ninstance leaf certificate ${tenantId} is different from previously retrieved \\\nor set tenant id ${this._tenantId}`);\n    }\n    const pk = await this._getInstanceMetadata('identity/key.pem', 'instance private key');\n    this._instPrivateKey = Utils.privateKeyFromPEM(pk);\n    const intermediateCert = await this._getInstanceMetadata('identity/intermediate.pem', 'instance intermediate certificate');\n    this._intermediateCerts = [intermediateCert];\n  }\n  async _getSecurityToken() {\n    await this._initFederationEndpoint();\n    await this._refreshInstanceCerts();\n    this._keyPair = await Utils.generateRSAKeyPair();\n    if (this._federationClient == null) {\n      this._federationClient = new X509FederationClient(this._federationEndpoint, this._tenantId, DEFAULT_PURPOSE, this._timeout);\n    }\n    return this._federationClient.getSecurityToken(this._keyPair.publicKey, this._instCert, this._instPrivateKey, this._intermediateCerts);\n  }\n  async _refreshProfileInt() {\n    const val = await this._getSecurityToken();\n    this._token = Utils.parseSecurityToken(val);\n    this._profile = {\n      keyId: 'ST$' + this._token.value,\n      privateKey: this._keyPair.privateKey\n    };\n  }\n  async _refreshProfile(toThrow) {\n    //Avoid multiple concurrent requests for security token.\n    if (this._profilePromise == null) {\n      this._profilePromise = this._refreshProfileInt();\n    }\n    try {\n      await this._profilePromise;\n    } catch (err) {\n      if (toThrow) {\n        throw err;\n      } else {\n        //If error occurred during background refresh, we don't throw\n        //and don't reschedule next refresh.\n        return;\n      }\n    } finally {\n      if (this._refreshTimer != null) {\n        clearTimeout(this._refreshTimer);\n      }\n      this._profilePromise = null;\n    }\n    if (!this._refreshAheadMs) {\n      //only for tests\n      return;\n    }\n    const exp = Utils.getSecurityTokenExpiration(this._token, this._expireBeforeMs);\n    if (!Number.isFinite(exp)) {\n      return;\n    }\n    const refreshInterval = exp - this._refreshAheadMs - Date.now();\n    if (refreshInterval <= 0) {\n      return;\n    }\n    this._refreshTimer = setTimeout(() => this._refreshProfile(), refreshInterval);\n  }\n  isProfileValid(profile) {\n    assert(profile != null);\n    return profile == this._profile && Utils.isSecurityTokenValid(this._token, this._expireBeforeMs);\n  }\n  async getProfile(needRefresh) {\n    if (needRefresh || this._token == null || !Utils.isSecurityTokenValid(this._token, this._expireBeforeMs)) {\n      await this._refreshProfile(true);\n    }\n    return this._profile;\n  }\n  close() {\n    if (this._refreshTimer != null) {\n      clearTimeout(this._refreshTimer);\n      this._refreshTimer = null;\n    }\n  }\n}\nmodule.exports = InstancePrincipalProvider;","map":{"version":3,"names":["assert","require","util","Region","HttpConstants","NoSQLArgumentError","NoSQLServiceError","NoSQLAuthorizationError","isPosInt32","isPosInt32OrZero","HttpClient","Utils","METADATA_SERVICE_BASE_URL","FALLBACK_METADATA_SERVICE_URL","AUTHORIZATION_HEADER_VALUE","DEFAULT_PURPOSE","SIGNING_HEADERS","authHttpError","msg","cause","service","network","X509FederationClient","constructor","federationEndpoint","tenantId","purpose","timeout","_httpClient","_url","URL","_tenantId","_purpose","_timeout","_requestPayload","publicKey","instCert","intermediateCerts","pubKeyEnc","export","type","format","toString","instCertEnc","pemCert2derB64","intermediateCertsEnc","map","cert","JSON","stringify","certificate","intermediateCertificates","_signingContent","dateStr","payload","digest","DATE","REQUEST_TARGET","pathname","CONTENT_LENGTH_LWR","length","CONTENT_TYPE_LWR","APPLICATION_JSON","CONTENT_SHA256","_authHeader","instPrivateKey","signature","sign","fingerprint","fingerprintFromPemCert","keyId","signatureHeader","_requestHeaders","Date","toUTCString","sha256digest","auth","CONTENT_TYPE","AUTHORIZATION","getSecurityToken","requestHeaders","req","url","method","POST","headers","res","request","err","message","parse","badProto","token","inspect","InstancePrincipalProvider","opt","cfg","_initUserFederationEndpoint","_refreshAheadMs","securityTokenRefreshAheadMs","_expireBeforeMs","securityTokenExpireBeforeMs","ep","href","startsWith","port","search","_federationEndpoint","_getInstanceMetadata","path","desc","chkFallback","_metadataUrl","GET","statusCode","HTTP_NOT_FOUND","err2","_initFederationEndpoint","reg","fromRegionCodeOrId","illegalState","regionId","secondLevelDomain","_refreshInstanceCerts","_instCert","getTenantIdFromInstanceCert","parseCert","pk","_instPrivateKey","privateKeyFromPEM","intermediateCert","_intermediateCerts","_getSecurityToken","_keyPair","generateRSAKeyPair","_federationClient","_refreshProfileInt","val","_token","parseSecurityToken","_profile","value","privateKey","_refreshProfile","toThrow","_profilePromise","_refreshTimer","clearTimeout","exp","getSecurityTokenExpiration","Number","isFinite","refreshInterval","now","setTimeout","isProfileValid","profile","isSecurityTokenValid","getProfile","needRefresh","close","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/auth/iam/instance_principal.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\nconst assert = require('assert');\nconst util = require('util');\n\nconst Region = require('../../region');\nconst HttpConstants = require('../../constants').HttpConstants;\nconst NoSQLArgumentError = require('../../error').NoSQLArgumentError;\nconst NoSQLServiceError = require('../../error').NoSQLServiceError;\nconst NoSQLAuthorizationError =\n    require('../../error').NoSQLAuthorizationError;\nconst isPosInt32 = require('../../utils').isPosInt32;\nconst isPosInt32OrZero = require('../../utils').isPosInt32OrZero;\nconst HttpClient = require('../http_client');\nconst Utils = require('./utils');\n\n/* Instance metadata service base URL */\nconst METADATA_SERVICE_BASE_URL = 'http://169.254.169.254/opc/v2/';\nconst FALLBACK_METADATA_SERVICE_URL = 'http://169.254.169.254/opc/v1/';\n\n/* The authorization header need to send to metadata service since V2 */\nconst AUTHORIZATION_HEADER_VALUE = 'Bearer Oracle';\n\n/* The default purpose value in federation requests against IAM */\nconst DEFAULT_PURPOSE = 'DEFAULT';\n\n/* signing headers used to obtain security token */\nconst SIGNING_HEADERS =\n    'date (request-target) content-length content-type x-content-sha256';\n\nfunction authHttpError(msg, cause) {\n    return cause instanceof NoSQLServiceError ?\n        NoSQLAuthorizationError.service(msg, cause) :\n        NoSQLAuthorizationError.network(msg, cause);\n}\n\nclass X509FederationClient {\n\n    constructor(federationEndpoint, tenantId, purpose, timeout) {\n        this._httpClient = new HttpClient();\n        this._url = new URL('/v1/x509', federationEndpoint);\n        this._tenantId = tenantId;\n        this._purpose = purpose;\n        this._timeout = timeout;\n    }\n\n    _requestPayload(publicKey, instCert, intermediateCerts) {\n        const pubKeyEnc = publicKey.export({\n            type: 'spki',\n            format: 'der',\n        }).toString('base64');\n        const instCertEnc = Utils.pemCert2derB64(instCert);\n        const intermediateCertsEnc = intermediateCerts.map(\n            cert => Utils.pemCert2derB64(cert));\n        return JSON.stringify({\n            publicKey: pubKeyEnc,\n            certificate: instCertEnc,\n            purpose: this._purpose,\n            intermediateCertificates: intermediateCertsEnc\n        });\n    }\n\n    _signingContent(dateStr, payload, digest) {\n        return `${HttpConstants.DATE}: ${dateStr}\\n\\\n${HttpConstants.REQUEST_TARGET}: post ${this._url.pathname}\\n\\\n${HttpConstants.CONTENT_LENGTH_LWR}: ${payload.length}\\n\\\n${HttpConstants.CONTENT_TYPE_LWR}: ${HttpConstants.APPLICATION_JSON}\\n\\\n${HttpConstants.CONTENT_SHA256}: ${digest}`;\n    }\n\n    async _authHeader(instCert, instPrivateKey, dateStr, payload, digest) {\n        const signature = await Utils.sign(\n            this._signingContent(dateStr, payload, digest),\n            instPrivateKey,\n            'instance principal federation request');\n        const fingerprint = Utils.fingerprintFromPemCert(instCert);\n        let keyId = `${this._tenantId}/fed-x509/${fingerprint}`;\n        return Utils.signatureHeader(SIGNING_HEADERS, keyId, signature);\n    }\n\n    async _requestHeaders(instCert, instPrivateKey, payload) {\n        const dateStr = new Date().toUTCString();\n        const digest = Utils.sha256digest(payload);\n        const auth = await this._authHeader(instCert, instPrivateKey, dateStr,\n            payload, digest);\n        return {\n            [HttpConstants.CONTENT_TYPE]: HttpConstants.APPLICATION_JSON,\n            [HttpConstants.CONTENT_SHA256]: digest,\n            [HttpConstants.DATE]: dateStr,\n            [HttpConstants.AUTHORIZATION]: auth\n        };\n    }\n\n    async getSecurityToken(publicKey, instCert, instPrivateKey,\n        intermediateCerts) {\n        const payload = this._requestPayload(publicKey, instCert,\n            intermediateCerts);\n        const requestHeaders = await this._requestHeaders(instCert,\n            instPrivateKey, payload);\n\n        const req = {\n            url: this._url,\n            method: HttpConstants.POST,\n            headers: requestHeaders,\n            timeout: this._timeout,\n            payload\n        };\n\n        let res;\n        try {\n            res = await this._httpClient.request(req);\n        } catch(err) {\n            throw authHttpError('Error getting security token from \\\nauthorization server: ' + err.message, err);\n        }\n\n        try {\n            res = JSON.parse(res);\n        } catch(err) {\n            throw NoSQLAuthorizationError.badProto(`Error parsing security \\\ntoken response \"${res}\" from authorization server: ${err.message}`, err);\n        }\n\n        if (typeof res.token !== 'string') {\n            throw NoSQLAuthorizationError.badProto('Missing or invalid \\\nsecurity token in authorization server response ' + util.inspect(res));\n        }\n\n        return res.token;\n    }\n\n}\n\nclass InstancePrincipalProvider {\n\n    constructor(opt, cfg) {\n        assert (opt != null);\n        if (opt.federationEndpoint != null) {\n            this._initUserFederationEndpoint(opt.federationEndpoint, cfg);\n        }\n        if (!isPosInt32(opt.timeout)) {\n            throw new NoSQLArgumentError('Invalid auth.iam.timeout value',\n                cfg);\n        }\n        this._timeout = opt.timeout;\n        this._refreshAheadMs = opt.securityTokenRefreshAheadMs;\n        assert(isPosInt32OrZero(this._refreshAheadMs));\n        this._expireBeforeMs = opt.securityTokenExpireBeforeMs;\n        assert(isPosInt32OrZero(this._expireBeforeMs));\n\n        this._httpClient = new HttpClient(null, false);\n    }\n\n    _initUserFederationEndpoint(ep, cfg) {\n        let url;\n        if (typeof ep === 'string') {\n            try {\n                url = new URL(ep);\n            } catch(err) {\n                throw new NoSQLArgumentError(\n                    'Invalid auth.iam.federationEndpoint URL', cfg, err);\n            }\n        } else if (ep instanceof URL) {\n            url = ep;\n        } else {\n            throw new NoSQLArgumentError(\n                'Invalid auth.iam.federationEndpoint value', cfg);\n        }\n        if (!url.href.startsWith('https://auth.') || url.port ||\n            (url.pathname && url.pathname !== '/') || url.search) {\n            throw new NoSQLArgumentError('Invalid format of \\\nauth.iam.federationEndpoint, the valid format is \\\nhttps://auth.{region-identifier}.{second-level-domain}', cfg);\n        }\n        this._federationEndpoint = url;\n    }\n\n    async _getInstanceMetadata(path, desc) {\n        let chkFallback;\n        if (this._metadataUrl == null) {\n            this._metadataUrl = METADATA_SERVICE_BASE_URL;\n            chkFallback = true;\n        }\n\n        const req = {\n            url: this._metadataUrl + path,\n            method: HttpConstants.GET,\n            headers: {\n                [HttpConstants.AUTHORIZATION]: AUTHORIZATION_HEADER_VALUE\n            },\n            timeout: this._timeout\n        };\n\n        try {\n            return await this._httpClient.request(req);\n        } catch(err) {\n            if (chkFallback && err instanceof NoSQLServiceError &&\n                err.statusCode === HttpConstants.HTTP_NOT_FOUND) {\n                this._metadataUrl = FALLBACK_METADATA_SERVICE_URL;\n                req.url = this._metadataUrl + path;\n                try {\n                    return await this._httpClient.request(req);\n                } catch(err2) {\n                    throw authHttpError(`Unable to get ${desc} from instance \\\nmetadata ${METADATA_SERVICE_BASE_URL}, error: ${err2.message}`, err2);\n                }\n            } else {\n                throw authHttpError(`Unable to get ${desc} from instance \\\nmetadata ${METADATA_SERVICE_BASE_URL} or fall back to \\\n${FALLBACK_METADATA_SERVICE_URL}, error: ${err.message}`, err);\n            }\n        }\n    }\n\n    /*\n    * Auto detects the endpoint that should be used when talking to\n    * IAM, if no endpoint has been configured already.\n    */\n    async _initFederationEndpoint() {\n        if (this._federationEndpoint != null) {\n            return;\n        }\n        const res = await this._getInstanceMetadata('instance/region',\n            'federation endpoint');\n        const reg = Region.fromRegionCodeOrId(res);\n        if (reg == null) {\n            throw NoSQLAuthorizationError.illegalState(`Missing or unknown \\\ninstance region: ${res}`);\n        }\n        this._federationEndpoint =\n            `https://auth.${reg.regionId}.${reg.secondLevelDomain}`;\n    }\n\n    async _refreshInstanceCerts() {\n        this._instCert = await this._getInstanceMetadata(\n            'identity/cert.pem', 'instance leaf certificate');\n        const tenantId = Utils.getTenantIdFromInstanceCert(\n            Utils.parseCert(this._instCert));\n        if (this._tenantId == null) {\n            this._tenantId = tenantId;\n        } else if (this._tenantId != tenantId) {\n            throw NoSQLAuthorizationError.illegalState(`Tenant id in \\\ninstance leaf certificate ${tenantId} is different from previously retrieved \\\nor set tenant id ${this._tenantId}`);\n        }\n\n        const pk = await this._getInstanceMetadata('identity/key.pem',\n            'instance private key');\n        this._instPrivateKey = Utils.privateKeyFromPEM(pk);\n\n        const intermediateCert = await this._getInstanceMetadata(\n            'identity/intermediate.pem', 'instance intermediate certificate');\n        this._intermediateCerts = [ intermediateCert ];\n    }\n\n    async _getSecurityToken() {\n        await this._initFederationEndpoint();\n        await this._refreshInstanceCerts();\n        this._keyPair = await Utils.generateRSAKeyPair();\n        \n        if (this._federationClient == null) {\n            this._federationClient = new X509FederationClient(\n                this._federationEndpoint, this._tenantId, DEFAULT_PURPOSE,\n                this._timeout);\n        }\n\n        return this._federationClient.getSecurityToken(\n            this._keyPair.publicKey, this._instCert, this._instPrivateKey,\n            this._intermediateCerts);\n    }\n\n    async _refreshProfileInt() {\n        const val = await this._getSecurityToken();\n        this._token = Utils.parseSecurityToken(val);\n        this._profile = {\n            keyId: 'ST$' + this._token.value,\n            privateKey: this._keyPair.privateKey\n        };\n    }\n\n    async _refreshProfile(toThrow) {\n        //Avoid multiple concurrent requests for security token.\n        if (this._profilePromise == null) {\n            this._profilePromise = this._refreshProfileInt();\n        }\n        try {\n            await this._profilePromise;\n        } catch(err) {\n            if (toThrow) {\n                throw err;\n            } else {\n                //If error occurred during background refresh, we don't throw\n                //and don't reschedule next refresh.\n                return;\n            }\n        } finally {\n            if (this._refreshTimer != null) {\n                clearTimeout(this._refreshTimer);\n            }\n            this._profilePromise = null;\n        }\n\n        if (!this._refreshAheadMs) { //only for tests\n            return;\n        }\n\n        const exp = Utils.getSecurityTokenExpiration(this._token,\n            this._expireBeforeMs);\n        if (!Number.isFinite(exp)) {\n            return;\n        }\n        \n        const refreshInterval = exp - this._refreshAheadMs - Date.now();\n        if (refreshInterval <= 0) {\n            return;\n        }\n\n        this._refreshTimer = setTimeout(\n            () => this._refreshProfile(), refreshInterval);\n    }\n\n    isProfileValid(profile) {\n        assert(profile != null);\n        return profile == this._profile &&\n            Utils.isSecurityTokenValid(this._token, this._expireBeforeMs);\n    }\n\n    async getProfile(needRefresh) {\n        if (needRefresh || this._token == null ||\n            !Utils.isSecurityTokenValid(this._token, this._expireBeforeMs)) {\n            await this._refreshProfile(true);\n        }\n\n        return this._profile;\n    }\n\n    close() {\n        if (this._refreshTimer != null) {\n            clearTimeout(this._refreshTimer);\n            this._refreshTimer = null;\n        }\n    }\n\n}\n\nmodule.exports = InstancePrincipalProvider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}