{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Protocol = require('./protocol');\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\nconst stringToUTCDate = require('../utils').stringToUTCDate;\nconst CapacityMode = require('../constants').CapacityMode;\nconst OpCode = require('../binary_protocol/constants').OpCode;\nconst Type = require('../binary_protocol/constants').Type;\nconst Fields = require('./constants').Fields;\nconst AddReplicaOp = require('../ops').AddReplicaOp;\nconst DropReplicaOp = require('../ops').DropReplicaOp;\nclass TableRequestSerializer extends Protocol {\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    this.writeHeader(nw, OpCode.TABLE_REQUEST, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n    this.checkWriteStringField(nw, Fields.STATEMENT, req.stmt);\n    const tableLimits = req.opt.tableLimits;\n    if (tableLimits != null) {\n      const mode = tableLimits.mode != null ? tableLimits.mode : CapacityMode.PROVISIONED;\n      nw.startMapField(Fields.LIMITS);\n      if (mode === CapacityMode.PROVISIONED) {\n        nw.writeIntField(Fields.READ_UNITS, tableLimits.readUnits);\n        nw.writeIntField(Fields.WRITE_UNITS, tableLimits.writeUnits);\n      }\n      nw.writeIntField(Fields.STORAGE_GB, tableLimits.storageGB);\n      nw.writeIntField(Fields.LIMITS_MODE, mode.ordinal);\n      nw.endMapField();\n    }\n    if (req.opt.definedtags != null) {\n      nw.writeStringField(Fields.DEFINED_TAGS, JSON.stringify(req.opt.definedTags));\n    }\n    if (req.opt.freeFormTags != null) {\n      nw.writeStringField(Fields.FREE_FORM_TAGS, JSON.stringify(req.opt.freeFormTags));\n    }\n    this.checkWriteStringField(nw, Fields.ETAG, req.opt.matchETag);\n    nw.endMapField();\n    nw.endMap();\n  }\n  static deserialize(nr, req) {\n    return this.deserializeTableResult(nr, req);\n  }\n}\nclass ReplicaOpSerializer extends Protocol {\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    assert(req._op === AddReplicaOp || req._op === DropReplicaOp);\n    const opCode = req._op === AddReplicaOp ? OpCode.ADD_REPLICA : OpCode.DROP_REPLICA;\n    this.writeHeader(nw, opCode, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n    //converted to string during validation\n    nw.writeStringField(Fields.REGION, req.region);\n    if (opCode === OpCode.ADD_REPLICA) {\n      this.checkWriteIntField(Fields.READ_UNITS, req.opt.readUnits);\n      this.checkWriteIntField(Fields.WRITE_UNITS, req.opt.writeUnits);\n    }\n    this.checkWriteStringField(nw, Fields.ETAG, req.opt.matchETag);\n    nw.endMapField();\n    nw.endMap();\n  }\n  static deserialize(nr, req) {\n    return this.deserializeTableResult(nr, req);\n  }\n}\nclass GetTableSerializer extends Protocol {\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    this.writeHeader(nw, OpCode.GET_TABLE, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n    this.checkWriteStringField(nw, Fields.OPERATION_ID, req.opt.operationId);\n    nw.endMapField();\n    nw.endMap();\n  }\n  static deserialize(dr, req) {\n    return this.deserializeTableResult(dr, req);\n  }\n}\nclass TableUsageSerializer extends Protocol {\n  static _deserializeUsageRecord(nr) {\n    const rec = {};\n    Protocol.readMap(nr, field => {\n      switch (field) {\n        case Fields.START:\n          rec.startTime = stringToUTCDate(nr.readString());\n          return true;\n        case Fields.TABLE_USAGE_PERIOD:\n          rec.secondsInPeriod = nr.readInt();\n          return true;\n        case Fields.READ_UNITS:\n          rec.readUnits = nr.readInt();\n          return true;\n        case Fields.WRITE_UNITS:\n          rec.writeUnits = nr.readInt();\n          return true;\n        case Fields.STORAGE_GB:\n          rec.storageGB = nr.readInt();\n          return true;\n        case Fields.READ_THROTTLE_COUNT:\n          rec.readThrottleCount = nr.readInt();\n          return true;\n        case Fields.WRITE_THROTTLE_COUNT:\n          rec.writeThrottleCount = nr.readInt();\n          return true;\n        case Fields.STORAGE_THROTTLE_COUNT:\n          rec.storageThrottleCount = nr.readInt();\n          return true;\n        case Fields.MAX_SHARD_USAGE_PERCENT:\n          rec.maxShardUsagePercent = nr.readInt();\n          return true;\n        default:\n          return false;\n      }\n    });\n    return rec;\n  }\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    this.writeHeader(nw, OpCode.GET_TABLE_USAGE, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n\n    //already converted to Date during validation\n    if (req.opt.startTime) {\n      nw.writeStringField(Fields.START, req.opt.startTime.toISOString());\n    }\n    if (req.opt.endTime) {\n      nw.writeStringField(Fields.END, req.opt.endTime.toISOString());\n    }\n    this.checkWriteIntField(nw, Fields.LIST_MAX_TO_READ, req.opt.limit);\n    this.checkWriteIntField(nw, Fields.LIST_START_INDEX, req.opt.startIndex);\n    nw.endMapField();\n    nw.endMap();\n  }\n  static deserialize(nr, req) {\n    const res = this.deserializeResponse(nr, req, (field, res) => {\n      switch (field) {\n        case Fields.TABLE_NAME:\n          res.tableName = nr.readString();\n          return true;\n        case Fields.TABLE_USAGE:\n          res.usageRecords = this.readArray(nr, this._deserializeUsageRecord);\n          return true;\n        case Fields.LAST_INDEX:\n          res.nextIndex = nr.readInt();\n          return true;\n        default:\n          return false;\n      }\n    });\n    res.usageRecords = res.usageRecords || [];\n    return res;\n  }\n}\nclass ReplicaStatsSerializer extends Protocol {\n  static _deserializeStatsRecord(nr) {\n    const rec = {};\n    Protocol.readMap(nr, field => {\n      switch (field) {\n        case Fields.TIME:\n          rec.collectionTime = this.readDateAsLong(nr);\n          return true;\n        case Fields.REPLICA_LAG:\n          rec.replicaLag = nr.readInt();\n          //If returned -1, replica lag is unknown.\n          if (rec.replicaLag === -1) {\n            rec.replicaLag = undefined;\n          }\n          return true;\n        default:\n          return false;\n      }\n    });\n    return rec;\n  }\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    this.writeHeader(nw, OpCode.GET_REPLICA_STATS, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n    //converted to string during validation\n    this.checkWriteStringField(nw, Fields.REGION, req.opt.region);\n\n    //already converted to Date during validation\n    if (req.opt.startTime) {\n      nw.writeStringField(Fields.START, req.opt.startTime.toISOString());\n    }\n    this.checkWriteIntField(nw, Fields.LIST_MAX_TO_READ, req.opt.limit);\n    nw.endMapField();\n    nw.endMap();\n  }\n  static deserialize(nr, req) {\n    const res = this.deserializeResponse(nr, req, (field, res) => {\n      switch (field) {\n        case Fields.TABLE_NAME:\n          res.tableName = nr.readString();\n          return true;\n        case Fields.REPLICA_STATS:\n          res.statsRecords = {};\n          this.readMap(nr, field => {\n            res.statsRecords[field] = this.readArray(nr, this._deserializeStatsRecord);\n            return true;\n          });\n          return true;\n        case Fields.NEXT_START_TIME:\n          res.nextStartTime = this.readDateAsLong(nr);\n          return true;\n        default:\n          return false;\n      }\n    });\n    res.statsRecords = res.statsRecords || {};\n    return res;\n  }\n}\nclass GetIndexesSerializer extends Protocol {\n  static _deserializeIndexResult(nr) {\n    const res = {};\n    Protocol.readMap(nr, field => {\n      switch (field) {\n        case Fields.NAME:\n          res.indexName = nr.readString();\n          return true;\n        case Fields.FIELDS:\n          //We can't use readArray() here since we need to\n          //populate two arrays.\n          nr.expectType(Type.ARRAY);\n          res.fields = new Array(nr.count);\n          res.fieldTypes = new Array(res.fields.length);\n          for (let i = 0; i < res.fields.length; i++) {\n            nr.next();\n            let name;\n            let type;\n            Protocol.readMap(nr, field => {\n              switch (field) {\n                case Fields.PATH:\n                  name = nr.readString();\n                  return true;\n                case Fields.TYPE:\n                  type = nr.readString();\n                  return true;\n                default:\n                  return false;\n              }\n            });\n            if (!name) {\n              throw new NoSQLProtocolError(`Missing field name in \\\nindex result at position ${i}`);\n            }\n            res.fields[i] = name;\n            res.fieldTypes[i] = type;\n          }\n          return true;\n        default:\n          return false;\n      }\n    });\n    return res;\n  }\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    this.writeHeader(nw, OpCode.GET_INDEXES, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n    this.checkWriteStringField(nw, Fields.INDEX, req.opt.indexName);\n    nw.endMapField();\n    nw.endMap();\n  }\n  static deserialize(nr, req) {\n    const res = this.deserializeResponse(nr, req, (field, res) => {\n      if (field !== Fields.INDEXES) {\n        return false;\n      }\n      res.indexes = this.readArray(nr, this._deserializeIndexResult);\n      return true;\n    });\n    return res.indexes ? res.indexes : [];\n  }\n}\nclass ListTablesSerializer extends Protocol {\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    this.writeHeader(nw, OpCode.LIST_TABLES, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n    this.checkWriteIntField(nw, Fields.LIST_START_INDEX, req.opt.startIndex);\n    this.checkWriteIntField(nw, Fields.LIST_MAX_TO_READ, req.opt.limit);\n    this.checkWriteStringField(nw, Fields.NAMESPACE, req.opt.namespace);\n    nw.endMapField();\n    nw.endMap();\n  }\n  static deserialize(nr, req) {\n    const res = this.deserializeResponse(nr, req, (field, res) => {\n      switch (field) {\n        case Fields.TABLES:\n          res.tables = this.readArray(nr, nr => nr.readString());\n          return true;\n        case Fields.LAST_INDEX:\n          res.lastIndex = nr.readInt();\n          return true;\n        default:\n          return false;\n      }\n    });\n    res.tables = res.tables || [];\n    return res;\n  }\n}\nmodule.exports = {\n  TableRequestSerializer,\n  ReplicaOpSerializer,\n  GetTableSerializer,\n  TableUsageSerializer,\n  ReplicaStatsSerializer,\n  GetIndexesSerializer,\n  ListTablesSerializer\n};","map":{"version":3,"names":["assert","require","Protocol","NoSQLProtocolError","stringToUTCDate","CapacityMode","OpCode","Type","Fields","AddReplicaOp","DropReplicaOp","TableRequestSerializer","serialize","nw","req","serialVersion","startMap","writeHeader","TABLE_REQUEST","startMapField","PAYLOAD","checkWriteStringField","STATEMENT","stmt","tableLimits","opt","mode","PROVISIONED","LIMITS","writeIntField","READ_UNITS","readUnits","WRITE_UNITS","writeUnits","STORAGE_GB","storageGB","LIMITS_MODE","ordinal","endMapField","definedtags","writeStringField","DEFINED_TAGS","JSON","stringify","definedTags","freeFormTags","FREE_FORM_TAGS","ETAG","matchETag","endMap","deserialize","nr","deserializeTableResult","ReplicaOpSerializer","_op","opCode","ADD_REPLICA","DROP_REPLICA","REGION","region","checkWriteIntField","GetTableSerializer","GET_TABLE","OPERATION_ID","operationId","dr","TableUsageSerializer","_deserializeUsageRecord","rec","readMap","field","START","startTime","readString","TABLE_USAGE_PERIOD","secondsInPeriod","readInt","READ_THROTTLE_COUNT","readThrottleCount","WRITE_THROTTLE_COUNT","writeThrottleCount","STORAGE_THROTTLE_COUNT","storageThrottleCount","MAX_SHARD_USAGE_PERCENT","maxShardUsagePercent","GET_TABLE_USAGE","toISOString","endTime","END","LIST_MAX_TO_READ","limit","LIST_START_INDEX","startIndex","res","deserializeResponse","TABLE_NAME","tableName","TABLE_USAGE","usageRecords","readArray","LAST_INDEX","nextIndex","ReplicaStatsSerializer","_deserializeStatsRecord","TIME","collectionTime","readDateAsLong","REPLICA_LAG","replicaLag","undefined","GET_REPLICA_STATS","REPLICA_STATS","statsRecords","NEXT_START_TIME","nextStartTime","GetIndexesSerializer","_deserializeIndexResult","NAME","indexName","FIELDS","expectType","ARRAY","fields","Array","count","fieldTypes","length","i","next","name","type","PATH","TYPE","GET_INDEXES","INDEX","INDEXES","indexes","ListTablesSerializer","LIST_TABLES","NAMESPACE","namespace","TABLES","tables","lastIndex","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/nson_protocol/table.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst Protocol = require('./protocol');\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\nconst stringToUTCDate = require('../utils').stringToUTCDate;\nconst CapacityMode = require('../constants').CapacityMode;\nconst OpCode = require('../binary_protocol/constants').OpCode;\nconst Type = require('../binary_protocol/constants').Type;\nconst Fields = require('./constants').Fields;\nconst AddReplicaOp = require('../ops').AddReplicaOp;\nconst DropReplicaOp = require('../ops').DropReplicaOp;\n\nclass TableRequestSerializer extends Protocol {\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        this.writeHeader(nw, OpCode.TABLE_REQUEST, serialVersion, req);\n        \n        nw.startMapField(Fields.PAYLOAD);\n        this.checkWriteStringField(nw, Fields.STATEMENT, req.stmt);\n\n        const tableLimits = req.opt.tableLimits;\n        if (tableLimits != null) {\n            const mode = (tableLimits.mode != null) ?\n                tableLimits.mode : CapacityMode.PROVISIONED;\n            nw.startMapField(Fields.LIMITS);\n            if (mode === CapacityMode.PROVISIONED) {\n                nw.writeIntField(Fields.READ_UNITS, tableLimits.readUnits);\n                nw.writeIntField(Fields.WRITE_UNITS, tableLimits.writeUnits);\n            }\n            nw.writeIntField(Fields.STORAGE_GB, tableLimits.storageGB);\n            nw.writeIntField(Fields.LIMITS_MODE, mode.ordinal);\n            nw.endMapField();\n        }\n\n        if (req.opt.definedtags != null) {\n            nw.writeStringField(Fields.DEFINED_TAGS,\n                JSON.stringify(req.opt.definedTags));\n        }\n        if (req.opt.freeFormTags != null) {\n            nw.writeStringField(Fields.FREE_FORM_TAGS,\n                JSON.stringify(req.opt.freeFormTags));\n        }\n\n        this.checkWriteStringField(nw, Fields.ETAG, req.opt.matchETag);\n\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static deserialize(nr, req) {\n        return this.deserializeTableResult(nr, req);\n    }\n}\n\nclass ReplicaOpSerializer extends Protocol {\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        assert(req._op === AddReplicaOp || req._op === DropReplicaOp);\n        const opCode = req._op === AddReplicaOp ?\n            OpCode.ADD_REPLICA : OpCode.DROP_REPLICA;\n        this.writeHeader(nw, opCode, serialVersion, req);\n        \n        nw.startMapField(Fields.PAYLOAD);\n        //converted to string during validation\n        nw.writeStringField(Fields.REGION, req.region);\n        if (opCode === OpCode.ADD_REPLICA) {\n            this.checkWriteIntField(Fields.READ_UNITS, req.opt.readUnits);\n            this.checkWriteIntField(Fields.WRITE_UNITS, req.opt.writeUnits);    \n        }\n        this.checkWriteStringField(nw, Fields.ETAG, req.opt.matchETag);\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static deserialize(nr, req) {\n        return this.deserializeTableResult(nr, req);\n    }\n\n}\n\nclass GetTableSerializer extends Protocol {\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        this.writeHeader(nw, OpCode.GET_TABLE, serialVersion, req);\n        nw.startMapField(Fields.PAYLOAD);\n        this.checkWriteStringField(nw, Fields.OPERATION_ID,\n            req.opt.operationId);\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static deserialize(dr, req) {\n        return this.deserializeTableResult(dr, req);\n    }\n\n}\n\nclass TableUsageSerializer extends Protocol {\n\n    static _deserializeUsageRecord(nr) {\n        const rec = {};\n\n        Protocol.readMap(nr, (field) => {\n            switch (field)\n            {\n            case Fields.START:\n                rec.startTime = stringToUTCDate(nr.readString());\n                return true;\n            case Fields.TABLE_USAGE_PERIOD:\n                rec.secondsInPeriod = nr.readInt();\n                return true;\n            case Fields.READ_UNITS:\n                rec.readUnits = nr.readInt();\n                return true;\n            case Fields.WRITE_UNITS:\n                rec.writeUnits = nr.readInt();\n                return true;\n            case Fields.STORAGE_GB:\n                rec.storageGB = nr.readInt();\n                return true;\n            case Fields.READ_THROTTLE_COUNT:\n                rec.readThrottleCount = nr.readInt();\n                return true;\n            case Fields.WRITE_THROTTLE_COUNT:\n                rec.writeThrottleCount = nr.readInt();\n                return true;\n            case Fields.STORAGE_THROTTLE_COUNT:\n                rec.storageThrottleCount = nr.readInt();\n                return true;\n            case Fields.MAX_SHARD_USAGE_PERCENT:\n                rec.maxShardUsagePercent = nr.readInt();\n                return true;\n            default:\n                return false;\n            }\n        });\n\n        return rec;\n    }\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        this.writeHeader(nw, OpCode.GET_TABLE_USAGE, serialVersion, req);\n        nw.startMapField(Fields.PAYLOAD);\n\n        //already converted to Date during validation\n        if (req.opt.startTime) {\n            nw.writeStringField(Fields.START,\n                req.opt.startTime.toISOString());\n        }\n        if (req.opt.endTime) {\n            nw.writeStringField(Fields.END, req.opt.endTime.toISOString());\n        }\n        this.checkWriteIntField(nw, Fields.LIST_MAX_TO_READ, req.opt.limit);\n        this.checkWriteIntField(nw, Fields.LIST_START_INDEX,\n            req.opt.startIndex);\n\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static deserialize(nr, req) {\n        const res = this.deserializeResponse(nr, req, (field, res) => {\n            switch (field) {\n            case Fields.TABLE_NAME:\n                res.tableName = nr.readString();\n                return true;\n            case Fields.TABLE_USAGE:\n                res.usageRecords = this.readArray(nr,\n                    this._deserializeUsageRecord);\n                return true;\n            case Fields.LAST_INDEX:\n                res.nextIndex = nr.readInt();\n                return true;\n            default:\n                return false;\n            }\n        });\n\n        res.usageRecords = res.usageRecords || [];\n        return res;\n    }\n\n}\n\nclass ReplicaStatsSerializer extends Protocol {\n\n    static _deserializeStatsRecord(nr) {\n        const rec = {};\n        Protocol.readMap(nr, field => {\n            switch (field)\n            {\n            case Fields.TIME:\n                rec.collectionTime = this.readDateAsLong(nr);\n                return true;\n            case Fields.REPLICA_LAG:\n                rec.replicaLag = nr.readInt();\n                //If returned -1, replica lag is unknown.\n                if (rec.replicaLag === -1) {\n                    rec.replicaLag = undefined;\n                }\n                return true;\n            default:\n                return false;\n            }\n        });\n        return rec;\n    }\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        this.writeHeader(nw, OpCode.GET_REPLICA_STATS, serialVersion, req);\n        nw.startMapField(Fields.PAYLOAD);\n        //converted to string during validation\n        this.checkWriteStringField(nw, Fields.REGION, req.opt.region);\n\n        //already converted to Date during validation\n        if (req.opt.startTime) {\n            nw.writeStringField(Fields.START,\n                req.opt.startTime.toISOString());\n        }\n\n        this.checkWriteIntField(nw, Fields.LIST_MAX_TO_READ, req.opt.limit);\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static deserialize(nr, req) {\n        const res = this.deserializeResponse(nr, req, (field, res) => {\n            switch (field) {\n            case Fields.TABLE_NAME:\n                res.tableName = nr.readString();\n                return true;\n            case Fields.REPLICA_STATS:\n                res.statsRecords = {};\n                this.readMap(nr, field => {\n                    res.statsRecords[field] = this.readArray(nr,\n                        this._deserializeStatsRecord);\n                    return true;\n                });\n                return true;\n            case Fields.NEXT_START_TIME:\n                res.nextStartTime = this.readDateAsLong(nr);\n                return true;\n            default:\n                return false;\n            }\n        });\n\n        res.statsRecords = res.statsRecords || {};\n        return res;\n    }\n}\n\nclass GetIndexesSerializer extends Protocol {\n\n    static _deserializeIndexResult(nr) {\n        const res = {};\n        Protocol.readMap(nr, field => {\n            switch (field) {\n            case Fields.NAME:\n                res.indexName = nr.readString();\n                return true;\n            case Fields.FIELDS:\n                //We can't use readArray() here since we need to\n                //populate two arrays.\n                nr.expectType(Type.ARRAY);\n                res.fields = new Array(nr.count);\n                res.fieldTypes = new Array(res.fields.length);\n                for (let i = 0; i < res.fields.length; i++) {\n                    nr.next();\n                    let name;\n                    let type;\n                    Protocol.readMap(nr, field => {\n                        switch (field) {\n                        case Fields.PATH:\n                            name = nr.readString();\n                            return true;\n                        case Fields.TYPE:\n                            type = nr.readString();\n                            return true;\n                        default:\n                            return false;\n                        }\n                    });\n                    if (!name) {\n                        throw new NoSQLProtocolError(`Missing field name in \\\nindex result at position ${i}`);\n                    }\n                    res.fields[i] = name;\n                    res.fieldTypes[i] = type;\n                }\n                return true;\n            default:\n                return false;\n            }\n        });\n        \n        return res;\n    }\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        this.writeHeader(nw, OpCode.GET_INDEXES, serialVersion, req);\n        nw.startMapField(Fields.PAYLOAD);\n        this.checkWriteStringField(nw, Fields.INDEX, req.opt.indexName);\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static deserialize(nr, req) {\n        const res = this.deserializeResponse(nr, req, (field, res) => {\n            if (field !== Fields.INDEXES) {\n                return false;\n            }\n            res.indexes = this.readArray(nr, this._deserializeIndexResult);\n            return true;\n        });\n\n        return res.indexes ? res.indexes : [];\n    }\n\n}\n\nclass ListTablesSerializer extends Protocol {\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        this.writeHeader(nw, OpCode.LIST_TABLES, serialVersion, req);\n        nw.startMapField(Fields.PAYLOAD);\n        this.checkWriteIntField(nw, Fields.LIST_START_INDEX,\n            req.opt.startIndex);\n        this.checkWriteIntField(nw, Fields.LIST_MAX_TO_READ, req.opt.limit);\n        this.checkWriteStringField(nw, Fields.NAMESPACE, req.opt.namespace);\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static deserialize(nr, req) {\n        const res = this.deserializeResponse(nr, req, (field, res) => {\n            switch (field) {\n            case Fields.TABLES:\n                res.tables = this.readArray(nr, nr => nr.readString());\n                return true;\n            case Fields.LAST_INDEX:\n                res.lastIndex = nr.readInt();\n                return true;\n            default:\n                return false;\n            }\n        });\n\n        res.tables = res.tables || [];\n        return res;\n    }\n\n}\n\nmodule.exports = {\n    TableRequestSerializer,\n    ReplicaOpSerializer,\n    GetTableSerializer,\n    TableUsageSerializer,\n    ReplicaStatsSerializer,\n    GetIndexesSerializer,\n    ListTablesSerializer,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}