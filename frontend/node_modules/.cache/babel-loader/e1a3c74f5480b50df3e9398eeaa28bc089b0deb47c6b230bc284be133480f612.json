{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst OpCode = require('../binary_protocol/constants').OpCode;\nconst Protocol = require('./protocol');\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\nconst QUERY_V4 = require('../ops').QueryOp.QUERY_V4;\nconst DataReader = require('../binary_protocol/reader');\nconst ccAsObj = require('../ops').ccAsObj;\nconst Fields = require('./constants').Fields;\nconst Type = require('../binary_protocol/constants').Type;\nconst BinaryPrepareSerializer = require('../binary_protocol/serializers').PrepareSerializer;\nconst BinaryQuerySerializer = require('../binary_protocol/serializers').QuerySerializer;\nclass PrepareSerializer extends Protocol {\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    this.writeHeader(nw, OpCode.PREPARE, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n    nw.writeIntField(Fields.QUERY_VERSION, req._queryVersion);\n    nw.writeStringField(Fields.STATEMENT, req.stmt);\n    this.checkWriteBooleanField(nw, Fields.GET_QUERY_PLAN, req.opt.getQueryPlan);\n    this.checkWriteBooleanField(nw, Fields.GET_QUERY_SCHEMA, req.opt.getResultSchema);\n    nw.endMapField();\n    nw.endMap();\n  }\n  static _deserializeDriverPlanInfo(buf, res) {\n    const dr = new DataReader(buf);\n    return BinaryPrepareSerializer._deserializeDriverPlanInfo(dr, res);\n  }\n\n  //topology info is not always sent\n  static _processPrepStmtField(nr, field, res) {\n    switch (field) {\n      case Fields.PREPARED_QUERY:\n        res._prepStmt = nr.readBinary();\n        return true;\n      case Fields.DRIVER_QUERY_PLAN:\n        this._deserializeDriverPlanInfo(nr.readBinary(), res);\n        return true;\n      case Fields.TABLE_NAME:\n        res._tableName = nr.readString();\n        return true;\n      case Fields.NAMESPACE:\n        res._namespace = nr.readString();\n        return true;\n      case Fields.QUERY_PLAN_STRING:\n        res._queryPlanStr = nr.readString();\n        return true;\n      case Fields.QUERY_RESULT_SCHEMA:\n        res._schema = nr.readString();\n        return true;\n      case Fields.QUERY_OPERATION:\n        res._opCode = nr.readInt();\n        return true;\n      //These fields are for query V3 and below, for query V4 the topology\n      //is read in Protocol.deserializeResponse().\n      case Fields.PROXY_TOPO_SEQNUM:\n        res._topoInfo = res._topoInfo || {};\n        res._topoInfo.seqNum = nr.readInt();\n        return true;\n      case Fields.SHARD_IDS:\n        res._topoInfo = res._topoInfo || {};\n        res._topoInfo.shardIds = this.readArray(nr, nr => nr.readInt());\n        return true;\n      default:\n        return false;\n    }\n  }\n  static _validatePrepStmt(ps) {\n    if (ps == null) {\n      throw new NoSQLProtocolError('Missing prepared query information');\n    }\n    if (ps._prepStmt == null) {\n      throw new NoSQLProtocolError('Missing prepared statement');\n    }\n    if (ps._topoInfo != null) {\n      this.validateTopologyInfo(ps._topoInfo);\n    }\n    //Todo: put anything else here that we need to check.\n  }\n  static deserialize(nr, req) {\n    const res = {\n      _sql: req.stmt\n    };\n    this.deserializeResponse(nr, req, (field, res) => this._processPrepStmtField(nr, field, res), res);\n    this._validatePrepStmt(res);\n    return res;\n  }\n}\nclass QuerySerializer extends Protocol {\n  static _writeVirtualScan(nw, vs) {\n    nw.startMapField(Fields.VIRTUAL_SCAN);\n    nw.writeIntField(Fields.VIRTUAL_SCAN_SID, vs.sid);\n    nw.writeIntField(Fields.VIRTUAL_SCAN_PID, vs.pid);\n    if (!vs.isInfoSent) {\n      nw.writeBinaryField(Fields.VIRTUAL_SCAN_PRIM_KEY, vs.primKey);\n      nw.writeBinaryField(Fields.VIRTUAL_SCAN_SEC_KEY, vs.secKey);\n      nw.writeBooleanField(Fields.VIRTUAL_SCAN_MOVE_AFTER, vs.moveAfterResumeKey);\n      nw.writeBinaryField(Fields.VIRTUAL_SCAN_JOIN_DESC_RESUME_KEY, vs.descResumeKey);\n      if (vs.joinPathTables) {\n        nw.writeFieldName(Fields.VIRTUAL_SCAN_JOIN_PATH_TABLES);\n        this.writeFieldValue(nw, vs.joinPathTables, {});\n      }\n      nw.writeBinaryField(Fields.VIRTUAL_SCAN_JOIN_PATH_KEY, vs.joinPathKey);\n      nw.writeBinaryField(Fields.VIRTUAL_SCAN_JOIN_PATH_SEC_KEY, vs.joinPathSecKey);\n      nw.writeBooleanField(Fields.VIRTUAL_SCAN_JOIN_PATH_MATCHED, vs.joinPathMatched);\n    }\n    nw.endMapField();\n  }\n  static _readVirtualScan(nr) {\n    const vs = {};\n    Protocol.readMap(nr, field => {\n      switch (field) {\n        case Fields.VIRTUAL_SCAN_SID:\n          vs.sid = nr.readInt();\n          return true;\n        case Fields.VIRTUAL_SCAN_PID:\n          vs.pid = nr.readInt();\n          return true;\n        case Fields.VIRTUAL_SCAN_PRIM_KEY:\n          vs.primKey = nr.readBinary();\n          return true;\n        case Fields.VIRTUAL_SCAN_SEC_KEY:\n          vs.secKey = nr.readBinary();\n          return true;\n        case Fields.VIRTUAL_SCAN_MOVE_AFTER:\n          vs.moveAfterResumeKey = nr.readBoolean();\n          return true;\n        case Fields.VIRTUAL_SCAN_JOIN_DESC_RESUME_KEY:\n          vs.descResumeKey = nr.readBinary();\n          return true;\n        case Fields.VIRTUAL_SCAN_JOIN_PATH_TABLES:\n          vs.joinPathTables = this.readArray(nr, nr => nr.readInt());\n          return true;\n        case Fields.VIRTUAL_SCAN_JOIN_PATH_KEY:\n          vs.joinPathKey = nr.readBinary();\n          return true;\n        case Fields.VIRTUAL_SCAN_JOIN_PATH_SEC_KEY:\n          vs.joinPathSecKey = nr.readBinary();\n          return true;\n        case Fields.VIRTUAL_SCAN_JOIN_PATH_MATCHED:\n          vs.joinPathMatched = nr.readBoolean();\n          return true;\n        default:\n          return false;\n      }\n    });\n    return vs;\n  }\n  static _readQueryTraces(nr) {\n    const traces = [];\n    nr.expectType(Type.ARRAY);\n    let cnt = nr.count;\n    if (cnt % 2 !== 0) {\n      throw new NoSQLProtocolError(`Invalid size of query traces array: ${cnt}`);\n    }\n    cnt /= 2;\n    for (let i = 0; i < cnt; i++) {\n      nr.next();\n      const name = nr.readString();\n      nr.next();\n      const val = nr.readString();\n      traces.push([name, val]);\n    }\n    return traces;\n  }\n  static serialize(nw, req, serialVersion) {\n    nw.startMap();\n    this.writeHeader(nw, OpCode.QUERY, serialVersion, req);\n    nw.startMapField(Fields.PAYLOAD);\n    this.writeConsistency(nw, req.opt.consistency);\n    if (req.opt.durability != null) {\n      this.writeDurability(nw, req.opt.durability);\n    }\n    this.checkWriteIntField(nw, Fields.MAX_READ_KB, req.opt.maxReadKB);\n    this.checkWriteIntField(nw, Fields.MAX_WRITE_KB, req.opt.maxWriteKB);\n    this.checkWriteIntField(nw, Fields.NUMBER_LIMIT, req.opt.limit);\n    this.checkWriteIntField(nw, Fields.TRACE_LEVEL, req.opt.traceLevel);\n    this.checkWriteLongField(nw, Fields.SERVER_MEMORY_CONSUMPTION, req.opt._maxServerMemory);\n    if (req.opt.traceLevel > 0) {\n      nw.writeBooleanField(Fields.TRACE_TO_LOG_FILES, req.opt.traceToLogFiles);\n      const batchNum = req.opt.continuationKey && req.opt.continuationKey._batchNum ? req.opt.continuationKey._batchNum : 0;\n      //It seems that Java driver is using 1-based counter.\n      nw.writeIntField(Fields.BATCH_COUNTER, batchNum + 1);\n    }\n    nw.writeIntField(Fields.QUERY_VERSION, req._queryVersion);\n    if (req.prepStmt != null) {\n      nw.writeBooleanField(Fields.IS_PREPARED, true);\n      nw.writeBooleanField(Fields.IS_SIMPLE_QUERY, req.prepStmt._queryPlan == null);\n      nw.writeBinaryField(Fields.PREPARED_QUERY, req.prepStmt._prepStmt);\n      if (req.prepStmt._bindings != null) {\n        const ents = Object.entries(req.prepStmt._bindings);\n        nw.startArrayField(Fields.BIND_VARIABLES);\n        for (let [key, val] of ents) {\n          nw.startMap();\n          nw.writeStringField(Fields.NAME, key);\n          this.writeValue(nw, val, req.opt);\n          nw.endMap();\n        }\n        nw.endArrayField();\n      }\n\n      //For query V3 we write topology seqNum in the payload.\n      if (req._queryVersion < QUERY_V4 && req._topoInfo != null) {\n        nw.writeIntField(Fields.TOPO_SEQ_NUM, req.prepStmt._topoInfo.seqNum);\n      }\n    } else {\n      nw.writeStringField(Fields.STATEMENT, req.stmt);\n    }\n    if (req.opt.continuationKey && !req.opt.continuationKey[ccAsObj]) {\n      nw.writeBinaryField(Fields.CONTINUATION_KEY, req.opt.continuationKey);\n    }\n    this.writeMathContext(nw, req.opt);\n    this.checkWriteIntField(nw, Fields.SHARD_ID, req._shardId);\n    if (req._queryVersion >= QUERY_V4) {\n      this.checkWriteStringField(nw, Fields.QUERY_ID, req.opt.queryId);\n      if (req._vScan != null) {\n        this._writeVirtualScan(nw, req._vScan);\n      }\n    }\n    nw.endMapField();\n    nw.endMap();\n  }\n  static _deserializeSortPhase1Results(buf, res) {\n    const dr = new DataReader(buf);\n    return BinaryQuerySerializer._deserializeSortPhase1Results(dr, res);\n  }\n  static deserialize(nr, req) {\n    let prepStmt;\n    const res = this.deserializeResponse(nr, req, (field, res) => {\n      switch (field) {\n        case Fields.QUERY_RESULTS:\n          res.rows = this.readArray(nr, this.readRow, req.opt);\n          return true;\n        case Fields.CONTINUATION_KEY:\n          res.continuationKey = nr.readBinary();\n          return true;\n        case Fields.SORT_PHASE1_RESULTS:\n          this._deserializeSortPhase1Results(nr.readBinary(), res);\n          return true;\n        case Fields.REACHED_LIMIT:\n          res._reachedLimit = nr.readBoolean();\n          return true;\n        case Fields.VIRTUAL_SCANS:\n          res._vScans = this.readArray(nr, this._readVirtualScan);\n          return true;\n        case Fields.QUERY_BATCH_TRACES:\n          res.queryTraces = this._readQueryTraces(nr);\n          return true;\n        default:\n          prepStmt = prepStmt || {};\n          return PrepareSerializer._processPrepStmtField(nr, field, prepStmt);\n      }\n    });\n\n    //If the QueryRequest was not initially prepared, the prepared\n    //statement created at the proxy is returned back along with the\n    //query results, so that the preparation does not need to be done\n    //during each query batch.\n    if (req.prepStmt == null) {\n      PrepareSerializer._validatePrepStmt(prepStmt);\n      prepStmt._sql = req.stmt;\n      prepStmt.consumedCapacity = res.consumedCapacity;\n      res._prepStmt = prepStmt;\n    } else if (prepStmt != null && prepStmt._topoInfo != null) {\n      //We received updated topology info. This should happen only for\n      //query V3 and below.\n      this.validateTopologyInfo(prepStmt._topoInfo);\n      res._topoInfo = prepStmt._topoInfo;\n    }\n    res.rows = res.rows || []; //empty array if no results\n    return res;\n  }\n}\nmodule.exports = {\n  PrepareSerializer,\n  QuerySerializer\n};","map":{"version":3,"names":["OpCode","require","Protocol","NoSQLProtocolError","QUERY_V4","QueryOp","DataReader","ccAsObj","Fields","Type","BinaryPrepareSerializer","PrepareSerializer","BinaryQuerySerializer","QuerySerializer","serialize","nw","req","serialVersion","startMap","writeHeader","PREPARE","startMapField","PAYLOAD","writeIntField","QUERY_VERSION","_queryVersion","writeStringField","STATEMENT","stmt","checkWriteBooleanField","GET_QUERY_PLAN","opt","getQueryPlan","GET_QUERY_SCHEMA","getResultSchema","endMapField","endMap","_deserializeDriverPlanInfo","buf","res","dr","_processPrepStmtField","nr","field","PREPARED_QUERY","_prepStmt","readBinary","DRIVER_QUERY_PLAN","TABLE_NAME","_tableName","readString","NAMESPACE","_namespace","QUERY_PLAN_STRING","_queryPlanStr","QUERY_RESULT_SCHEMA","_schema","QUERY_OPERATION","_opCode","readInt","PROXY_TOPO_SEQNUM","_topoInfo","seqNum","SHARD_IDS","shardIds","readArray","_validatePrepStmt","ps","validateTopologyInfo","deserialize","_sql","deserializeResponse","_writeVirtualScan","vs","VIRTUAL_SCAN","VIRTUAL_SCAN_SID","sid","VIRTUAL_SCAN_PID","pid","isInfoSent","writeBinaryField","VIRTUAL_SCAN_PRIM_KEY","primKey","VIRTUAL_SCAN_SEC_KEY","secKey","writeBooleanField","VIRTUAL_SCAN_MOVE_AFTER","moveAfterResumeKey","VIRTUAL_SCAN_JOIN_DESC_RESUME_KEY","descResumeKey","joinPathTables","writeFieldName","VIRTUAL_SCAN_JOIN_PATH_TABLES","writeFieldValue","VIRTUAL_SCAN_JOIN_PATH_KEY","joinPathKey","VIRTUAL_SCAN_JOIN_PATH_SEC_KEY","joinPathSecKey","VIRTUAL_SCAN_JOIN_PATH_MATCHED","joinPathMatched","_readVirtualScan","readMap","readBoolean","_readQueryTraces","traces","expectType","ARRAY","cnt","count","i","next","name","val","push","QUERY","writeConsistency","consistency","durability","writeDurability","checkWriteIntField","MAX_READ_KB","maxReadKB","MAX_WRITE_KB","maxWriteKB","NUMBER_LIMIT","limit","TRACE_LEVEL","traceLevel","checkWriteLongField","SERVER_MEMORY_CONSUMPTION","_maxServerMemory","TRACE_TO_LOG_FILES","traceToLogFiles","batchNum","continuationKey","_batchNum","BATCH_COUNTER","prepStmt","IS_PREPARED","IS_SIMPLE_QUERY","_queryPlan","_bindings","ents","Object","entries","startArrayField","BIND_VARIABLES","key","NAME","writeValue","endArrayField","TOPO_SEQ_NUM","CONTINUATION_KEY","writeMathContext","SHARD_ID","_shardId","checkWriteStringField","QUERY_ID","queryId","_vScan","_deserializeSortPhase1Results","QUERY_RESULTS","rows","readRow","SORT_PHASE1_RESULTS","REACHED_LIMIT","_reachedLimit","VIRTUAL_SCANS","_vScans","QUERY_BATCH_TRACES","queryTraces","consumedCapacity","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/nson_protocol/query.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst OpCode = require('../binary_protocol/constants').OpCode;\nconst Protocol = require('./protocol');\nconst NoSQLProtocolError = require('../error').NoSQLProtocolError;\nconst QUERY_V4 = require('../ops').QueryOp.QUERY_V4;\nconst DataReader = require('../binary_protocol/reader');\nconst ccAsObj = require('../ops').ccAsObj;\nconst Fields = require('./constants').Fields;\nconst Type = require('../binary_protocol/constants').Type;\nconst BinaryPrepareSerializer = require('../binary_protocol/serializers')\n    .PrepareSerializer;\nconst BinaryQuerySerializer = require('../binary_protocol/serializers')\n    .QuerySerializer;\n\nclass PrepareSerializer extends Protocol {\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        this.writeHeader(nw, OpCode.PREPARE, serialVersion, req);\n        nw.startMapField(Fields.PAYLOAD);\n        nw.writeIntField(Fields.QUERY_VERSION, req._queryVersion);\n        nw.writeStringField(Fields.STATEMENT, req.stmt);\n        this.checkWriteBooleanField(nw, Fields.GET_QUERY_PLAN,\n            req.opt.getQueryPlan);\n        this.checkWriteBooleanField(nw, Fields.GET_QUERY_SCHEMA,\n            req.opt.getResultSchema);\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static _deserializeDriverPlanInfo(buf, res) {\n        const dr = new DataReader(buf);\n        return BinaryPrepareSerializer._deserializeDriverPlanInfo(dr, res);\n    }\n\n    //topology info is not always sent\n    static _processPrepStmtField(nr, field, res) {\n        switch (field) {\n        case Fields.PREPARED_QUERY:\n            res._prepStmt = nr.readBinary();\n            return true;\n        case Fields.DRIVER_QUERY_PLAN:\n            this._deserializeDriverPlanInfo(nr.readBinary(), res);\n            return true;\n        case Fields.TABLE_NAME:\n            res._tableName = nr.readString();\n            return true;\n        case Fields.NAMESPACE:\n            res._namespace = nr.readString();\n            return true;\n        case Fields.QUERY_PLAN_STRING:\n            res._queryPlanStr = nr.readString();\n            return true;\n        case Fields.QUERY_RESULT_SCHEMA:\n            res._schema = nr.readString();\n            return true;\n        case Fields.QUERY_OPERATION:\n            res._opCode = nr.readInt();\n            return true;\n        //These fields are for query V3 and below, for query V4 the topology\n        //is read in Protocol.deserializeResponse().\n        case Fields.PROXY_TOPO_SEQNUM:\n            res._topoInfo = res._topoInfo || {};\n            res._topoInfo.seqNum = nr.readInt();\n            return true;\n        case Fields.SHARD_IDS:\n            res._topoInfo = res._topoInfo || {};\n            res._topoInfo.shardIds = this.readArray(nr,\n                nr => nr.readInt());\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    static _validatePrepStmt(ps) {\n        if (ps == null) {\n            throw new NoSQLProtocolError(\n                'Missing prepared query information');\n        }\n        if (ps._prepStmt == null) {\n            throw new NoSQLProtocolError('Missing prepared statement');\n        }\n        if (ps._topoInfo != null) {\n            this.validateTopologyInfo(ps._topoInfo);\n        }\n        //Todo: put anything else here that we need to check.\n    }\n    \n    static deserialize(nr, req) {\n        const res = {\n            _sql: req.stmt\n        };\n\n        this.deserializeResponse(nr, req, (field, res) =>\n            this._processPrepStmtField(nr, field, res), res);\n        this._validatePrepStmt(res);\n        return res;\n    }\n\n}\n\nclass QuerySerializer extends Protocol {\n\n    static _writeVirtualScan(nw, vs) {\n        nw.startMapField(Fields.VIRTUAL_SCAN);\n        nw.writeIntField(Fields.VIRTUAL_SCAN_SID, vs.sid);\n        nw.writeIntField(Fields.VIRTUAL_SCAN_PID, vs.pid);\n        if (!vs.isInfoSent) {\n            nw.writeBinaryField(Fields.VIRTUAL_SCAN_PRIM_KEY, vs.primKey);\n            nw.writeBinaryField(Fields.VIRTUAL_SCAN_SEC_KEY, vs.secKey);\n            nw.writeBooleanField(Fields.VIRTUAL_SCAN_MOVE_AFTER,\n                vs.moveAfterResumeKey);\n\n            nw.writeBinaryField(Fields.VIRTUAL_SCAN_JOIN_DESC_RESUME_KEY,\n                vs.descResumeKey);\n            if (vs.joinPathTables) {\n                nw.writeFieldName(Fields.VIRTUAL_SCAN_JOIN_PATH_TABLES);\n                this.writeFieldValue(nw, vs.joinPathTables, {});\n            }\n            nw.writeBinaryField(Fields.VIRTUAL_SCAN_JOIN_PATH_KEY,\n                vs.joinPathKey);\n            nw.writeBinaryField(Fields.VIRTUAL_SCAN_JOIN_PATH_SEC_KEY,\n                vs.joinPathSecKey);\n            nw.writeBooleanField(Fields.VIRTUAL_SCAN_JOIN_PATH_MATCHED,\n                vs.joinPathMatched);\n        }\n        nw.endMapField();\n    }\n\n    static _readVirtualScan(nr) {\n        const vs = {};\n\n        Protocol.readMap(nr, field => {\n            switch (field) {\n            case Fields.VIRTUAL_SCAN_SID:\n                vs.sid = nr.readInt();\n                return true;\n            case Fields.VIRTUAL_SCAN_PID:\n                vs.pid = nr.readInt();\n                return true;\n            case Fields.VIRTUAL_SCAN_PRIM_KEY:\n                vs.primKey = nr.readBinary();\n                return true;\n            case Fields.VIRTUAL_SCAN_SEC_KEY:\n                vs.secKey = nr.readBinary();\n                return true;\n            case Fields.VIRTUAL_SCAN_MOVE_AFTER:\n                vs.moveAfterResumeKey = nr.readBoolean();\n                return true;\n            case Fields.VIRTUAL_SCAN_JOIN_DESC_RESUME_KEY:\n                vs.descResumeKey = nr.readBinary();\n                return true;\n            case Fields.VIRTUAL_SCAN_JOIN_PATH_TABLES:\n                vs.joinPathTables = this.readArray(nr, nr => nr.readInt());\n                return true;\n            case Fields.VIRTUAL_SCAN_JOIN_PATH_KEY:\n                vs.joinPathKey = nr.readBinary();\n                return true;\n            case Fields.VIRTUAL_SCAN_JOIN_PATH_SEC_KEY:\n                vs.joinPathSecKey = nr.readBinary();\n                return true;\n            case Fields.VIRTUAL_SCAN_JOIN_PATH_MATCHED:\n                vs.joinPathMatched = nr.readBoolean();\n                return true; \n            default:\n                return false;\n            }\n        });\n\n        return vs;\n    }\n\n    static _readQueryTraces(nr) {\n        const traces = [];\n        nr.expectType(Type.ARRAY);\n\n        let cnt = nr.count;\n        if (cnt % 2 !== 0) {\n            throw new NoSQLProtocolError(\n                `Invalid size of query traces array: ${cnt}`);\n        }\n        cnt /= 2;\n\n        for(let i = 0; i < cnt; i++) {\n            nr.next();\n            const name = nr.readString();\n            nr.next();\n            const val = nr.readString();\n            traces.push([name, val]);\n        }\n        \n        return traces;\n    }\n\n    static serialize(nw, req, serialVersion) {\n        nw.startMap();\n        this.writeHeader(nw, OpCode.QUERY, serialVersion, req);\n        nw.startMapField(Fields.PAYLOAD);\n\n        this.writeConsistency(nw, req.opt.consistency);\n        if (req.opt.durability != null) {\n            this.writeDurability(nw, req.opt.durability);\n        }\n\n        this.checkWriteIntField(nw, Fields.MAX_READ_KB, req.opt.maxReadKB);\n        this.checkWriteIntField(nw, Fields.MAX_WRITE_KB, req.opt.maxWriteKB);\n        this.checkWriteIntField(nw, Fields.NUMBER_LIMIT, req.opt.limit);\n        this.checkWriteIntField(nw, Fields.TRACE_LEVEL, req.opt.traceLevel);\n        this.checkWriteLongField(nw, Fields.SERVER_MEMORY_CONSUMPTION,\n            req.opt._maxServerMemory);\n\n        if (req.opt.traceLevel > 0) {\n            nw.writeBooleanField(Fields.TRACE_TO_LOG_FILES,\n                req.opt.traceToLogFiles);\n            const batchNum =\n                req.opt.continuationKey && req.opt.continuationKey._batchNum ?\n                    req.opt.continuationKey._batchNum : 0;\n            //It seems that Java driver is using 1-based counter.\n            nw.writeIntField(Fields.BATCH_COUNTER, batchNum + 1);\n        }\n\n        nw.writeIntField(Fields.QUERY_VERSION, req._queryVersion);\n        \n        if (req.prepStmt != null) {\n            nw.writeBooleanField(Fields.IS_PREPARED, true);\n            nw.writeBooleanField(Fields.IS_SIMPLE_QUERY,\n                req.prepStmt._queryPlan == null);\n            nw.writeBinaryField(Fields.PREPARED_QUERY,\n                req.prepStmt._prepStmt);\n            \n            if (req.prepStmt._bindings != null) {\n                const ents = Object.entries(req.prepStmt._bindings);\n                nw.startArrayField(Fields.BIND_VARIABLES);\n                for(let [key, val] of ents) {\n                    nw.startMap();\n                    nw.writeStringField(Fields.NAME, key);\n                    this.writeValue(nw, val, req.opt);\n                    nw.endMap();\n                }\n                nw.endArrayField();\n            }\n\n            //For query V3 we write topology seqNum in the payload.\n            if (req._queryVersion < QUERY_V4 && req._topoInfo != null) {\n                nw.writeIntField(Fields.TOPO_SEQ_NUM,\n                    req.prepStmt._topoInfo.seqNum);\n            }\n        } else {\n            nw.writeStringField(Fields.STATEMENT, req.stmt);\n        }\n\n        if (req.opt.continuationKey && !req.opt.continuationKey[ccAsObj]) {\n            nw.writeBinaryField(Fields.CONTINUATION_KEY,\n                req.opt.continuationKey);\n        }\n\n        this.writeMathContext(nw, req.opt);\n        this.checkWriteIntField(nw, Fields.SHARD_ID, req._shardId);\n\n        if (req._queryVersion >= QUERY_V4) {\n            this.checkWriteStringField(nw, Fields.QUERY_ID, req.opt.queryId);\n            if (req._vScan != null) {\n                this._writeVirtualScan(nw, req._vScan);\n            }\n        }\n\n        nw.endMapField();\n        nw.endMap();\n    }\n\n    static _deserializeSortPhase1Results(buf, res) {\n        const dr = new DataReader(buf);\n        return BinaryQuerySerializer._deserializeSortPhase1Results(dr, res);\n    }\n\n    static deserialize(nr, req) {\n        let prepStmt;\n\n        const res = this.deserializeResponse(nr, req, (field, res) => {\n            switch (field) {\n            case Fields.QUERY_RESULTS:\n                res.rows = this.readArray(nr, this.readRow, req.opt);\n                return true;\n            case Fields.CONTINUATION_KEY:\n                res.continuationKey = nr.readBinary();\n                return true;\n            case Fields.SORT_PHASE1_RESULTS:\n                this._deserializeSortPhase1Results(nr.readBinary(), res);\n                return true;\n            case Fields.REACHED_LIMIT:\n                res._reachedLimit = nr.readBoolean();\n                return true;\n            case Fields.VIRTUAL_SCANS:\n                res._vScans = this.readArray(nr, this._readVirtualScan);\n                return true;\n            case Fields.QUERY_BATCH_TRACES:\n                res.queryTraces = this._readQueryTraces(nr);\n                return true;\n            default:\n                prepStmt = prepStmt || {};\n                return PrepareSerializer._processPrepStmtField(nr, field,\n                    prepStmt);\n            }\n        });\n\n        //If the QueryRequest was not initially prepared, the prepared\n        //statement created at the proxy is returned back along with the\n        //query results, so that the preparation does not need to be done\n        //during each query batch.\n        if (req.prepStmt == null) {\n            PrepareSerializer._validatePrepStmt(prepStmt);\n            prepStmt._sql = req.stmt;\n            prepStmt.consumedCapacity = res.consumedCapacity;\n            res._prepStmt = prepStmt;\n        } else if (prepStmt != null && prepStmt._topoInfo != null) {\n            //We received updated topology info. This should happen only for\n            //query V3 and below.\n            this.validateTopologyInfo(prepStmt._topoInfo);\n            res._topoInfo = prepStmt._topoInfo;\n        }\n\n        res.rows = res.rows || []; //empty array if no results\n        return res;\n    }\n\n}\n\nmodule.exports = {\n    PrepareSerializer,\n    QuerySerializer\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}