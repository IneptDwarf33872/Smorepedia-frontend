{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\nconst assert = require('assert');\nconst Config = require('../config');\nconst Limits = require('../constants').Limits;\nconst isPosInt32 = require('../utils').isPosInt32;\nconst TTLUtil = require('../ttl_util');\nconst Op = require('./op');\nclass GetOp extends Op {\n  static validate(req) {\n    this._validateReadRequest(req);\n    this._chkKey(req);\n  }\n  static get supportsRateLimiting() {\n    return true;\n  }\n  static doesReads() {\n    return true;\n  }\n}\nclass PutOp extends Op {\n  static needUpdateTTL(req) {\n    return req.opt.updateTTLToDefault || req.opt.ttl;\n  }\n  static _validateTTL(req) {\n    if (req.opt.ttl == null) {\n      return;\n    }\n    if (req.opt.updateTTLToDefault) {\n      throw new NoSQLArgumentError('Cannot specify ' + '\"updateTTLToDefault\" option if TTL is specified', req);\n    }\n    req.opt.ttl = TTLUtil._validate(req.opt.ttl, req);\n  }\n  static _validate(req, isSubRequest = false) {\n    if (req.opt.ifAbsent && req.opt.ifPresent) {\n      throw new NoSQLArgumentError('Options ifAbsent and ifPresent ' + 'cannot be specified together', req);\n    }\n    if (req.opt.ifAbsent && req.opt.matchVersion != null) {\n      throw new NoSQLArgumentError('matchVersion is not compatible ' + 'with ifAbsent version', req);\n    }\n    if (req.opt.identityCacheSize != null && !isPosInt32(req.opt.identityCacheSize)) {\n      throw new NoSQLArgumentError('Invalid identity cache size', req);\n    }\n    this._validateWriteRequest(req, isSubRequest);\n    this._chkRow(req);\n    this._validateTTL(req);\n    this._chkMatchVersion(req);\n  }\n  static validate(req) {\n    this._validate(req);\n  }\n  static get supportsRateLimiting() {\n    return true;\n  }\n  static doesReads(req) {\n    return req.opt.ifAbsent || req.opt.ifPresent || req.opt.matchVersion;\n  }\n  static doesWrites() {\n    return true;\n  }\n}\nclass DeleteOp extends Op {\n  static _validate(req, isSubRequest = false) {\n    this._validateWriteRequest(req, isSubRequest);\n    this._chkKey(req);\n    this._chkMatchVersion(req);\n  }\n  static validate(req) {\n    this._validate(req);\n  }\n  static get supportsRateLimiting() {\n    return true;\n  }\n  static doesReads() {\n    return true;\n  }\n  static doesWrites() {\n    return true;\n  }\n}\nclass MultiDeleteOp extends Op {\n  static validate(req) {\n    this._validateWriteRequest(req);\n    this._chkKey(req);\n    this._validateFieldRange(req);\n    //Not sure if we need to hardcode WRITE_KB_LIMIT here because\n    //if it changes in the proxy, we may forget to change it in this\n    //driver.  IMO, it is better to let proxy reject over-the-limit\n    //values.\n    if (req.opt.maxWriteKB != null) {\n      if (!isPosInt32(req.opt.maxWriteKB)) {\n        throw new NoSQLArgumentError('Invalid \"maxWriteKB\" value', req);\n      } else if (req.opt.maxWriteKB > Limits.WRITE_KB) {\n        throw new NoSQLArgumentError('maxWriteKB value exceeds ' + `limit of ${Limits.WRITE_KB}`, req);\n      }\n    }\n    this._chkContinuationKey(req);\n  }\n  static get supportsRateLimiting() {\n    return true;\n  }\n  static doesReads() {\n    return true;\n  }\n  static doesWrites() {\n    return true;\n  }\n}\nclass WriteMultipleOp extends Op {\n  static get REQUEST_SIZE_LIMIT() {\n    return Limits.BATCH_REQUEST_SIZE;\n  }\n  static _validateOp(op, idx, req) {\n    if (req.tableName == null) {\n      this._chkTblName(op);\n    } else if (op.tableName != null) {\n      throw new NoSQLArgumentError(`Cannot specify table name both as \\\nargument to writeMany: ${req.tableName} and for operation at index ${idx}: \\\n${op.tableName}`, req);\n    }\n\n    //Here we will convert each op to canonical form to use by the\n    //serializer. We also use options provided to the API for options\n    //not provided for each individual op.\n\n    //User-supplied options should be in op itself.  We make a copy of\n    //op before inheriting to avoid changing op object itself just in\n    //case, to avoid option name clashes.\n    op.opt = Config.inheritOpt(Object.assign({}, op), req.opt);\n    if (op.put != null) {\n      if (op.delete != null) {\n        throw new NoSQLArgumentError('Operation at index ' + `${idx}: cannot have both put and delete`, req);\n      }\n      op.row = op.put;\n      PutOp._validate(op, true);\n      if (PutOp.doesReads(op)) {\n        req._doesReads = true;\n      }\n    } else {\n      if (op.delete == null) {\n        throw new NoSQLArgumentError(`Operation at index ${idx} does not have put ` + 'or delete', req);\n      }\n      op.key = op.delete;\n      DeleteOp._validate(op, true);\n      if (DeleteOp.doesReads(op)) {\n        req._doesReads = true;\n      }\n    }\n  }\n\n  //validate and convert each op to canonical form having \"opt\" and\n  //\"row\" or \"key\" properties for put/delete\n  static validate(req) {\n    this._validateRequest(req);\n    //Table name could be specified per op instead.\n    if (req.tableName != null) {\n      this._chkTblName(req);\n    }\n    this._validateDurability(req);\n    if ('rows' in req) {\n      if (!Array.isArray(req.rows) || !req.rows.length) {\n        throw new NoSQLArgumentError('Invalid rows array', req);\n      }\n      req.ops = req.rows.map(put => ({\n        put\n      }));\n    } else if ('keys' in req) {\n      if (!Array.isArray(req.keys) || !req.keys.length) {\n        throw new NoSQLArgumentError('Invalid keys array', req);\n      }\n      req.ops = req.keys.map(key => ({\n        delete: key\n      }));\n    } else if (!Array.isArray(req.ops) || !req.ops.length) {\n      throw new NoSQLArgumentError('Missing, invalid or empty operations array', req);\n    }\n    if (req.ops.length > Limits.BATCH_OP_NUMBER) {\n      throw new NoSQLArgumentError('Number of batch operations ' + `exceeds limit of ${Limits.BATCH_OP_NUMBER}`, req);\n    }\n    //Validation code in Java driver does not validate every operation\n    //for WriteMultipleRequest.  Should we do it here?\n    for (let i = 0; i < req.ops.length; i++) {\n      const op = req.ops[i];\n      if (op == null || typeof op !== 'object') {\n        throw new NoSQLArgumentError(`Invalid operation value at index ${i}`, req);\n      }\n      this._validateOp(op, i, req);\n    }\n  }\n  static get supportsRateLimiting() {\n    return true;\n  }\n  static doesReads(req) {\n    return req._doesReads;\n  }\n  static doesWrites() {\n    return true;\n  }\n  static getTableName(req) {\n    if (req.tableName) {\n      return req.tableName;\n    }\n\n    //If table name is specified per operation, use the table name of the\n    //first operation for simplicity.  For rate limiter, we will convert\n    //this to top-level (ancestor) table-name which would be the same for\n    //all operations.\n    assert(req.ops != null && req.ops.length != 0 && req.ops[0].tableName);\n    return req.ops[0].tableName;\n  }\n}\nmodule.exports = {\n  GetOp,\n  PutOp,\n  DeleteOp,\n  MultiDeleteOp,\n  WriteMultipleOp\n};","map":{"version":3,"names":["NoSQLArgumentError","require","assert","Config","Limits","isPosInt32","TTLUtil","Op","GetOp","validate","req","_validateReadRequest","_chkKey","supportsRateLimiting","doesReads","PutOp","needUpdateTTL","opt","updateTTLToDefault","ttl","_validateTTL","_validate","isSubRequest","ifAbsent","ifPresent","matchVersion","identityCacheSize","_validateWriteRequest","_chkRow","_chkMatchVersion","doesWrites","DeleteOp","MultiDeleteOp","_validateFieldRange","maxWriteKB","WRITE_KB","_chkContinuationKey","WriteMultipleOp","REQUEST_SIZE_LIMIT","BATCH_REQUEST_SIZE","_validateOp","op","idx","tableName","_chkTblName","inheritOpt","Object","assign","put","delete","row","_doesReads","key","_validateRequest","_validateDurability","Array","isArray","rows","length","ops","map","keys","BATCH_OP_NUMBER","i","getTableName","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/ops/dml.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\nconst assert = require('assert');\nconst Config = require('../config');\nconst Limits = require('../constants').Limits;\nconst isPosInt32 = require('../utils').isPosInt32;\nconst TTLUtil = require('../ttl_util');\nconst Op = require('./op');\n\nclass GetOp extends Op {\n\n    static validate(req) {\n        this._validateReadRequest(req);\n        this._chkKey(req);\n    }\n\n    static get supportsRateLimiting() {\n        return true;\n    }\n\n    static doesReads() {\n        return true;\n    }\n\n}\n\nclass PutOp extends Op {\n\n    static needUpdateTTL(req) {\n        return req.opt.updateTTLToDefault || req.opt.ttl;\n    }\n\n    static _validateTTL(req) {\n        if (req.opt.ttl == null) {\n            return;\n        }\n        if (req.opt.updateTTLToDefault) {\n            throw new NoSQLArgumentError('Cannot specify ' +\n            '\"updateTTLToDefault\" option if TTL is specified', req);\n        }\n        req.opt.ttl = TTLUtil._validate(req.opt.ttl, req);\n    }\n\n    static _validate(req, isSubRequest = false) {\n        if (req.opt.ifAbsent && req.opt.ifPresent) {\n            throw new NoSQLArgumentError('Options ifAbsent and ifPresent ' +\n                'cannot be specified together', req);\n        }\n        if (req.opt.ifAbsent && req.opt.matchVersion != null) {\n            throw new NoSQLArgumentError('matchVersion is not compatible ' +\n            'with ifAbsent version', req);\n        }\n        if (req.opt.identityCacheSize != null &&\n            !isPosInt32(req.opt.identityCacheSize)) {\n            throw new NoSQLArgumentError('Invalid identity cache size', req);\n        }\n        this._validateWriteRequest(req, isSubRequest);\n        this._chkRow(req);\n        this._validateTTL(req);\n        this._chkMatchVersion(req);\n    }\n\n    static validate(req) {\n        this._validate(req);\n    }\n\n    static get supportsRateLimiting() {\n        return true;\n    }\n\n    static doesReads(req) {\n        return req.opt.ifAbsent || req.opt.ifPresent || req.opt.matchVersion;\n    }\n\n    static doesWrites() {\n        return true;\n    }\n}\n\nclass DeleteOp extends Op {\n\n    static _validate(req, isSubRequest = false) {\n        this._validateWriteRequest(req, isSubRequest);\n        this._chkKey(req);\n        this._chkMatchVersion(req);\n    }\n\n    static validate(req) {\n        this._validate(req);\n    }\n\n    static get supportsRateLimiting() {\n        return true;\n    }\n\n    static doesReads() {\n        return true;\n    }\n\n    static doesWrites() {\n        return true;\n    }\n\n}\n\nclass MultiDeleteOp extends Op {\n\n    static validate(req) {\n        this._validateWriteRequest(req);\n        this._chkKey(req);\n        this._validateFieldRange(req);\n        //Not sure if we need to hardcode WRITE_KB_LIMIT here because\n        //if it changes in the proxy, we may forget to change it in this\n        //driver.  IMO, it is better to let proxy reject over-the-limit\n        //values.\n        if (req.opt.maxWriteKB != null) {\n            if (!isPosInt32(req.opt.maxWriteKB)) {\n                throw new NoSQLArgumentError('Invalid \"maxWriteKB\" value',\n                    req);\n            } else if (req.opt.maxWriteKB > Limits.WRITE_KB) {\n                throw new NoSQLArgumentError('maxWriteKB value exceeds ' +\n                    `limit of ${Limits.WRITE_KB}`, req);\n            }\n        }\n        this._chkContinuationKey(req);\n    }\n\n    static get supportsRateLimiting() {\n        return true;\n    }\n\n    static doesReads() {\n        return true;\n    }\n\n    static doesWrites() {\n        return true;\n    }\n\n}\n\nclass WriteMultipleOp extends Op {\n\n    static get REQUEST_SIZE_LIMIT() {\n        return Limits.BATCH_REQUEST_SIZE;\n    }\n\n    static _validateOp(op, idx, req) {\n        if (req.tableName == null) {\n            this._chkTblName(op);\n        } else if (op.tableName != null) {\n            throw new NoSQLArgumentError(`Cannot specify table name both as \\\nargument to writeMany: ${req.tableName} and for operation at index ${idx}: \\\n${op.tableName}`, req);\n        }\n\n        //Here we will convert each op to canonical form to use by the\n        //serializer. We also use options provided to the API for options\n        //not provided for each individual op.\n\n        //User-supplied options should be in op itself.  We make a copy of\n        //op before inheriting to avoid changing op object itself just in\n        //case, to avoid option name clashes.\n        op.opt = Config.inheritOpt(Object.assign({}, op), req.opt);\n\n        if (op.put != null) {\n            if (op.delete != null) {\n                throw new NoSQLArgumentError('Operation at index ' +\n                    `${idx}: cannot have both put and delete`, req);\n            }\n            op.row = op.put;\n            PutOp._validate(op, true);\n            if (PutOp.doesReads(op)) {\n                req._doesReads = true;\n            }\n        } else {\n            if (op.delete == null) {\n                throw new NoSQLArgumentError(\n                    `Operation at index ${idx} does not have put ` +\n                        'or delete', req);\n            }\n            op.key = op.delete;\n            DeleteOp._validate(op, true);\n            if (DeleteOp.doesReads(op)) {\n                req._doesReads = true;\n            }\n        }\n    }\n\n    //validate and convert each op to canonical form having \"opt\" and\n    //\"row\" or \"key\" properties for put/delete\n    static validate(req) {\n        this._validateRequest(req);\n        //Table name could be specified per op instead.\n        if (req.tableName != null) {\n            this._chkTblName(req);    \n        }\n        this._validateDurability(req);\n\n        if ('rows' in req) {\n            if (!Array.isArray(req.rows) || !req.rows.length) {\n                throw new NoSQLArgumentError('Invalid rows array', req);\n            }\n            req.ops = req.rows.map(put => ({ put }));\n        } else if ('keys' in req) {\n            if (!Array.isArray(req.keys) || !req.keys.length) {\n                throw new NoSQLArgumentError('Invalid keys array', req);\n            }\n            req.ops = req.keys.map(key => ({ delete: key }));    \n        } else if (!Array.isArray(req.ops) || !req.ops.length) {\n            throw new NoSQLArgumentError(\n                'Missing, invalid or empty operations array', req);\n        }\n        if (req.ops.length > Limits.BATCH_OP_NUMBER) {\n            throw new NoSQLArgumentError('Number of batch operations ' +\n                `exceeds limit of ${Limits.BATCH_OP_NUMBER}`, req);\n        }\n        //Validation code in Java driver does not validate every operation\n        //for WriteMultipleRequest.  Should we do it here?\n        for(let i = 0; i < req.ops.length; i++) {\n            const op = req.ops[i];\n            if (op == null || typeof op !== 'object') {\n                throw new NoSQLArgumentError(\n                    `Invalid operation value at index ${i}`, req);\n            }\n            this._validateOp(op, i, req);\n        }\n    }\n\n    static get supportsRateLimiting() {\n        return true;\n    }\n\n    static doesReads(req) {\n        return req._doesReads;\n    }\n\n    static doesWrites() {\n        return true;\n    }\n\n    static getTableName(req) {\n        if (req.tableName) {\n            return req.tableName;\n        }\n\n        //If table name is specified per operation, use the table name of the\n        //first operation for simplicity.  For rate limiter, we will convert\n        //this to top-level (ancestor) table-name which would be the same for\n        //all operations.\n        assert(req.ops != null && req.ops.length != 0 &&\n            req.ops[0].tableName);\n        return req.ops[0].tableName;\n    }\n\n}\n\nmodule.exports = {\n    GetOp,\n    PutOp,\n    DeleteOp,\n    MultiDeleteOp,\n    WriteMultipleOp\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}