{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl\n *\n * Please see LICENSE.txt file included in the top-level directory of the\n * appropriate download for a copy of the license and additional information.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst SQLFuncCode = require('./common').SQLFuncCode;\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst isNumeric = require('./utils').isNumeric;\nconst sizeof = require('./utils').sizeof;\nconst normalizeNumeric = require('./utils').normalizeNumeric;\nconst resBuf2MapKey = require('./utils').resBuf2MapKey;\nconst add = require('./arith').add;\nconst compareNonNullAtomics = require('./compare').compareNonNullAtomics;\nconst compareFieldValuesTotalOrder = require('./compare').compareFieldValuesTotalOrder;\nconst BinaryProtocol = require('../binary_protocol/protocol');\nconst DataWriter = require('../binary_protocol/writer');\nconst MEM_OVERHEAD = '_ctx'.length + '_incMem'.length + '_aggrVal'.length;\nclass ValueAggregator {\n  constructor(ctx, incMem) {\n    this._ctx = ctx;\n    this._incMem = incMem;\n    this._aggrVal = this.constructor._initialValue();\n    if (this._incMem) {\n      this._incMem(MEM_OVERHEAD + sizeof(this._aggrVal));\n    }\n  }\n  static _initialValue() {\n    return undefined;\n  }\n  aggregate() {\n    throw new Error('Cannot call abstract method \"aggregate\" in class \\\n\"ValueAggregator\"');\n  }\n  get result() {\n    return this._aggrVal;\n  }\n  reset() {\n    this._aggrVal = this.constructor._initialValue();\n  }\n}\nclass SingleValueAggregator extends ValueAggregator {\n  constructor(ctx, incMem) {\n    super(ctx, incMem);\n  }\n  _aggregate() {\n    throw new Error('Cannot call abstract method \"_aggregate\" in class \\\n\"SingleValueAggregator\"');\n  }\n  aggregate(val) {\n    const oldVal = this._aggrVal;\n    this._aggregate(val);\n    if (!this._incMem || oldVal === this._aggrVal ||\n    //common case\n    typeof oldVal === 'number' && typeof newVal === 'number') {\n      return;\n    }\n    this._incMem(sizeof(this._ctx, this._aggrVal) - sizeof(this._ctx, oldVal));\n  }\n}\nclass MinMaxAggregator extends SingleValueAggregator {\n  constructor(ctx, incMem, isMin) {\n    super(ctx, incMem);\n    this._isMin = isMin;\n  }\n  _supportsComp(val) {\n    return isNumeric(this._ctx, val) || typeof val === 'boolean' || typeof val === 'string' || val instanceof Date;\n  }\n  _isNewMinMax(val) {\n    if (!this._supportsComp(val)) {\n      return false;\n    }\n    if (this._aggrVal == undefined) {\n      return true;\n    }\n    const compRes = compareNonNullAtomics(this, val, this._aggrVal);\n    return this._isMin ? compRes < 0 : compRes > 0;\n  }\n  _aggregate(val) {\n    if (this._isNewMinMax(val)) {\n      this._aggrVal = val;\n    }\n  }\n}\nclass SumAggregator extends SingleValueAggregator {\n  constructor(ctx, incMem) {\n    super(ctx, incMem);\n  }\n  _aggregate(val) {\n    if (!isNumeric(this._ctx, val)) {\n      return;\n    }\n    this._aggrVal = this._aggrVal != undefined ? add(this._ctx, this._aggrVal, val) : val;\n  }\n}\nclass CountAggregator extends SingleValueAggregator {\n  constructor(ctx, incMem, funcCode) {\n    super(ctx, incMem);\n    this._funcCode = funcCode;\n  }\n  static _initialValue() {\n    return 0;\n  }\n  _aggregate(val) {\n    switch (this._funcCode) {\n      case SQLFuncCode.FN_COUNT_STAR:\n        break;\n      case SQLFuncCode.FN_COUNT:\n        if (val == undefined || val == EMPTY_VALUE) {\n          return;\n        }\n        break;\n      case SQLFuncCode.FN_COUNT_NUMBERS:\n        if (!isNumeric(this._ctx, val)) {\n          return;\n        }\n        break;\n      default:\n        assert(false);\n        break;\n    }\n    this._aggrVal = add(this, this._aggrVal, 1);\n  }\n}\nclass CollectAggregator extends ValueAggregator {\n  constructor(ctx, incMem, isDistinct, toSortResults) {\n    super(ctx, incMem);\n    if (isDistinct) {\n      this._dup = new Set();\n      this._dw = new DataWriter();\n    }\n    //Order of values in the result of array_collect is not defined. We\n    //only sort in test mode to match actual with expected results.\n    this._toSortResults = toSortResults;\n  }\n  static _initialValue() {\n    return [];\n  }\n  _makeKey(val) {\n    this._dw.reset();\n    BinaryProtocol.writeFieldValue(this._dw, val, {\n      _dbNumber: this._ctx._dbNumber,\n      _writeSortedMaps: true,\n      _replacer: normalizeNumeric\n    });\n    return resBuf2MapKey(this._dw.buffer);\n  }\n  get result() {\n    return this._toSortResults ? super.result.sort((val1, val2) => compareFieldValuesTotalOrder(this._ctx, val1, val2)) : super.result;\n  }\n  aggregate(val) {\n    if (val == undefined || val == EMPTY_VALUE) {\n      return;\n    }\n    if (!Array.isArray(val)) {\n      throw this._ctx.illegalState(`Input value in collect step is not an array: \\\n${util.inspect(val)}`);\n    }\n    for (const elem of val) {\n      if (this._dup) {\n        const key = this._makeKey(elem);\n        if (this._dup.has(key)) {\n          continue;\n        }\n        this._dup.add(key);\n        if (this._incMem) {\n          this._incMem(sizeof(key));\n        }\n      }\n      this._aggrVal.push(elem);\n      if (this._incMem) {\n        this._incMem(sizeof(elem));\n      }\n    }\n  }\n  reset() {\n    super.reset();\n    if (this._dup) {\n      this._dup.clear();\n      this._dw.reset();\n    }\n  }\n}\nmodule.exports = {\n  ValueAggregator,\n  MinMaxAggregator,\n  SumAggregator,\n  CountAggregator,\n  CollectAggregator\n};","map":{"version":3,"names":["assert","require","util","SQLFuncCode","EMPTY_VALUE","isNumeric","sizeof","normalizeNumeric","resBuf2MapKey","add","compareNonNullAtomics","compareFieldValuesTotalOrder","BinaryProtocol","DataWriter","MEM_OVERHEAD","length","ValueAggregator","constructor","ctx","incMem","_ctx","_incMem","_aggrVal","_initialValue","undefined","aggregate","Error","result","reset","SingleValueAggregator","_aggregate","val","oldVal","newVal","MinMaxAggregator","isMin","_isMin","_supportsComp","Date","_isNewMinMax","compRes","SumAggregator","CountAggregator","funcCode","_funcCode","FN_COUNT_STAR","FN_COUNT","FN_COUNT_NUMBERS","CollectAggregator","isDistinct","toSortResults","_dup","Set","_dw","_toSortResults","_makeKey","writeFieldValue","_dbNumber","_writeSortedMaps","_replacer","buffer","sort","val1","val2","Array","isArray","illegalState","inspect","elem","key","has","push","clear","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/query/value_aggr.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl\n *\n * Please see LICENSE.txt file included in the top-level directory of the\n * appropriate download for a copy of the license and additional information.\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst SQLFuncCode = require('./common').SQLFuncCode;\nconst EMPTY_VALUE = require('../constants').EMPTY_VALUE;\nconst isNumeric = require('./utils').isNumeric;\nconst sizeof = require('./utils').sizeof;\nconst normalizeNumeric = require('./utils').normalizeNumeric;\nconst resBuf2MapKey = require('./utils').resBuf2MapKey;\nconst add = require('./arith').add;\nconst compareNonNullAtomics = require('./compare').compareNonNullAtomics;\nconst compareFieldValuesTotalOrder =\n    require('./compare').compareFieldValuesTotalOrder;\nconst BinaryProtocol = require('../binary_protocol/protocol');\nconst DataWriter = require('../binary_protocol/writer');\n\nconst MEM_OVERHEAD = '_ctx'.length + '_incMem'.length + '_aggrVal'.length;\n\nclass ValueAggregator {\n\n    constructor(ctx, incMem) {\n        this._ctx = ctx;\n        this._incMem = incMem;\n        this._aggrVal = this.constructor._initialValue();\n        if (this._incMem) {\n            this._incMem(MEM_OVERHEAD + sizeof(this._aggrVal));\n        }\n    }\n\n    static _initialValue() {\n        return undefined;\n    }\n\n    aggregate() {\n        throw new Error(\n            'Cannot call abstract method \"aggregate\" in class \\\n\"ValueAggregator\"');\n    }\n\n    get result() {\n        return this._aggrVal;\n    }\n\n    reset() {\n        this._aggrVal = this.constructor._initialValue();\n    }\n}\n\nclass SingleValueAggregator extends ValueAggregator {\n\n    constructor(ctx, incMem) {\n        super(ctx, incMem);\n    }\n\n    _aggregate() {\n        throw new Error(\n            'Cannot call abstract method \"_aggregate\" in class \\\n\"SingleValueAggregator\"');\n    }\n\n    aggregate(val) {\n        const oldVal = this._aggrVal;\n        this._aggregate(val);\n\n        if (!this._incMem || oldVal === this._aggrVal ||\n            //common case\n            (typeof oldVal === 'number' && typeof newVal === 'number')) {\n            return;\n        }\n\n        this._incMem(sizeof(this._ctx, this._aggrVal) -\n            sizeof(this._ctx, oldVal));\n    }\n}\n\nclass MinMaxAggregator extends SingleValueAggregator {\n\n    constructor(ctx, incMem, isMin) {\n        super(ctx, incMem);\n        this._isMin = isMin;\n    }\n\n    _supportsComp(val) {\n        return isNumeric(this._ctx, val) || typeof val === 'boolean' ||\n            typeof val === 'string' || val instanceof Date;\n    }\n    \n    _isNewMinMax(val) {\n        if (!this._supportsComp(val)) {\n            return false;\n        }\n        if (this._aggrVal == undefined) {\n            return true;\n        }\n        const compRes = compareNonNullAtomics(this, val, this._aggrVal);\n        return this._isMin ? compRes < 0 : compRes > 0;\n    }\n\n    _aggregate(val) {\n        if (this._isNewMinMax(val)) {\n            this._aggrVal = val;\n        }\n    }\n\n}\n\nclass SumAggregator extends SingleValueAggregator {\n    constructor(ctx, incMem) {\n        super(ctx, incMem);\n    }\n\n    _aggregate(val) {\n        if (!isNumeric(this._ctx, val)) {\n            return;\n        }\n        this._aggrVal = this._aggrVal != undefined ?\n            add(this._ctx, this._aggrVal, val) : val;\n    }\n}\n\nclass CountAggregator extends SingleValueAggregator {\n    constructor(ctx, incMem, funcCode) {\n        super(ctx, incMem);\n        this._funcCode = funcCode;\n    }\n\n    static _initialValue() {\n        return 0;\n    }\n\n    _aggregate(val) {\n        switch(this._funcCode) {\n        case SQLFuncCode.FN_COUNT_STAR:\n            break;\n        case SQLFuncCode.FN_COUNT:\n            if (val == undefined || val == EMPTY_VALUE) {\n                return;\n            }\n            break;\n        case SQLFuncCode.FN_COUNT_NUMBERS:\n            if (!isNumeric(this._ctx, val)) {\n                return;\n            }\n            break;\n        default:\n            assert(false);\n            break;\n        }\n\n        this._aggrVal = add(this, this._aggrVal, 1);\n    }\n}\n\nclass CollectAggregator extends ValueAggregator {\n    constructor(ctx, incMem, isDistinct, toSortResults) {\n        super(ctx, incMem);\n        if (isDistinct) {\n            this._dup = new Set();\n            this._dw = new DataWriter();\n        }\n        //Order of values in the result of array_collect is not defined. We\n        //only sort in test mode to match actual with expected results.\n        this._toSortResults = toSortResults;\n    }\n\n    static _initialValue() {\n        return [];\n    }\n\n    _makeKey(val) {\n        this._dw.reset();\n        BinaryProtocol.writeFieldValue(this._dw, val, {\n            _dbNumber: this._ctx._dbNumber,\n            _writeSortedMaps: true,\n            _replacer: normalizeNumeric\n        });\n        return resBuf2MapKey(this._dw.buffer);\n    }\n\n    get result() {\n        return this._toSortResults ?\n            super.result.sort((val1, val2) =>\n                compareFieldValuesTotalOrder(this._ctx, val1, val2)) :\n            super.result;\n    }\n\n    aggregate(val) {\n        if (val == undefined || val == EMPTY_VALUE) {\n            return;\n        }\n        \n        if (!Array.isArray(val)) {\n            throw this._ctx.illegalState(\n                `Input value in collect step is not an array: \\\n${util.inspect(val)}`);\n        }\n\n        for(const elem of val) {\n            if (this._dup) {\n                const key = this._makeKey(elem);\n                if (this._dup.has(key)) {\n                    continue;\n                }\n                this._dup.add(key);\n                if (this._incMem) {\n                    this._incMem(sizeof(key));\n                }\n            }\n            this._aggrVal.push(elem);\n            if (this._incMem) {\n                this._incMem(sizeof(elem));\n            }\n        }\n    }\n\n    reset() {\n        super.reset();\n        if (this._dup) {\n            this._dup.clear();\n            this._dw.reset();\n        }\n    }\n}\n\nmodule.exports = {\n    ValueAggregator,\n    MinMaxAggregator,\n    SumAggregator,\n    CountAggregator,\n    CollectAggregator\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}