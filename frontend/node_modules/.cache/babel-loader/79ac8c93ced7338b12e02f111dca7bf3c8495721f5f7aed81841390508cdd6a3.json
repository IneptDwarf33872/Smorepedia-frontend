{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst ops = require('./ops');\nconst NoSQLClientImpl = require('./nosql_client_impl');\n\n/**\n * Defines NoSQLClient, which is the point of access to the\n * Oracle NoSQL Database Cloud service.\n */\n\n/**\n * @classdesc NoSQLClient class provides access to Oracle NoSQL Database\n * tables.  Methods of this class are used to create and manage tables and\n * indexes, and to read and write data. All operations are performed\n * asynchronously.\n * <p>\n * Each method returns a Promise object that will resolve to the\n * result of the operation if successful, or reject with an error upon\n * failure. To handle results and errors, you may use promise chains\n * with .then.catch or async functions with await.  The result of\n * operation is a JavaScript object with properties specific to each\n * operation and is documented for each method below.  If any error\n * has occurred, the promise will reject with {@link NoSQLError} or\n * one of its subclasses.\n * <p>\n * You instantiate NoSQLClient by providing connection and credential\n * information, either in the form of a configuration object of type\n * {@link Config} or a path to a file that holds {@link Config} information.\n * Some parameters, such as the service endpoint or region, are required.\n * Other parameters are optional and need not be specified in the\n * {@link Config}. Default values are used for optional parameters.\n * <p>\n * Note that it is possible to create {@link NoSQLClient} instance without\n * providing configuration if all of the following are true:\n * <ul>\n * <li>You are using {@link NoSQLClient} with the Cloud Service.</li>\n * <li>You store your credentials and region identifier in an OCI configuration\n * file with the default file path and default profile name.  See\n * {@link IAMConfig} for more information.</li>\n * <li>You use defaults for all other configuration properties.</li>\n * </ul>\n * <p>\n * Each method of NoSQLClient also takes an optional <em>opt</em>\n * parameter which contains options specific to a particular\n * operation.  Some of these options may be the same as those\n * specified by {@link Config} and will override the {@link Config}\n * values for this operation.  The method description describes which\n * options are pertinent for that operation. If an options is not\n * specified in the <em>opt</em> parameter and is also not present in\n * {@link Config}, the driver will use default values.\n * <p>\n * In general, same methods and options are applicable to both Oracle\n * NoSQL Database Cloud Service and On-Premise Oracle NoSQL Database.\n * However, some methods, options and result types may be specific to\n * particular {@link ServiceType}, which is specified in their documentation.\n * <p>\n * <em>For cloud service only:</em> for each method you may provide\n * <em>opt.compartment</em> which specifies the compartment of the given table\n * (or compartment used to perform given operation).  If not set in options or\n * initial config (see {@link Config}#compartment), the root\n * compartment of the tenancy is assumed. The compartment is a string that\n * may be either the id (OCID) of the compartment or a compartment name. Both\n * are acceptable. If a name is used it can be either the name of a top-level\n * compartment, or for nested compartments, it should be a compartment path\n * to the nested compartment that does not include the root compartment name\n * (tenant), e.g. <em>compartmentA.compartmentB.compartmentC</em>\n * <p>\n * Alternatively, instead of setting <em>opt.compartment</em>\n * you may prefix the table name with its compartment name (for top-level\n * compartments) or compartment path (for nested compartments), e.g.\n * <em>compartmentA.compartmentB.compartmentC:myTable</em>.\n * Note that the table name cannot be\n * prefixed with compartment id.  Prefixing the table with compartment\n * name/path takes precendence over other methods of specifying the\n * compartment.\n *\n * @fires NoSQLClient#error\n * @fires NoSQLClient#retryable\n * @fires NoSQLClient#consumedCapacity\n * @fires NoSQLClient#tableState\n *\n * @tutorial connect-cloud\n * @tutorial connect-on-prem\n * @tutorial tables\n *\n * @example // Using NoSQLClient with async-await\n *\n * const NoSQLClient = require('oracle-nosqldb').NoSQLClient;\n *\n * async function test() {\n *      let client;\n *      try {\n *          client = new NoSQLClient('config.json');\n *          let res = await client.tableDDL(\n *              'CREATE TABLE foo(id INTEGER, name STRING, PRIMARY KEY(id))',\n *              {\n *                  tableLimits: {\n *                      readUnits: 100,\n *                      writeUnits: 100,\n *                      storageGB: 50\n *                  }\n *              }\n *          );\n *          console.log('Table: %s, state: %s', res.tableName,\n *              res.tableState);\n *          await client.forCompletion(res);\n *          res = await client.put('foo', { id: 1, name: 'test' });\n *          res = await client.get('foo', { id: 1 });\n *          console.log(res.row);\n *          //..........\n *      } catch(err) {\n *          //handle errors\n *      } finally {\n *          if (client) {\n *              client.close();\n *          }\n *      }\n * }\n */\nclass NoSQLClient extends NoSQLClientImpl {\n  /**\n   * Constructs an instance of NoSQLClient. This function is synchronous.\n   * @param {string|Config|null} [config] Configuration for NoSQL client.\n   * May be either a string indicating the file path to a configuration\n   * file, or a {@link Config} object. If a file path is supplied,\n   * the path can be absolute or relative to the current directory\n   * of the application. The file should contain the {@link Config} object\n   * and can be either JSON or JavaScript (in the latter case its\n   * <em>module.exports</em> should be set to the {@link Config} object).\n   * Note that you may pass <em>null</em> or omit this parameter (use\n   * no-argument constructor) if using the cloud service with the default OCI\n   * configuration file that contains credentials and region identifier, as\n   * described above\n   * @throws {NoSQLArgumentError} if the configuration is\n   * missing required properties or contains invalid property values\n   * @see {@link Config}\n   */\n  constructor(config) {\n    super(config);\n  }\n\n  /**\n   * Returns the version of the driver.\n   * @returns {string} The version of the driver\n   */\n  static get version() {\n    return require('./constants').PACKAGE_VERSION;\n  }\n\n  /**\n   * Returns the service type of used by this {@link NoSQLClient} instance.\n   * @returns {ServiceType} Service type\n   */\n  get serviceType() {\n    return this._config.serviceType;\n  }\n\n  /**\n   * Releases resources associated with NoSQLClient.  This method must be\n   * called after NoSQLClient is no longer needed.\n   * @returns {Promise} Promise, which may be resolved if closing\n   * the client did not require asynchronous operations.  The resolved\n   * value is ignored.  Currently, the close may need to perform\n   * asynchronous operation only when using {@link ServiceType.KVSTORE},\n   * otherwise resolved Promise is returned.  The Promise should not reject\n   * (rather log the error if any), so you only need to <em>await</em> for\n   * it if you need to perform an action upon its completion.\n   * @see {@link ServiceType}\n   */\n  close() {\n    return super.close();\n  }\n\n  /**\n   * Obtains and caches authorization information in advance of performing\n   * database operations.\n   * <p>\n   * Built-in authorization providers use with this SDK obtain authorization\n   * information such as authorization signature or token and cache it for\n   * some time.  In some instances, obtaining this information make take\n   * some time, especially in cases when a network request to authorization\n   * server is required, e.g. when using Cloud Service with Instance\n   * Principal (see {@link IAMConfig}).  By default, this information is\n   * obtained on demand when database operation is issued and this may cause\n   * timeout errors if the default timeout for database operations is not\n   * sufficient to obtain this information.  You may call this method to\n   * obtain and pre-cache authorization information, so that when database\n   * operations are issued, they do not need to spend any extra time on\n   * obtaining authorization.\n   * <p> A current use case for this method is when using Cloud Service\n   * with Instance Principal, because a network request is required to\n   * obtain authorization token (as well additional requests to obtain\n   * instance region, instance certificates, instance private key, etc).\n   * An alternative solution is to increase operation timeouts to allot\n   * enough time to obtain authorzation token when required.  However,\n   * calling {@link NoSQLClient#precacheAuth} will provide better\n   * performance when starting multiple concurrent database operations.\n   * <p>\n   * Call this method after creating {@link NoSQLClient} instance before\n   * performing database operations.  Note that after the authorization\n   * expires, it will need to be obtained again which make take some time in\n   * some cases as described above.  However, build-in authoirzation\n   * providers used with this SDK are configured to refresh the\n   * authorization in background ahead of its expiration so that database\n   * operations may use existing authorization while the new one is obtained\n   * in the background.\n   * <p>\n   * Calling this method is equivalient to calling\n   * {@link AuthorizationProvider}#getAuthorization which will pre-cache\n   * the authorzation in the process, so if using custom\n   * {@link AuthorizationProvider} that does not cache authorzation, this\n   * method will have no effect.\n   * <p>\n   * This method does not take explicit timeout, but uses timeouts specified\n   * for authorization network requests for given built-in authorization\n   * provider.  See properties {@link IAMConfig}#timeout and\n   * {@link KVStoreAuthConfig}#timeout.\n   * @example\n   * // Using {@link NoSQLClient#precacheAuth} on new {@link NoSQLClient}\n   * // instance.\n   * let client;\n   * try {\n   *     client = await new NoSQLClient(config).precacheAuth();\n   *     .....\n   * } finally {\n   *     client?.close();\n   * }\n   * @async\n   * @returns {Promise} Promise of {@link NoSQLClient} of this instance\n   * @see {@link IAMConfig}\n   * @see {@link KVStoreAuthConfig}\n   * @see {@link AuthorizationProvider}\n   */\n  precacheAuth() {\n    return super._precacheAuth();\n  }\n\n  /**\n   * Executes a DDL operation on a table. The operations allowed are\n   * defined by the Data Definition Language (DDL) portion of the\n   * query language related to tables such as table creation and\n   * drop, index add and drop, and the ability to alter table schema\n   * and table limits.\n   * <p>\n   * Operations using table DDL statements infer the table name from the\n   * statement itself, e.g. \"CREATE TABLE mytable(...)\". Table\n   * creation requires a valid {@link TableLimits} object to define\n   * the throughput and storage desired for the table. It is an\n   * error for TableLimits to be specified with a statement other\n   * than create or alter table.\n   * <p>\n   * Note that these are potentially long-running operations, so the\n   * result returned by this API does not imply operation completion\n   * and the table may be in an intermediate state. (see {@link\n   * TableState}).  The caller should use the {@link NoSQLClient#getTable}\n   * method to check the status of the operation or\n   * {@link NoSQLClient#forCompletion} to asynchronously wait for the\n   * operation completion.\n   * <p>\n   * Alternatively, if <em>opt.complete</em> is set to true, this API will\n   * complete (i.e. the returned <em>Promise</em> will resolve) only\n   * when the operation is completed and the table reaches state\n   * {@link TableState.ACTIVE} or {@link TableState.DROPPED} (if the\n   * operation was \"DROP TABLE\").  This is equivalent to sequentially\n   * executing {@link NoSQLClient#tableDDL} and\n   * {@link NoSQLClient#forCompletion}.  In this case, <em>opt.timeout</em>\n   * covers the whole time interval until operation completion.\n   * If not specified, separate default timeouts are used for issuing the\n   * DDL operation and waiting for its completion, with values of\n   * {@link Config}#ddlTimeout and {@link Config}#tablePollTimeout\n   * correspondingly (the latter defaults to no timeout if\n   * {@link Config}#tablePollTimeout is not set).  You may also use\n   * <em>opt.delay</em> to specify polling delay (see\n   * {@link NoSQLClient#forCompletion}).\n   * @async\n   * @param {string} stmt SQL statement\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#ddlTimeout (if\n   * <em>opt.complete</em> is true, separate default timeouts are used for\n   * issuing the DDL operation and waiting for its completion, with values\n   * of {@link Config}#ddlTimeout and {@link Config}#tablePollTimeout\n   * correspondingly)\n   * @param {TableLimits} [opt.tableLimits] Specifies new table limits for\n   * a table. See {@link TableLimits}.  Note that this property is required\n   * when creating a table\n   * @param {TableETag} [opt.matchETag] Cloud Service only. Entity tag that\n   * must be matched for the operation to proceed. See {@link TableETag}\n   * @param {DefinedTags} [opt.definedTags] Cloud Service only. Defined tags\n   * to use for the operation.  See {@link DefinedTags}\n   * @param {FreeFormTags} [opt.freeFormTags] Cloud Service only. Free-form\n   * tags to use for the operation.  See {@link FreeFormTags}\n   * @param {boolean} [opt.complete] If set to true, the returned\n   * <em>Promise</em> will only resolve when the operation is completed and\n   * the table state becomes {@link TableState.ACTIVE} or\n   * {@link TableState.DROPPED} (if the operation was \"DROP TABLE\")\n   * @param {number} [opt.delay] If <em>opt.complete</em> is true, specifies\n   * delay between successive polls while waiting for operation completion.\n   * Defaults to {@link Config}#tablePollDelay.  Has no effect if\n   * <em>opt.complete</em> is not enabled\n   * @returns {Promise} Promise of {@link TableResult}\n   * @see {@link TableResult}\n   * @see {@link NoSQLClient#forCompletion}\n   */\n  tableDDL(stmt, opt) {\n    const req = {\n      api: this.tableDDL,\n      stmt,\n      opt\n    };\n    return opt != null && opt.complete ? this._withCompletion(ops.TableDDLOp, req) : this._execute(ops.TableDDLOp, req);\n  }\n\n  /**\n   * Note: this method is only supported when using the driver with the\n   * Cloud Service or Cloud Simulator.  When using the driver with\n   * On-Premise NoSQL Database (see {@link ServiceType.KVSTORE}), this\n   * method is a no-op.\n   * <p>\n   * Sets new limits of throughput and storage for existing table.\n   * <p>\n   * Same considerations as described in {@link NoSQLClient#tableDDL} about\n   * long-running operations, using {@link NoSQLClient#forCompletion} and\n   * options <em>opt.complete</em> and <em>opt.delay</em> apply to this API.\n   * See {@link NoSQLClient#tableDDL}.\n   * @async\n   * @param {string} tableName Table name\n   * @param {TableLimits} tableLimits New table limits for the table\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#ddlTimeout (if\n   * <em>opt.complete</em> is true, separate default timeouts are used for\n   * issuing the DDL operation and waiting for its completion, with values\n   * of {@link Config}#ddlTimeout and {@link Config}#tablePollTimeout\n   * correspondingly)\n   * @param {TableETag} [opt.matchETag] Cloud Service only. Entity tag that\n   * must be matched for the operation to proceed. See {@link TableETag}\n   * @param {boolean} [opt.complete] If set to true, the returned\n   * <em>Promise</em> will only resolve when the operation is completed and\n   * the table state becomes {@link TableState.ACTIVE}\n   * @param {number} [opt.delay] If <em>opt.complete</em> is true, specifies\n   * delay between successive polls while waiting for operation completion.\n   * Defaults to {@link Config}#tablePollDelay.  Has no effect if\n   * <em>opt.complete</em> is not enabled\n   * @returns {Promise} Promise of {@link TableResult}\n   * @see {@link TableResult}\n   * @see {@link NoSQLClient#tableDDL}\n   */\n  setTableLimits(tableName, tableLimits, opt) {\n    opt = this._assignOpt(opt, {\n      tableLimits\n    });\n    const req = {\n      api: this.setTableLimits,\n      tableName,\n      opt\n    };\n    return opt.complete ? this._withCompletion(ops.TableLimitsOp, req) : this._execute(ops.TableLimitsOp, req);\n  }\n\n  /**\n   * Note: this method is only supported when using the driver with the\n   * Cloud Service or Cloud Simulator.  When using the driver with\n   * On-Premise NoSQL Database (see {@link ServiceType.KVSTORE}), this\n   * method is a no-op.\n   * <p>\n   * Sets defined and free-form tags on existing table.\n   * <p> See {@link DefinedTags} and {@link FreeFormTags} for more\n   * information on tagging.\n   * <p>\n   * Same considerations as described in {@link NoSQLClient#tableDDL} about\n   * long-running operations, using {@link NoSQLClient#forCompletion} and\n   * options <em>opt.complete</em> and <em>opt.delay</em> apply to this API.\n   * See {@link NoSQLClient#tableDDL}.\n   * @async\n   * @param {string} tableName Table name\n   * @param {DefinedTags} definedTags Cloud Service only. Defined tags\n   * to use for the operation. See {@link DefinedTags}.  Pass <em>null</em>\n   * if you wish to set only free-form tags\n   * @param {FreeFormTags} [freeFormTags] Cloud Service only. Free-form\n   * tags to use for the operation.  See {@link FreeFormTags}. Pass\n   * <em>null</em> (or omit if not using <em>opt</em> parameter) if you with\n   * to set only defined tags.\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#ddlTimeout (if\n   * <em>opt.complete</em> is true, separate default timeouts are used for\n   * issuing the DDL operation and waiting for its completion, with values\n   * of {@link Config}#ddlTimeout and {@link Config}#tablePollTimeout\n   * correspondingly)\n   * @param {TableETag} [opt.matchETag] Cloud Service only. Entity tag that\n   * must be matched for the operation to proceed. See {@link TableETag}\n   * @param {boolean} [opt.complete] If set to true, the returned\n   * <em>Promise</em> will only resolve when the operation is completed and\n   * the table state becomes {@link TableState.ACTIVE}\n   * @param {number} [opt.delay] If <em>opt.complete</em> is true, specifies\n   * delay between successive polls while waiting for operation completion.\n   * Defaults to {@link Config}#tablePollDelay.  Has no effect if\n   * <em>opt.complete</em> is not enabled\n   * @returns {Promise} Promise of {@link TableResult}\n   * @see {@link DefinedTags}\n   * @see {@link FreeFormTags}\n   * @see {@link TableResult}\n   * @see {@link NoSQLClient#tableDDL}\n   */\n  setTableTags(tableName, definedTags, freeFormTags, opt) {\n    opt = this._assignOpt(opt, {\n      definedTags,\n      freeFormTags\n    });\n    const req = {\n      api: this.setTableTags,\n      tableName,\n      opt\n    };\n    return opt.complete ? this._withCompletion(ops.TableLimitsOp, req) : this._execute(ops.TableLimitsOp, req);\n  }\n\n  /**\n   * Retrieves static information about a table, including its\n   * provisioned througput, capacity and schema, in the form of {@link\n   * TableResult}. Dynamic information such as usage() is obtained using\n   * {@link getTableUsage}\n   * @async\n   * @param {string|TableResult} table Either a table name or a\n   * {@link TableResult} object that was returned from a call to\n   * {@link NoSQLClient#tableDDL}. If the latter,\n   * error information for the DDL operation will be retrieved, so\n   * if the original call failed, this follow-on call will also fail with\n   * the same error.\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @returns {Promise} Promise of {@link TableResult}\n   * @see {@link NoSQLClient#tableDDL}\n   */\n  getTable(table, opt) {\n    return this._execute(ops.GetTableOp, {\n      api: this.getTable,\n      table,\n      opt\n    });\n  }\n\n  /**\n   * Waits asynchronously for the table to reach a desired state.  This is\n   * achieved by polling the table at specified intervals.\n   * <p>\n   * This API is used to ensure that the table is ready for data\n   * operations after it has been created or altered. It should only be used\n   * if the table DDL operation has been performed outside of the current\n   * flow of control (e.g. by another application) such that the\n   * {@link TableResult} of the DDL operation is not available.  To wait for\n   * completion of the table DDL operation that you issued, use\n   * {@link NoSQLClient#forCompletion}.  This API waits until\n   * the table has transitioned from an intermediate state like\n   * {@link TableState.CREATING} or {@link TableState.UPDATING} to a\n   * stable state like {@link TableState.ACTIVE}, at which point it\n   * can be used.\n   * <p>\n   * The result of this operation, if successful, is a {@link TableResult}\n   * that shows the table state from the last poll. The\n   * state of {@link TableState.DROPPED} is treated specially in\n   * that it will be returned as success, even if the table does not\n   * exist. Other states will throw an exception if the table is not\n   * found.\n   * @async\n   * @param {string} tableName Table name\n   * @param {TableState} tableState Desired table state\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds, i.e. how long to keep polling for desired table state.\n   * Defaults to {@link Config}#tablePollTimeout\n   * @param {number} [opt.delay] Delay in milliseconds between\n   * successive polls, determines how often the polls are performed.\n   * Defaults to {@link Config}#tablePollDelay\n   * @returns {Promise} Promise of {@link TableResult} representing\n   * result of the last poll\n   * @see {@link NoSQLClient#getTable}\n   * @see {@link NoSQLClient#tableDDL}\n   * @see {@link NoSQLClient#forCompletion}\n   */\n  forTableState(tableName, tableState, opt) {\n    return this._forTableState(tableName, tableState, opt);\n  }\n\n  /**\n   * Note: this method is only supported when using the driver with the\n   * Cloud Service.  It is not supported when using the driver with\n   * On-Premise NoSQL Database (see {@link ServiceType.KVSTORE}), in which\n   * case it will result in error.\n   * <p>\n   * Retrieves dynamic information associated with a table, as returned in\n   * {@link TableUsageResult}. This information includes a time series of\n   * usage snapshots, each indicating data such as read and write\n   * throughput, throttling events, etc, as found in {@link TableUsage}.\n   * <p>\n   * Usage information is collected in time slices and returned in\n   * individual usage records.  It is possible to return a range of usage\n   * records within a given time period.  Unless the time period is\n   * specified, only the most recent usage record is returned. Usage records\n   * are created on a regular basis and maintained for a period of time.\n   * Only records for time periods that have completed are returned so that\n   * a user never sees changing data for a specific range.\n   * <p>\n   * Because the number of table usage records can be very large, you may\n   * page the results over multiple calls to\n   * {@link NoSQLClient#getTableUsage} using <em>opt.startIndex</em> and\n   * <em>opt.limit</em> parameters as shown in the example.  However, the\n   * recommended way is to call {@link NoSQLClient#tableUsageIterable} and\n   * iterate over its result.\n   * @example <caption>Paging over table usage records</caption>\n   * // We iterate until the number of returned table usage records becomes\n   * // less than the limit (and possibly 0), which means that the last\n   * // partial result has been received.\n   * const now = Date.now();\n   * const opt = {\n   *     startTime: now - 3600 * 1000, // last 1 hour\n   *     endTime: now,\n   *     limit: 100\n   * };\n   * do {\n   *     const res = await client.getTableUsage('MyTable', opt);\n   *     for(const rec of res.usageRecords) {\n   *         console.log(rec);\n   *     }\n   *     opt.startIndex = res.nextIndex;\n   * } while(res.usageRecords.length === opt.limit);\n   * @async\n   * @param {string} tableName Table name\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {Date|string|number} [opt.startTime]  Start time for the time\n   * period.  Can be JavaScript Date, string representing date and time or\n   * number of milliseconds since epoch (January 1, 1970, 00:00:00 UTC).\n   * For string representation see <em>Date.parse()</em>.  If time\n   * range is not specified, the most recent complete usage record is\n   * returned\n   * @param {Date|string|number}  [opt.endTime]  End time for the time\n   * period, represented same as opt.startTime\n   * @param {number} [opt.limit]  Limit to the number of usage records\n   * desired. If not specified or value is 0, there is no limit, but not all\n   * usage records may be returned due to size limitations\n   * @param {number} [opt.startIndex=0] Index at which to start returning\n   * table usage records.  To page table usage records, set this value to\n   * {@link TableUsageResult}#nextIndex returned from previous call to\n   * {@link NoSQLClient#getTableUsage}. These operations are best done in a\n   * loop. See the example\n   * @returns {Promise} Promise of {@link TableUsageResult}\n   * @see {@link TableUsageResult}\n   * @see {@link #tableUsageIterable}\n   */\n  getTableUsage(tableName, opt) {\n    return this._execute(ops.TableUsageOp, {\n      api: this.getTableUsage,\n      tableName,\n      opt\n    });\n  }\n\n  /**\n   * Note: this method is only supported when using the driver with the\n   * Cloud Service.  It is not supported when using the driver with\n   * On-Premise NoSQL Database (see {@link ServiceType.KVSTORE}), in which\n   * case it will result in error.\n   * <p>\n   * Retrieves dynamic information associated with a table, as returned in\n   * {@link TableUsageResult}.\n   * <p>\n   * Use this API when you need to retrieve a\n   * large number of table usage records and you wish to page the results\n   * rather than returning the whole list at once.  The iteration is done\n   * by using <em>for-await-of</em> loop. The iteration is asynchronous and\n   * each step of the iteration returns a Promise of\n   * {@link TableUsageResult}. Using this API is equivalent to paging table\n   * usage records as shown in the example of\n   * {@link NoSQLClient#getTableUsage}.\n   * <p>\n   * Note that you must specify a time range (at least one of\n   * <em>opt.startTime</em> and <em>opt.endTime</em> for which to return\n   * table usage records, otherwise only one (the most recent) table usage\n   * record will be returned.\n   * <p>\n   * You may optionally specify a limit on the number of table usage records\n   * returned in each partial result using <em>opt.limit</em>. If not\n   * specified, a default system limit will be used.\n   * @example <caption>Paging table usage records</caption>\n   * const now = Date.now();\n   * const opt = {\n   *     startTime: now - 3600 * 1000, // last 1 hour\n   *     endTime: now,\n   *     limit: 100\n   * };\n   * for await(const res of client.tableUsageIterable('MyTable', opt)) {\n   *     for(const rec of res.usageRecords) {\n   *         console.log(rec);\n   *     }\n   * }\n   * @param {string} tableName Table name\n   * @param {object} opt Options object. See <em>opt</em> parameter of\n   * {@link NoSQLClient#getTableUsage}.  The same options are available,\n   * except <em>opt.startIndex</em>\n   * @returns {Promise} Promise of {@link TableUsageResult}\n   * @see {@link #getTableUsage}\n   * @since 5.4\n   */\n  tableUsageIterable(tableName, opt) {\n    return this._tableUsageIterable(tableName, opt);\n  }\n\n  /**\n   * Retrieves information about indexes of the table as array of\n   * {@link IndexInfo} objects.\n   * @async\n   * @param {string} tableName Table name\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {string} [opt.indexName]  Return information only about specific\n   * index, same as {@link NoSQLClient#getIndex}.  If not specified,\n   * information on all indexes is returned\n   * @returns {Promise} Promise of {@link IndexInfo}[]\n   * @see {@link IndexInfo}\n   */\n  getIndexes(tableName, opt) {\n    return this._execute(ops.GetIndexesOp, {\n      api: this.getIndexes,\n      tableName,\n      opt\n    });\n  }\n\n  /**\n   * Retrieves information about specific index of the table as\n   * {@link IndexInfo} object.\n   * @async\n   * @param {string} tableName Table name\n   * @param {string} indexName Index name\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @returns {Promise} Promise of {@link IndexInfo}\n   * @see {@link NoSQLClient#getIndexes}\n   */\n  getIndex(tableName, indexName, opt) {\n    return this._getIndex(tableName, indexName, opt);\n  }\n\n  /**\n   * Lists tables, returning table names. If further information about a\n   * specific table is desired the {@link NoSQLClient#getTable} API may be\n   * used.  If a given identity has access to a large number of tables\n   * the list may be paged by using startIndex and limit options.  The list\n   * is returned as string array in {@link ListTablesResult}.  Names\n   * are returned in alphabetical order to facilitate paging.\n   * @async\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information. Only tables belonging to the given compartment (but not\n   * its child compartments) will be listed\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {number} [opt.startIndex]  The index to use to start returning\n   * table names. This is related to the {@link ListTablesResult}#lastIndex\n   * from a previous request and can be used to page table names. If not\n   * set, the list starts at index 0\n   * @param {number} [opt.limit] The maximum number of table names to return\n   * in the operation. If not set or set to 0, there is no limit\n   * @param {string} [opt.namespace] On-premise only.  If set, list tables\n   * from given namespace only, otherwise list all tables for the user.\n   * @returns {Promise} Promise of {@link ListTablesResult}\n   * @see {@link ListTablesResult}\n   */\n  listTables(opt) {\n    return this._execute(ops.ListTablesOp, {\n      api: this.listTables,\n      opt\n    });\n  }\n\n  /**\n   * Gets the row associated with a primary key. On success the value of the\n   * row is available as property of {@link GetResult}. If there are no\n   * matching rows, the operation is still successful the row property will\n   * be set to null.\n   * @async\n   * @param {string} tableName Table name\n   * @param {Key} key Primary {@link Key} of the row\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {Consistency} [opt.consistency] {@link Consistency} used for\n   * the operation.  Defaults to {@link Config}#Consistency\n   * @returns {Promise} Promise of {@link GetResult}\n   * @see {@link Key}\n   * @see {@link GetResult}\n   */\n  get(tableName, key, opt) {\n    return this._execute(ops.GetOp, {\n      api: this.get,\n      tableName,\n      key,\n      opt\n    });\n  }\n\n  /**\n   * Puts a row into a table. This method creates a new row or overwrites\n   * an existing row entirely. The value used for the put must contain a\n   * complete primary key and all required fields.\n   * <p>\n   * It is not possible to put part of a row.  Any fields that are not\n   * provided will be defaulted, overwriting any existing value. Fields that\n   * are not nullable or defaulted must be provided or the operation will\n   * fail.\n   * <p>\n   * By default a put operation is unconditional, but put operations can be\n   * conditional based on existence, or not, of a previous value as well as\n   * conditional on the {@link Version} of the existing value:\n   * <ul>\n   * <li>Use <em>opt.isAbsent</em> to do a put only if there is no existing\n   * row that matches the primary key.</li>\n   * <li>Use <em>opt.ifPresent</em> to do a put only if there is an\n   * existing row that matches the primary key.</li>\n   * <li>Use <em>opt.matchVersion</em> to do a put only if there is an\n   * existing row that matches the primary key <em>and</em> its\n   * {@link Version} matches that provided by <em>opt.matchVersion</em>.\n   * </li>\n   * </ul>\n   * Note that only one of <em>opt.isAbsent</em>, <em>opt.ifPresent</em> or\n   * <em>opt.matchVersion</em> options may be specified for given put\n   * operation.\n   * <p>\n   * It is also possible, on failure, to return information about the\n   * existing row. The row, including its {@link Version} can be optionally\n   * returned if a put operation fails because of a Version mismatch or if\n   * the operation fails because the row already exists. The existing row\n   * information will only be returned if <em>opt.returnExisting</em> is\n   * true and one of the following occurs:\n   * <ul>\n   * <li><em>opt.isAbsent</em> is true and the operation fails because\n   * the row already exists.</li>\n   * <li><em>opt.matchVersion</em> is used and the operation fails because\n   * the row exists and its {@link Version} does not match.</li>\n   * </ul>\n   * The information about the result of the put operation is returned as\n   * {@link PutResult}.  Note that the failure cases discussed above that\n   * resulted from inability to satisfy <em>opt.isAbsent</em>,\n   * <em>opt.ifPresent</em> or <em>opt.matchVersion</em> options are still\n   * considered successful as API calls, i.e. they result in\n   * {@link PutResult} and not {@link NoSQLError}.  See\n   * {@link PutResult}#success.  However if put fails for other reasons,\n   * this API call will result in error instead.\n   *\n   * @async\n   * @param {string} tableName Table name\n   * @param {Row} row Table {@link Row}\n   * @param {object} [opt] Options object:\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {boolean} [opt.ifAbsent] If set to true, do put\n   * only if there is no existing row that matches the primary key\n   * @param {boolean} [opt.ifPresent] If set to true, do put only if\n   * there is existing row that matches the primary key\n   * @param {Version} [opt.matchVersion] If set, do a put only if there is\n   * an existing row that matches the primary key and its {@link Version}\n   * matches the value provided\n   * @param {boolean} [opt.returnExisting] If set to true, existing\n   * row and its version will be returned as part of {@link PutResult}\n   * if put operation fails as per discussion above\n   * @param {Durability} [opt.durability] On-premises only. Set the desired\n   * durability for master/replica sync/acks.  Defaults to\n   * {@link Config}#durability or if not set, the default server-side\n   * durability settings are used. See {@link Durability}\n   * @param {TimeToLive|number} [opt.ttl] Sets {@link TimeToLive} value,\n   * causing the time to live on the row to be set to the specified value\n   * on put. This value overrides any default time to live setting on\n   * the table\n   * @param {boolean} [opt.updateTTLToDefault] If set to true, and\n   * there is an existing row, causes the operation to update the time to\n   * live (TTL) value of the row based on the table's default TTL if set.\n   * If the table has no default TTL this state has no effect.  By default\n   * updating an existing row has no effect on its TTL.  This option cannot\n   * be specified if <em>opt.ttl</em> is specified\n   * @param {boolean} [opt.exactMatch] If true the value must be an exact\n   * match for the table schema or the operation will fail. An exact match\n   * means that there are no required fields missing and that there are no\n   * extra, unknown fields. The default behavior is to not require an exact\n   * match\n   * @param {number} [opt.identityCacheSize] Sets the number of generated\n   * identity values that are requested from the server during a put. This\n   * takes precedence over the DDL identity CACHE option set during creation\n   * of the identity column.  Must be positive integer.  If not set, the DDL\n   * identity CACHE value is used\n   * @returns {Promise} Promise of {@link PutResult}\n   * @see {@link Row}\n   * @see {@link Version}\n   * @see {@link TimeToLive}\n   * @see {@link PutResult}\n   */\n  put(tableName, row, opt) {\n    return this._execute(ops.PutOp, {\n      api: this.put,\n      tableName,\n      row,\n      opt\n    });\n  }\n\n  /**\n   * Performs a put if there is no existing row that matches the primary\n   * key.  This API is a shorthand for {@link NoSQLClient#put} with\n   * <em>opt.ifAbsent</em> set to true.\n   * @async\n   * @param {string} tableName Table name\n   * @param {Row} row Row, same as in {@link NoSQLClient#put}\n   * @param {object} opt Options object, see below\n   * @param {string} [opt.compartment] Same as in {@link NoSQLClient#put}\n   * @param {number} [opt.timeout] Same as in {@link NoSQLClient#put}\n   * @param {Durability} [opt.durability] Same as in {@link NoSQLClient#put}\n   * @param {boolean} [opt.returnExisting] Same as in\n   * {@link NoSQLClient#put}\n   * @param {TimeToLive|number} [opt.ttl] Same as in {@link NoSQLClient#put}\n   * @param {boolean} [opt.exactMatch] Same as in {@link NoSQLClient#put}\n   * @param {number} [opt.identityCacheSize] Same as in\n   * {@link NoSQLClient#put}\n   * @returns {Promise} Promise of {@link PutResult}\n   * @see {@link NoSQLClient#put}\n   */\n  putIfAbsent(tableName, row, opt) {\n    return this._execute(ops.PutOp, {\n      api: this.putIfAbsent,\n      tableName,\n      row,\n      opt: this._assignOpt(opt, {\n        ifAbsent: true\n      })\n    });\n  }\n\n  /**\n   * Performs a put if there is existing row that matches the primary\n   * key.  This API is a shorthand for {@link NoSQLClient#put} with\n   * <em>opt.ifPresent</em> set to true.\n   * @async\n   * @param {string} tableName Table name\n   * @param {Row} row Row, same as in {@link NoSQLClient#put}\n   * @param {object} opt Options object, see below\n   * @param {string} [opt.compartment] Same as in {@link NoSQLClient#put}\n   * @param {number} [opt.timeout] Same as in {@link NoSQLClient#put}\n   * @param {Durability} [opt.durability] Same as in {@link NoSQLClient#put}\n   * @param {TimeToLive|number} [opt.ttl] Same as in {@link NoSQLClient#put}\n   * @param {boolean} [opt.updateTTLToDefault] Same as in\n   * {@link NoSQLClient#put}\n   * @param {boolean} [opt.exactMatch] Same as in {@link NoSQLClient#put}\n   * @param {number} [opt.identityCacheSize] Same as in\n   * {@link NoSQLClient#put}\n   * @returns {Promise} Promise of {@link PutResult}\n   * @see {@link NoSQLClient#put}\n   */\n  putIfPresent(tableName, row, opt) {\n    return this._execute(ops.PutOp, {\n      api: this.putIfPresent,\n      tableName,\n      row,\n      opt: this._assignOpt(opt, {\n        ifPresent: true\n      })\n    });\n  }\n\n  /**\n   * Performs a put if there is an existing row that matches the primary key\n   * and its {@link Version} matches the value provided.  This API is a\n   * shorthand for {@link NoSQLClient#put} with <em>opt.matchVersion</em>\n   * specified.\n   * @async\n   * @param {string} tableName Table name\n   * @param {Row} row Row, same as in {@link NoSQLClient#put}\n   * @param {Version} matchVersion {@link Version} to match\n   * @param {object} opt Options object, see below\n   * @param {string} [opt.compartment] Same as in {@link NoSQLClient#put}\n   * @param {number} [opt.timeout] Same as in {@link NoSQLClient#put}\n   * @param {Durability} [opt.durability] Same as in {@link NoSQLClient#put}\n   * @param {boolean} [opt.returnExisting] Same as in\n   * {@link NoSQLClient#put}\n   * @param {TimeToLive|number} [opt.ttl] Same as in {@link NoSQLClient#put}\n   * @param {boolean} [opt.updateTTLToDefault] Same as in\n   * {@link NoSQLClient#put}\n   * @param {boolean} [opt.exactMatch] Same as in {@link NoSQLClient#put}\n   * @param {number} [opt.identityCacheSize] Same as in\n   * {@link NoSQLClient#put}\n   * @returns {Promise} Promise of {@link PutResult}\n   * @see {@link NoSQLClient#put}\n   */\n  putIfVersion(tableName, row, matchVersion, opt) {\n    return this._execute(ops.PutOp, {\n      api: this.putIfVersion,\n      tableName,\n      row,\n      opt: this._assignOpt(opt, {\n        matchVersion\n      })\n    });\n  }\n\n  /**\n   * Deletes a row from a table. The row is identified using a primary key\n   * value.\n   * <p>\n   * By default a delete operation is unconditional and will succeed if the\n   * specified row exists. Delete operations can be made conditional based\n   * on whether the {@link Version} of an existing row matches that supplied\n   * <em>opt.matchVersion</em>\n   * <p>\n   * It is also possible, on failure, to return information about the\n   * existing row.  The row and its version can be optionally returned as\n   * part of {@link DeleteResult} if a delete operation fails because of\n   * a version mismatch. The existing row information will only be returned\n   * if <em>opt.returnExisting</em> is true and <em>opt.matchVersion</em> is\n   * set and the operation fails because the row exists and its version does\n   * not match.  Use of <em>opt.returnExisting</em> may result in additional\n   * consumed read capacity. If the operation is successful there will be no\n   * information returned about the previous row.\n   * <p>\n   * The information about the result of the delete operation is returned as\n   * {@link DeleteResult}.  Note that the failures to delete if the row\n   * doesn't exist or if <em>opt.matchVersion</em> is set and the version\n   * did not match are still considered successful as API calls, i.e. they\n   * result in {@link DeleteResult} and not {@link NoSQLError}, see\n   * {@link DeleteResult}#success.  However if delete fails for other reasons,\n   * this API call will result in error instead.\n   * @async\n   * @param {string} tableName Table name\n   * @param {Key} key Primary {@link Key} of the row\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {boolean} [opt.returnExisting] If set to true, existing\n   * row and its version will be returned as part of {@link DeleteResult}\n   * if delete operation fails because of version mismatch as discussed\n   * above\n   * @param {Durability} [opt.durability] On-premises only. Set the desired\n   * durability for master/replica sync/acks.  Defaults to\n   * {@link Config}#durability or if not set, the default server-side\n   * durability settings are used. See {@link Durability}\n   * @param {Version} [opt.matchVersion] If set, delete only if\n   * there is an existing row that matches the primary key and its\n   * {@link Version} matches the value provided\n   * @returns {Promise} Promise of {@link DeleteResult}\n   * @see {@link Key}\n   * @see {@link Version}\n   * @see {@link DeleteResult}\n   */\n  delete(tableName, key, opt) {\n    return this._execute(ops.DeleteOp, {\n      api: this.delete,\n      tableName,\n      key,\n      opt\n    });\n  }\n\n  /**\n   * Performs a delete if there is an existing row that matches the primary\n   * key and its {@link Version} matches the value provided.  This API is a\n   * shorthand for {@link NoSQLClient#delete} with <em>opt.matchVersion</em>\n   * specified.\n   * @async\n   * @param {string} tableName Table name\n   * @param {Key} key Primary key, same as in {@link NoSQLClient#delete}\n   * @param {Version} matchVersion {@link Version} to match\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Same as in\n   * {@link NoSQLClient#delete}\n   * @param {number} [opt.timeout] Same as in {@link NoSQLClient#delete}\n   * @param {boolean} [opt.returnExisting] Same as in\n   * {@link NoSQLClient#delete}\n   * @param {Durability} [opt.durability] Same as in\n   * {@link NoSQLClient#delete}\n   * @returns {Promise} Promise of {@link DeleteResult}\n   * @see {@link NoSQLClient#delete}\n   */\n  deleteIfVersion(tableName, key, matchVersion, opt) {\n    return this._execute(ops.DeleteOp, {\n      api: this.deleteIfVersion,\n      tableName,\n      key,\n      opt: this._assignOpt(opt, {\n        matchVersion\n      })\n    });\n  }\n\n  /**\n   * Deletes multiple rows from a table residing on the same shard in an\n   * atomic operation.  A range of rows is specified using a partial primary\n   * key plus a field range based on the portion of the key that is not\n   * provided. The partial primary key must contain all of the fields that\n   * are in the shard key.  For example if a table's primary key is\n   * &lt;id, timestamp&gt; and the its shard key is the id, it is possible\n   * to delete a range of timestamp values for a specific id by providing\n   * a key with an id value but no timestamp value and providing a range\n   * of timestamp values in the <em>opt.fieldRange</em>.  If the field range\n   * is not provided, the operation will delete all rows matching the\n   * partial key.\n   * <p>\n   * The information about the result of this operation will be returned as\n   * [MultiDeleteResult]{@link MultiDeleteResult}.\n   * <p>\n   * Because this operation can exceed the maximum amount of data modified\n   * in a single operation it is possible that it will delete only part of\n   * the range of rows and a continuation key will be set in\n   * [MultiDeleteResult]{@link MultiDeleteResult} that can be\n   * used to continue the operation.\n   * @async\n   * @param {string} tableName Table name\n   * @param {Key} key Partial Primary {@link Key}\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {FieldRange} [opt.fieldRange] Field range based on columns not\n   * provided in partial key.  For more details, see {@link FieldRange}\n   * @param {number} [opt.maxWriteKB] The limit on the total KB write during\n   * this operation.  This value can only reduce the system defined limit.\n   * An attempt to increase the limit beyond the system defined limit will\n   * result in error\n   * @param {Durability} [opt.durability] On-premises only. Set the desired\n   * durability for master/replica sync/acks.  Defaults to\n   * {@link Config}#durability or if not set, the default server-side\n   * durability settings are used. See {@link Durability}\n   * @param {ContinuationKey} [opt.continuationKey] Continuation key\n   * returned in {@link MultiDeleteResult} from the previous call to this\n   * API and can be used to continue this operation.  Operations with a\n   * continuation key still require the primary key\n   * @returns {Promise} Promise of {@link MultiDeleteResult}\n   * @see {@link Key}\n   * @see {@link FieldRange}\n   * @see {@link MultiDeleteResult}\n   */\n  deleteRange(tableName, key, opt) {\n    return opt != null && opt.all ? this._deleteRangeAll(tableName, key, opt) : this._execute(ops.MultiDeleteOp, {\n      api: this.deleteRange,\n      tableName,\n      key,\n      opt\n    });\n  }\n\n  /**\n   * Executes a sequence of put and delete operations associated with\n   * a table or tables that share the same <em>shard key</em> portion of\n   * their primary keys, all the specified operations are executed within\n   * the scope of a single transaction, thus making the operation atomic.\n   * It is an efficient way to atomically modify multiple related rows.\n   * <p>\n   * There are some size-based limitations on this operation:\n   * <ul>\n   * <li>The max number of individual operations (put, delete) in a single\n   * call to this API is 50.</li>\n   * <li>The total request size is limited to 25MB.</li>\n   * </ul>\n   * The result of this operation is returned as\n   * {@link WriteMultipleResult}.  On successful completion, it will store\n   * array of the execution results of all sub operations.  If this\n   * operation was aborted because of failure of a sub operation which has\n   * <em>opt.abortOnFail</em> set to true, then the index and execution\n   * result of the failed sub operation will be stored in\n   * {@link WriteMultipleResult} (thus the API call in this case is still\n   * successful and no error results).\n   * <p>\n   * Note that in addition to <em>opt</em> argument of this API, each\n   * sub operation may have its own <em>opt</em> property as\n   * {@link WriteOperation}#opt specifying options pertaining to particular\n   * put or delete sub operation, see {@link NoSQLClient#put} and\n   * {@link NoSQLClient#delete} (the only exception is <em>timeout</em>\n   * which can only be specified for the whole operation in <em>opt</em>\n   * argument).  Each option value explicitly set in\n   * {@link WriteOperation#opt} will take precedence over its value in\n   * <em>opt</em> argument, otherwise the <em>opt</em> argument can be used\n   * to specify options that should be the same for all sub operations.\n   * <p>\n   * It is possible to issue operations for multiple tables as long as\n   * these tables have the same shard key.  This means that these tables\n   * must be part of the same parent/child table hierarchy that has a single\n   * ancestor table specifying the shard key (you may include operations for\n   * this ancestor table and/or any of its descendants).  To issue\n   * operations for multiple tables, omit the <em>tableName</em> parameter\n   * (and thus use <em>writeMany(operations[, opt])</em>) and specify\n   * table per operation as {@link WriteOperation}#tableName.\n   * @async\n   * @param {string} [tableName] Table name, if all operations are for a\n   * single table.  If issuing operations for multiple tables, omit this\n   * parameter and specify table name for each operation as\n   * {@link WriteOperation}#tableName. Specifying this parameter together\n   * with {@link WriteOperation}#tableName for any operation will result in\n   * error\n   * @param {WriteOperation[]} operations Array of\n   * {@link WriteOperation} objects each representing single put or delete\n   * operation, see {@link WriteOperation}\n   * @param {object} [opt] Options object, specifies options that should be\n   * same for all put and delete sub operations (options relevant\n   * only to put but not to delete will be ignored for delete operations).\n   * Options for specific sub operation, other than <em>timeout</em>,\n   * <em>compartment</em> and <em>durability</em> may be specified in\n   * {@link WriteOperation} and will override values specified here. For\n   * list of options, see {@link WriteOperation}\n   * @param {Durability} [opt.durability] On-premises only. Set the desired\n   * durability for master/replica sync/acks.  Defaults to\n   * {@link Config}#durability or if not set, the default server-side\n   * durability settings are used. See {@link Durability}\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @returns {Promise} Promise of {@link WriteMultipleResult}\n   */\n  writeMany(tableName, operations, opt) {\n    //Check if tableName parameter was omitted and operations is the first\n    //parameter.\n    if (Array.isArray(tableName) && !Array.isArray(operations)) {\n      opt = operations;\n      operations = tableName;\n      tableName = undefined;\n    }\n    return this._execute(ops.WriteMultipleOp, {\n      api: this.writeMany,\n      tableName,\n      ops: operations,\n      opt\n    });\n  }\n\n  /**\n   * Executes a sequence of put operations associated with a table that\n   * share the same <em>shard key</em> portion of their primary keys, all\n   * the specified operations are executed within the scope of single\n   * transaction, thus making the operation atomic.\n   * This API is a shortcut to {@link NoSQLClient#writeMany} with the\n   * following simplifications:\n   * <ul>\n   * <li>The sequence contains only put operations.</li>\n   * <li>All operations are for a single table.</li>\n   * <li>Options are specified only in the <em>opt</em> argument of this API\n   * and are same for all put sub operations (no per-sub-operation options).\n   * </li>\n   * </ul>\n   * This API may be more convenient to use than\n   * {@link NoSQLClient#writeMany} when applicable.\n   * @async\n   * @param {string} tableName\n   * @param {Row[]} rows Array of rows to put, see\n   * {@link Row}\n   * @param {object} [opt] Options object.  All options are the same as in\n   * {@link NoSQLClient#put}, besides an additional <em>abortOnFail</em>\n   * option, see below\n   * @param {boolean} [opt.abortOnFail] If set to true, aborts the whole\n   * transaction if any of the puts fails.  This is only applicable to\n   * failures due to inability to satisfy <em>opt.ifAbsent</em>,\n   * <em>opt.ifPresent</em> or <em>opt.matchVersion</em> options, see\n   * discussion in {@link NoSQLClient#put}.  Other failures will result\n   * in error\n   * @returns {Promise} Promise of {@link WriteMultipleResult}\n   */\n  putMany(tableName, rows, opt) {\n    return this._execute(ops.WriteMultipleOp, {\n      api: this.putMany,\n      tableName,\n      rows,\n      opt\n    });\n  }\n\n  /**\n   * Executes a sequence of delete operations associated with a table that\n   * share the same <em>shard key</em> portion of their primary keys, all\n   * the specified operations are executed within the scope of single\n   * transaction, thus making the operation atomic.\n   * This API is a shortcut to {@link NoSQLClient#writeMany} with the\n   * following simplifications:\n   * <ul>\n   * <li>The sequence contains only delete operations.</li>\n   * <li>All operations are for a single table.</li>\n   * <li>Options are specified only in the <em>opt</em> argument of this API\n   * and are same for all delete sub-operations (no per-sub-operation\n   * options).</li>\n   * </ul>\n   * This API may be more more convenient to use than\n   * {@link NoSQLClient#writeMany} when applicable.\n   * @async\n   * @param {string} tableName\n   * @param {Key[]} keys Array of primary keys to delete,\n   * see {@link Key}\n   * @param {object} [opt] Options object.  All options are the same as in\n   * {@link NoSQLClient#delete}, besides an additional <em>abortOnFail</em>\n   * option, see below\n   * @param {boolean} [opt.abortOnFail] If set to true, aborts the whole\n   * transaction if any of the deletes fails.  This is only applicable to\n   * failures due non-existence of the row or inability to match\n   * <em>opt.matchVersion</em>, see discussion in\n   * {@link NoSQLClient#delete}.  Other failures will result in error\n   * @returns {Promise} Promise of {@link WriteMultipleResult}\n   */\n  deleteMany(tableName, keys, opt) {\n    return this._execute(ops.WriteMultipleOp, {\n      api: this.deleteMany,\n      tableName,\n      keys,\n      opt\n    });\n  }\n\n  /**\n   * Prepares a query for execution and reuse. See {@link NoSQLClient#query}\n   * for general information and restrictions. It is recommended that\n   * prepared queries are used when the same query will run multiple times\n   * as execution is much more efficient than starting with a query string\n   * every time. The query language and API support query variables to\n   * assist with re-use.\n   * <p>\n   * The result of this operation is {@link PreparedStatement}.  It supports\n   * bind variables in queries which can be used to more easily reuse a\n   * query by parameterization, see {@link PreparedStatement} for details.\n   * @async\n   * @param {string} stmt Query SQL statement\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {boolean} [opt.getQueryPlan] If <em>true</em>, requests a\n   * printout of query execution plan to be included in the returned\n   * {@link PreparedStatement} as {@link PreparedStatement#queryPlan}\n   * @param {boolean} [opt.getResultSchema] If <em>true</em>, requests a\n   * JSON value of query result schema to be included in the returned\n   * {@link PreparedStatement} as {@link PreparedStatement#resultSchema}\n   * @returns {Promise} Promise of {@link PreparedStatement}\n   */\n  prepare(stmt, opt) {\n    return this._prepare(stmt, opt);\n  }\n\n  /**\n   * Queries a table based on the query statement.\n   * <p>\n   * Queries that include a full shard key will execute much more\n   * efficiently than more distributed queries that must go to multiple\n   * shards.\n   * <p>\n   * DDL-style queries such as \"CREATE TABLE ...\" or \"DROP TABLE ..\" are not\n   * supported by this API. Those operations must be performed using\n   * {@link NoSQLClient#tableDDL}.\n   * <p>\n   * For performance reasons prepared queries are preferred for queries that\n   * may be reused. Prepared queries bypass compilation of the query. They\n   * also allow for parameterized queries using bind variables, see\n   * {@link NoSQLClient#prepare}.\n   * <p>\n   * The result of this operation is returned as {@link QueryResult}.  It\n   * contains array of result records and may contain continuation key as\n   * {@link QueryResult}#continuationKey.\n   * <p>\n   * The amount of data read by a single query request is limited by a\n   * system default and can be further limited by setting\n   * <em>opt.maxReadKB</em>. This limits the amount of data <em>read</em>\n   * and not the amount of data <em>returned</em>, which means that a query\n   * can return zero results but still have more data to read. This\n   * situation is detected by checking if the {@link QueryResult} has a\n   * continuation key.  In addition, number of results returned by the query\n   * may be explicitly limited by setting <em>opt.limit</em>. For this\n   * reason queries should always operate in a loop, acquiring more results,\n   * until the continuation key is null, indicating that the query is done.\n   * Inside the loop the continuation key is applied to\n   * {@link NoSQLClient#query} by setting <em>opt.continuationKey</em>.\n   *\n   * @async\n   * @param {string|PreparedStatement} stmt Query statement, can be either\n   * SQL query string or a prepared query represented as\n   * {@link PreparedStatement}, see {@link NoSQLClient#prepare}\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#timeout\n   * @param {Consistency} [opt.consistency] {@link Consistency} used for the\n   * operation.  Defaults to {@link Config}#consistency\n   * @param {Durability} [opt.durability] On-premises only.\n   * {@link Durability} value used for the update query operation.  Defaults\n   * to {@link Config}#durability or if not set, default server-side\n   * durability settings are used. This option only applies for update\n   * queries, i.e. queries issued via INSERT, UPDATE, UPSERT and DELETE\n   * statements. For read-only SELECT queries this option is ignored\n   * @param {number} [opt.limit] Sets the limit on number of rows returned\n   * by the operation. This allows an operation to return less than the\n   * default amount of data\n   * @param {number} [opt.maxReadKB] Sets the limit on the total data read\n   * during this operation, in KB.  This value can only reduce the system\n   * defined limit. An attempt to increase the limit beyond the system\n   * defined limit will result in error. This limit is independent of read\n   * units consumed by the operation\n   * @param {number} [opt.maxWriteKB] Sets the limit on the total data\n   * written during this operation, in KB.  Relevant for update and delete\n   * queries.  This value can only reduce the system defined limit. An\n   * attempt to increase the limit beyond the system defined limit will\n   * result in error. This limit is independent of the write units consumed\n   * by the operation\n   * @param {number} [opt.maxMemoryMB] Maximum amount of memory in megabytes\n   * that may be used locally in this query execution for operations such as\n   * duplicate elimination (which may be required if using an index on an\n   * array or a map) and sorting. Such operations may require significant\n   * amount of memory as they need to cache full result set or a large\n   * subset of it in locally. If memory consumption exceeds this value,\n   * error will result.  Default is 1GB.  Defaults to\n   * {@link Config}#maxMemoryMB\n   * @param {ContinuationKey} [opt.continuationKey] Continuation key\n   * returned in {@link QueryResult} from previous call to this API used to\n   * continue the query.  If there are no more results,\n   * continuation key will be null.  Note that it is possible that\n   * continuation key is not null, but the query has no more\n   * results remaining.  In this case the next call to\n   * {@link NoSQLClient#query} will result in {@link QueryResult}#rows being\n   * empty array and next continuation key being null.  This is possible if\n   * the previous call to {@link NoSQLClient#query} fetched all remaing rows\n   * in the result set but was stopped due to the set limitations, including\n   * <em>opt.maxReadKB</em> or <em>opt.limit</em>.  In this case the server\n   * will not look ahead to check if any more results remain\n   * @returns {Promise} Promise of {@link QueryResult}\n   */\n  query(stmt, opt) {\n    return this._query(stmt, opt);\n  }\n\n  /**\n   * This API facilitates iteration over query results returned by\n   * {@link NoSQLClient#query} by using <em>for-await-of</em> loop.  The\n   * iteration over query results is necessary because of the limitations\n   * on the amount of data read during each query request as described in\n   * {@link NoSQLClient#query}.  The iteration is asynchronous and each\n   * step of the iteration returns a Promise of {@link QueryResult}.  Using\n   * this API is internally equivalent to calling {@link NoSQLClient#query}\n   * in a loop and using continuation key returned in {@link QueryResult} to\n   * continue the query.  Thus you do not need to explicitly manage\n   * continuation key when using this API.\n   * <p>\n   * Note that calling this API by itself does not start\n   * the query, the query is started when starting the iteration via\n   * <em>for-await-of</em> loop.\n   * <p>\n   * The returned iterable cannot be reused for multiple queries.\n   * To execute another query, call {@link NoSQLClient#queryIterable} again\n   * to create a new iterable.\n   * <p>\n   * All other considerations described in {@link NoSQLClient#query} apply\n   * when using this API.\n   * @example // Using {@link NoSQLClient#queryIterable}\n   * try {\n   *     const stmt = 'SELECT * from orders';\n   *     for await(const res of client.queryIterable(stmt)) {\n   *         console.log(`Retrieved ${res.rows.length} rows`);\n   *         // Do something with res.rows\n   *     }\n   * } catch(err) {\n   *     // handle errors\n   * }\n   * @param {string|PreparedStatement} stmt Query statement, same as for\n   * {@link NoSQLClient#query}\n   * @param {object} [opt] Options object.  All options are same as for\n   * {@link NoSQLClient#query}, except that <em>continuationKey</em> is not\n   * used (it will be ignored if set)\n   * @returns {object} Async iterable to iterate over query results using\n   * <em>for-await-of</em> loop.\n   * @see {@link NoSQLClient#query}\n   */\n  queryIterable(stmt, opt) {\n    return this._queryIterable(stmt, opt);\n  }\n\n  /**\n   * On-premise only.\n   * <p>\n   * Performs an administrative operation on the system.  The operations\n   * allowed are defined by Data Definition Language (DDL) portion of the\n   * query language that do not affect a specific table. For table-specific\n   * DLL operations use {@link NoSQLClient#tableDDL}.\n   * <p>\n   * Examples of statements passed to this method include:\n   * <ul>\n   * <li>CREATE NAMESPACE mynamespace</li>\n   * <li>CREATE USER some_user IDENTIFIED BY password</li>\n   * <li>CREATE ROLE some_role</li>\n   * <li>GRANT ROLE some_role TO USER some_user</li>\n   * </ul>\n   * <p>\n   * <p>\n   * Note that these are potentially long-running operations, so the\n   * result returned by this API does not imply operation completion.  The\n   * caller should use the {@link NoSQLClient#adminStatus} method to check\n   * the status of the operation or {@link NoSQLClient#forCompletion} to\n   * asynchronously wait for the operation completion.\n   * <p>\n   * Alternatively, if <em>opt.complete</em> is set to true, this API will\n   * complete (i.e. the returned <em>Promise</em> will resolve) only\n   * when the operation is completed.  This is equivalent to sequentially\n   * executing {@link NoSQLClient#adminDDL} and\n   * {@link NoSQLClient#forCompletion}.  In this case, <em>opt.timeout</em>\n   * covers the whole time interval until operation completion.\n   * If not specified, separate default timeouts are used for issuing the\n   * DDL operation and waiting for its completion, with values of\n   * {@link Config}#ddlTimeout and {@link Config}#adminPollTimeout\n   * correspondingly (the latter defaults to no timeout if\n   * {@link Config}#adminPollTimeout is not set).  You may also use\n   * <em>opt.delay</em> to specify polling delay (see\n   * {@link NoSQLClient#forCompletion}).\n   * <p>\n   * Note that some of the statements used by admin DDL may contain\n   * passwords in which case it is advisable to pass the statement as\n   * <em>Buffer</em> so that the memory can be subsequently cleared by the\n   * application.  The <em>Buffer</em> should contain the statement as\n   * UTF-8 encoded string.\n   * @async\n   * @param {Buffer|string} stmt Statement for the operation as string or\n   * Buffer containing UTF-8 encoded string\n   * @param {object} [opt] Options object, see below\n   * @param {number} [opt.timeout] Timeout for the operation in\n   * milliseconds.  Defaults to {@link Config}#ddlTimeout (if\n   * <em>opt.complete</em> is true, separate default timeouts are used for\n   * issuing the DDL operation and waiting for its completion, with values\n   * of {@link Config}#ddlTimeout and {@link Config}#adminPollTimeout\n   * correspondingly)\n   * @param {boolean} [opt.complete] If set to true, the returned\n   * <em>Promise</em> will only resolve when the operation is completed\n   * @param {number} [opt.delay] If <em>opt.complete</em> is true, specifies\n   * delay between successive polls while waiting for operation completion.\n   * Defaults to {@link Config}#adminPollDelay.  Has no effect if\n   * <em>opt.complete</em> is not enabled\n   * @returns {Promise} Promise of {@link AdminResult}\n   * @see {@link AdminResult}\n   * @see {@link NoSQLClient#forCompletion}\n   */\n  adminDDL(stmt, opt) {\n    const req = {\n      api: this.adminDDL,\n      stmt,\n      opt\n    };\n    return opt != null && opt.complete ? this._withCompletion(ops.AdminDDLOp, req) : this._execute(ops.AdminDDLOp, req);\n  }\n\n  /**\n   * On-premise only.\n   * <p>\n   * Check the status of the operation performed by\n   * {@link NoSQLClient#adminDDL}.  Returns the status of the operation\n   * as {@link AdminResult}, that includes operation state and operation\n   * output if any.\n   * @async\n   * @param {AdminResult} adminResult Result returned by\n   * {@link NoSQLClient#adminDDL}\n   * @param {object} [opt] Options object, see below\n   * @param {object} [opt.timeout]  Timeout for the operation in\n   * milliseconds, defaults to {@link Config}#timeout\n   * @returns {Promise} Promise of {@link AdminResult}\n   * @see {@link NoSQLClient#adminDDL}\n   * @see {@link AdminResult}\n   */\n  adminStatus(adminResult, opt) {\n    return this._adminStatus({\n      api: this.adminStatus,\n      adminResult,\n      opt\n    });\n  }\n\n  /**\n   * Asynchronously waits for DDL operation completion.\n   * <p>\n   * DDL operations are operations initiated by {@link NoSQLClient#tableDDL}\n   * and {@link NoSQLClient#adminDDL} (the latter On-premise only).  These\n   * are potentially long-running operations and the results returned by\n   * {@link NoSQLClient#tableDDL} or {@link NoSQLClient#adminDDL} do not\n   * imply operation completion.  {@link NoSQLClient#forCompletion} takes\n   * the result of either operation as an argument and completes (i.e. the\n   * returned <em>Promise</em> resolves) when the corresponding operation\n   * is completed by the service.  This is accomplished by polling the\n   * operation state at specified intervals using\n   * {@link NoSQLClient#getTable} for table DDL operations and\n   * {@link NoSQLClient#adminStatus} for admin DDL operations.\n   * <p>\n   * For table DDL operations initiated by {@link NoSQLClient#tableDDL} this\n   * method asynchronously waits for state {@link TableState.ACTIVE} for all\n   * operations except \"DROP TABLE\", in the latter case asynchronously\n   * waiting for {@link TableState.DROPPED}.\n   * <p>\n   * The result of this method is {@link TableResult} or {@link AdminResult}\n   * representing the state of the operation at the last poll.  If the\n   * operation fails, this method will result in error (i.e. the returned\n   * <em>Promise</em> will reject with error) contaning information about\n   * the operation failure.\n   * <p>\n   * Note that on operation completion, the passed {@link TableResult} or\n   * {@link AdminResult} is modified in place (to reflect operation\n   * completion) in addition to being returned.\n   * <p>\n   * As a more convenient way to perform DDL operations to completion, you\n   * may pass <em>opt.complete</em> to {@link NoSQLClient#tableDDL} or\n   * {@link NoSQLClient#adminDDL}.  In this case, after DDL operation is\n   * initiated, these methods will internally use\n   * {@link NoSQLClient#forCompletion} to await operation completion.\n   * @example // Using {@link NoSQLClient#forCompletion}\n   * try {\n   *     let res = await client.tableDDL('DROP TABLE.....');\n   *     await client.forCompletion(res);\n   *     res = await client.adminDDL('CREATE NAMESPACE.....');\n   *     await client.forCompletion(res);\n   * } catch(err) {\n   *     // May be caused by client.forCompletion() if long running DDL\n   *     // operation was unsuccessful.\n   * }\n   * @async\n   * @param {TableResult|AdminResult} res Result of\n   * {@link NoSQLClient#tableDDL} or {@link NoSQLClient#adminDDL}.  This\n   * result is modified by this method on operation completion.\n   * @param {object} [opt] Options object, see below\n   * @param {string} [opt.compartment] Cloud service only. Compartment id\n   * or name to use for this operation. Defaults to\n   * {@link Config}#compartment. See {@link Config}#compartment for more\n   * information\n   * @param {number} [opt.timeout] Timeout in milliseconds, i.e. how\n   * long to keep polling for operation completion.  Defaults to\n   * {@link Config}#tablePollTimeout for table DDL operations or to\n   * {@link Config}#adminPollTimeout for admin DDL operations\n   * @param {number} [opt.delay] Delay in milliseconds between\n   * successive polls, determines how often the polls are performed.\n   * Defaults to {@link Config}#tablePollDelay for table DDL operations or\n   * to {@link Config}#adminPollDelay for admin DDL operations\n   * @returns {Promise} Promise of {@link TableResult} or\n   * {@link AdminResult}, which is the object passed as first argument and\n   * modified to reflect operation completion\n   * @see {@link NoSQLClient#tableDDL}\n   * @see {@link NoSQLClient#getTable}\n   * @see {@link TableResult}\n   * @see {@link NoSQLClient#adminDDL}\n   * @see {@link NoSQLClient#adminStatus}\n   * @see {@link AdminResult}\n   */\n  forCompletion(res, opt) {\n    return this._forCompletion(res, opt);\n  }\n\n  /**\n   * On-premise only.\n   * <p>\n   * Returns the namespaces in the store as an array of strings.  If no\n   * namespaces are found, empty array is returned.\n   * <p>\n   * This operation entails executing admin DDL and waiting for the\n   * operation completion.\n   * @async\n   * @param {object} [opt] Options object, see below\n   * @param {number} [opt.timeout=30000] Timeout for the operation in\n   * milliseconds\n   * @param {number} [opt.delay] Same as in {@link NoSQLClient#adminDDL}\n   * @returns {Promise} Promise of string[] of namespace names\n   * @see {@link NoSQLClient#adminDDL}\n   */\n  listNamespaces(opt) {\n    return this._listNamespaces(opt);\n  }\n\n  /**\n   * On-premise only.\n   * <p>\n   * Returns the users in the store as an array of {@link UserInfo}.  If no\n   * users are found, empty array is returned.\n   * <p>\n   * This operation entails executing admin DDL and waiting for the\n   * operation completion.\n   * @async\n   * @param {object} [opt] Options object, see below\n   * @param {number} [opt.timeout=30000] Timeout for the operation in\n   * milliseconds\n   * @param {number} [opt.delay] Same as in {@link NoSQLClient#adminDDL}\n   * @returns {Promise} Promise of {@link UserInfo}[] of objects containing\n   * information about each user\n   * @see {@link UserInfo}\n   * @see {@link NoSQLClient#adminDDL}\n   */\n  listUsers(opt) {\n    return this._listUsers(opt);\n  }\n\n  /**\n   * On-premise only.\n   * <p>\n   * Returns the roles in the store as an array of strings.  If no\n   * roles are found, empty array is returned.\n   * <p>\n   * This operation entails executing admin DDL and waiting for the\n   * operation completion.\n   * @async\n   * @param {object} [opt] Options object, see below\n   * @param {number} [opt.timeout=30000] Timeout for the operation in\n   * milliseconds\n   * @param {number} [opt.delay] Same as in {@link NoSQLClient#adminDDL}\n   * @returns {Promise} Promise of string[] of role names\n   * @see {@link NoSQLClient#adminDDL}\n   */\n  listRoles(opt) {\n    return this._listRoles(opt);\n  }\n  addReplica(tableName, region, opt) {\n    const req = {\n      api: this.addReplica,\n      tableName,\n      region,\n      opt\n    };\n    return opt != null && opt.complete ? this._withCompletion(ops.AddReplicaOp, req) : this._execute(ops.AddReplicaOp, req);\n  }\n  dropReplica(tableName, region, opt) {\n    const req = {\n      api: this.dropReplica,\n      tableName,\n      region,\n      opt\n    };\n    return opt != null && opt.complete ? this._withCompletion(ops.DropReplicaOp, req) : this._execute(ops.DropReplicaOp, req);\n  }\n  forLocalReplicaInit(tableName, opt) {\n    return this._forLocalReplicaInit(tableName, opt);\n  }\n  getReplicaStats(tableName, opt) {\n    return this._execute(ops.ReplicaStatsOp, {\n      api: this.getReplicaStats,\n      tableName,\n      opt\n    });\n  }\n\n  /**\n   * For testing only.\n   * @returns {number} The current serial version in use\n   */\n  getSerialVersion() {\n    return this._getSerialVersion();\n  }\n}\n\n/**\n * NoSQLClient error event.\n *\n * Emitted when any {@link NoSQLClient} method results in error.  This event\n * is not emitted when automatic retries are performed, only when the error is\n * final.\n * <p>\n * Also mote that this event will not be emitted if it has no listeners, so it\n * is not necessary to subscribe to it.\n *\n * @event NoSQLClient#error\n * @param {NoSQLError} err Error of type NoSQLError or one of its subclasses\n * @param {Operation} op Object describing operation that\n * caused the error, see {@link Operation}\n */\n\n/**\n * NoSQLClient retryable event.\n *\n * Emitted when error from {@link NoSQLClient} operation will result in\n * automatic retry of operation.  It will be emitted on each subsequent retry.\n * @see {@link RetryConfig} for explanation of retries\n *\n * @event NoSQLClient#retryable\n * @param {NoSQLError} err Error of type NoSQLError or one of its subclasses\n * that caused the retry\n * @param {Operation} op Object describing operation that caused the error,\n * see {@link Operation}\n * @param {number} numRetries Number of retries performed so far for this\n * operation, not counting the original API invokation or the retry about to\n * be performed\n */\n\n/**\n * NoSQLClient consumedCapacity event.\n *\n * Emitted by {@link NoSQLClient} method calls that return\n * {@link ConsumedCapacity} as part of their result.  These methods include\n * all data manipulation and query methods.  This event may be used to\n * calculate relevant statistsics.\n *\n * @event NoSQLClient#consumedCapacity\n * @param {ConsumedCapacity} consumedCapacity Capacity consumed by the method\n * call, {@link ConsumedCapacity}\n * @param {Operation} op Object describing operation that returned this consumed\n * capacity, see {@link Operation}\n */\n\n/**\n * NoSQLClient tableState event.\n *\n * Emitted by {@link NoSQLClient} method calls that return table state as part\n * of their result, such as {@link NoSQLClient#getTable},\n * {@link NoSQLClient#tableDDL} and {@link NoSQLClient#setTableLimits} and\n * also while table is polled waiting for DDL operation completion using\n * {@link NoSQLClient#forCompletion}.  Can be used to perform actions on a\n * table reaching certain state.  Note that this event may be emitted mutliple\n * times even while the table state did not change.\n *\n * @event NoSQLClient#tableState\n * @param {string} tableName Table name\n * @param {TableState} tableState Current table state, see {@link TableState}\n */\n\nmodule.exports = NoSQLClient;","map":{"version":3,"names":["ops","require","NoSQLClientImpl","NoSQLClient","constructor","config","version","PACKAGE_VERSION","serviceType","_config","close","precacheAuth","_precacheAuth","tableDDL","stmt","opt","req","api","complete","_withCompletion","TableDDLOp","_execute","setTableLimits","tableName","tableLimits","_assignOpt","TableLimitsOp","setTableTags","definedTags","freeFormTags","getTable","table","GetTableOp","forTableState","tableState","_forTableState","getTableUsage","TableUsageOp","tableUsageIterable","_tableUsageIterable","getIndexes","GetIndexesOp","getIndex","indexName","_getIndex","listTables","ListTablesOp","get","key","GetOp","put","row","PutOp","putIfAbsent","ifAbsent","putIfPresent","ifPresent","putIfVersion","matchVersion","delete","DeleteOp","deleteIfVersion","deleteRange","all","_deleteRangeAll","MultiDeleteOp","writeMany","operations","Array","isArray","undefined","WriteMultipleOp","putMany","rows","deleteMany","keys","prepare","_prepare","query","_query","queryIterable","_queryIterable","adminDDL","AdminDDLOp","adminStatus","adminResult","_adminStatus","forCompletion","res","_forCompletion","listNamespaces","_listNamespaces","listUsers","_listUsers","listRoles","_listRoles","addReplica","region","AddReplicaOp","dropReplica","DropReplicaOp","forLocalReplicaInit","_forLocalReplicaInit","getReplicaStats","ReplicaStatsOp","getSerialVersion","_getSerialVersion","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/nosql_client.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst ops = require('./ops');\nconst NoSQLClientImpl = require('./nosql_client_impl');\n\n/**\n * Defines NoSQLClient, which is the point of access to the\n * Oracle NoSQL Database Cloud service.\n */\n\n/**\n * @classdesc NoSQLClient class provides access to Oracle NoSQL Database\n * tables.  Methods of this class are used to create and manage tables and\n * indexes, and to read and write data. All operations are performed\n * asynchronously.\n * <p>\n * Each method returns a Promise object that will resolve to the\n * result of the operation if successful, or reject with an error upon\n * failure. To handle results and errors, you may use promise chains\n * with .then.catch or async functions with await.  The result of\n * operation is a JavaScript object with properties specific to each\n * operation and is documented for each method below.  If any error\n * has occurred, the promise will reject with {@link NoSQLError} or\n * one of its subclasses.\n * <p>\n * You instantiate NoSQLClient by providing connection and credential\n * information, either in the form of a configuration object of type\n * {@link Config} or a path to a file that holds {@link Config} information.\n * Some parameters, such as the service endpoint or region, are required.\n * Other parameters are optional and need not be specified in the\n * {@link Config}. Default values are used for optional parameters.\n * <p>\n * Note that it is possible to create {@link NoSQLClient} instance without\n * providing configuration if all of the following are true:\n * <ul>\n * <li>You are using {@link NoSQLClient} with the Cloud Service.</li>\n * <li>You store your credentials and region identifier in an OCI configuration\n * file with the default file path and default profile name.  See\n * {@link IAMConfig} for more information.</li>\n * <li>You use defaults for all other configuration properties.</li>\n * </ul>\n * <p>\n * Each method of NoSQLClient also takes an optional <em>opt</em>\n * parameter which contains options specific to a particular\n * operation.  Some of these options may be the same as those\n * specified by {@link Config} and will override the {@link Config}\n * values for this operation.  The method description describes which\n * options are pertinent for that operation. If an options is not\n * specified in the <em>opt</em> parameter and is also not present in\n * {@link Config}, the driver will use default values.\n * <p>\n * In general, same methods and options are applicable to both Oracle\n * NoSQL Database Cloud Service and On-Premise Oracle NoSQL Database.\n * However, some methods, options and result types may be specific to\n * particular {@link ServiceType}, which is specified in their documentation.\n * <p>\n * <em>For cloud service only:</em> for each method you may provide\n * <em>opt.compartment</em> which specifies the compartment of the given table\n * (or compartment used to perform given operation).  If not set in options or\n * initial config (see {@link Config}#compartment), the root\n * compartment of the tenancy is assumed. The compartment is a string that\n * may be either the id (OCID) of the compartment or a compartment name. Both\n * are acceptable. If a name is used it can be either the name of a top-level\n * compartment, or for nested compartments, it should be a compartment path\n * to the nested compartment that does not include the root compartment name\n * (tenant), e.g. <em>compartmentA.compartmentB.compartmentC</em>\n * <p>\n * Alternatively, instead of setting <em>opt.compartment</em>\n * you may prefix the table name with its compartment name (for top-level\n * compartments) or compartment path (for nested compartments), e.g.\n * <em>compartmentA.compartmentB.compartmentC:myTable</em>.\n * Note that the table name cannot be\n * prefixed with compartment id.  Prefixing the table with compartment\n * name/path takes precendence over other methods of specifying the\n * compartment.\n *\n * @fires NoSQLClient#error\n * @fires NoSQLClient#retryable\n * @fires NoSQLClient#consumedCapacity\n * @fires NoSQLClient#tableState\n *\n * @tutorial connect-cloud\n * @tutorial connect-on-prem\n * @tutorial tables\n *\n * @example // Using NoSQLClient with async-await\n *\n * const NoSQLClient = require('oracle-nosqldb').NoSQLClient;\n *\n * async function test() {\n *      let client;\n *      try {\n *          client = new NoSQLClient('config.json');\n *          let res = await client.tableDDL(\n *              'CREATE TABLE foo(id INTEGER, name STRING, PRIMARY KEY(id))',\n *              {\n *                  tableLimits: {\n *                      readUnits: 100,\n *                      writeUnits: 100,\n *                      storageGB: 50\n *                  }\n *              }\n *          );\n *          console.log('Table: %s, state: %s', res.tableName,\n *              res.tableState);\n *          await client.forCompletion(res);\n *          res = await client.put('foo', { id: 1, name: 'test' });\n *          res = await client.get('foo', { id: 1 });\n *          console.log(res.row);\n *          //..........\n *      } catch(err) {\n *          //handle errors\n *      } finally {\n *          if (client) {\n *              client.close();\n *          }\n *      }\n * }\n */\nclass NoSQLClient extends NoSQLClientImpl {\n\n    /**\n     * Constructs an instance of NoSQLClient. This function is synchronous.\n     * @param {string|Config|null} [config] Configuration for NoSQL client.\n     * May be either a string indicating the file path to a configuration\n     * file, or a {@link Config} object. If a file path is supplied,\n     * the path can be absolute or relative to the current directory\n     * of the application. The file should contain the {@link Config} object\n     * and can be either JSON or JavaScript (in the latter case its\n     * <em>module.exports</em> should be set to the {@link Config} object).\n     * Note that you may pass <em>null</em> or omit this parameter (use\n     * no-argument constructor) if using the cloud service with the default OCI\n     * configuration file that contains credentials and region identifier, as\n     * described above\n     * @throws {NoSQLArgumentError} if the configuration is\n     * missing required properties or contains invalid property values\n     * @see {@link Config}\n     */\n    constructor(config) {\n        super(config);\n    }\n\n    /**\n     * Returns the version of the driver.\n     * @returns {string} The version of the driver\n     */\n    static get version() {\n        return require('./constants').PACKAGE_VERSION;\n    }\n\n    /**\n     * Returns the service type of used by this {@link NoSQLClient} instance.\n     * @returns {ServiceType} Service type\n     */\n    get serviceType() {\n        return this._config.serviceType;\n    }\n\n    /**\n     * Releases resources associated with NoSQLClient.  This method must be\n     * called after NoSQLClient is no longer needed.\n     * @returns {Promise} Promise, which may be resolved if closing\n     * the client did not require asynchronous operations.  The resolved\n     * value is ignored.  Currently, the close may need to perform\n     * asynchronous operation only when using {@link ServiceType.KVSTORE},\n     * otherwise resolved Promise is returned.  The Promise should not reject\n     * (rather log the error if any), so you only need to <em>await</em> for\n     * it if you need to perform an action upon its completion.\n     * @see {@link ServiceType}\n     */\n    close() {\n        return super.close();\n    }\n\n    /**\n     * Obtains and caches authorization information in advance of performing\n     * database operations.\n     * <p>\n     * Built-in authorization providers use with this SDK obtain authorization\n     * information such as authorization signature or token and cache it for\n     * some time.  In some instances, obtaining this information make take\n     * some time, especially in cases when a network request to authorization\n     * server is required, e.g. when using Cloud Service with Instance\n     * Principal (see {@link IAMConfig}).  By default, this information is\n     * obtained on demand when database operation is issued and this may cause\n     * timeout errors if the default timeout for database operations is not\n     * sufficient to obtain this information.  You may call this method to\n     * obtain and pre-cache authorization information, so that when database\n     * operations are issued, they do not need to spend any extra time on\n     * obtaining authorization.\n     * <p> A current use case for this method is when using Cloud Service\n     * with Instance Principal, because a network request is required to\n     * obtain authorization token (as well additional requests to obtain\n     * instance region, instance certificates, instance private key, etc).\n     * An alternative solution is to increase operation timeouts to allot\n     * enough time to obtain authorzation token when required.  However,\n     * calling {@link NoSQLClient#precacheAuth} will provide better\n     * performance when starting multiple concurrent database operations.\n     * <p>\n     * Call this method after creating {@link NoSQLClient} instance before\n     * performing database operations.  Note that after the authorization\n     * expires, it will need to be obtained again which make take some time in\n     * some cases as described above.  However, build-in authoirzation\n     * providers used with this SDK are configured to refresh the\n     * authorization in background ahead of its expiration so that database\n     * operations may use existing authorization while the new one is obtained\n     * in the background.\n     * <p>\n     * Calling this method is equivalient to calling\n     * {@link AuthorizationProvider}#getAuthorization which will pre-cache\n     * the authorzation in the process, so if using custom\n     * {@link AuthorizationProvider} that does not cache authorzation, this\n     * method will have no effect.\n     * <p>\n     * This method does not take explicit timeout, but uses timeouts specified\n     * for authorization network requests for given built-in authorization\n     * provider.  See properties {@link IAMConfig}#timeout and\n     * {@link KVStoreAuthConfig}#timeout.\n     * @example\n     * // Using {@link NoSQLClient#precacheAuth} on new {@link NoSQLClient}\n     * // instance.\n     * let client;\n     * try {\n     *     client = await new NoSQLClient(config).precacheAuth();\n     *     .....\n     * } finally {\n     *     client?.close();\n     * }\n     * @async\n     * @returns {Promise} Promise of {@link NoSQLClient} of this instance\n     * @see {@link IAMConfig}\n     * @see {@link KVStoreAuthConfig}\n     * @see {@link AuthorizationProvider}\n     */\n    precacheAuth() {\n        return super._precacheAuth();\n    }\n\n    /**\n     * Executes a DDL operation on a table. The operations allowed are\n     * defined by the Data Definition Language (DDL) portion of the\n     * query language related to tables such as table creation and\n     * drop, index add and drop, and the ability to alter table schema\n     * and table limits.\n     * <p>\n     * Operations using table DDL statements infer the table name from the\n     * statement itself, e.g. \"CREATE TABLE mytable(...)\". Table\n     * creation requires a valid {@link TableLimits} object to define\n     * the throughput and storage desired for the table. It is an\n     * error for TableLimits to be specified with a statement other\n     * than create or alter table.\n     * <p>\n     * Note that these are potentially long-running operations, so the\n     * result returned by this API does not imply operation completion\n     * and the table may be in an intermediate state. (see {@link\n     * TableState}).  The caller should use the {@link NoSQLClient#getTable}\n     * method to check the status of the operation or\n     * {@link NoSQLClient#forCompletion} to asynchronously wait for the\n     * operation completion.\n     * <p>\n     * Alternatively, if <em>opt.complete</em> is set to true, this API will\n     * complete (i.e. the returned <em>Promise</em> will resolve) only\n     * when the operation is completed and the table reaches state\n     * {@link TableState.ACTIVE} or {@link TableState.DROPPED} (if the\n     * operation was \"DROP TABLE\").  This is equivalent to sequentially\n     * executing {@link NoSQLClient#tableDDL} and\n     * {@link NoSQLClient#forCompletion}.  In this case, <em>opt.timeout</em>\n     * covers the whole time interval until operation completion.\n     * If not specified, separate default timeouts are used for issuing the\n     * DDL operation and waiting for its completion, with values of\n     * {@link Config}#ddlTimeout and {@link Config}#tablePollTimeout\n     * correspondingly (the latter defaults to no timeout if\n     * {@link Config}#tablePollTimeout is not set).  You may also use\n     * <em>opt.delay</em> to specify polling delay (see\n     * {@link NoSQLClient#forCompletion}).\n     * @async\n     * @param {string} stmt SQL statement\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#ddlTimeout (if\n     * <em>opt.complete</em> is true, separate default timeouts are used for\n     * issuing the DDL operation and waiting for its completion, with values\n     * of {@link Config}#ddlTimeout and {@link Config}#tablePollTimeout\n     * correspondingly)\n     * @param {TableLimits} [opt.tableLimits] Specifies new table limits for\n     * a table. See {@link TableLimits}.  Note that this property is required\n     * when creating a table\n     * @param {TableETag} [opt.matchETag] Cloud Service only. Entity tag that\n     * must be matched for the operation to proceed. See {@link TableETag}\n     * @param {DefinedTags} [opt.definedTags] Cloud Service only. Defined tags\n     * to use for the operation.  See {@link DefinedTags}\n     * @param {FreeFormTags} [opt.freeFormTags] Cloud Service only. Free-form\n     * tags to use for the operation.  See {@link FreeFormTags}\n     * @param {boolean} [opt.complete] If set to true, the returned\n     * <em>Promise</em> will only resolve when the operation is completed and\n     * the table state becomes {@link TableState.ACTIVE} or\n     * {@link TableState.DROPPED} (if the operation was \"DROP TABLE\")\n     * @param {number} [opt.delay] If <em>opt.complete</em> is true, specifies\n     * delay between successive polls while waiting for operation completion.\n     * Defaults to {@link Config}#tablePollDelay.  Has no effect if\n     * <em>opt.complete</em> is not enabled\n     * @returns {Promise} Promise of {@link TableResult}\n     * @see {@link TableResult}\n     * @see {@link NoSQLClient#forCompletion}\n     */\n    tableDDL(stmt, opt) {\n        const req = {\n            api: this.tableDDL,\n            stmt,\n            opt\n        };\n        return opt != null && opt.complete ?\n            this._withCompletion(ops.TableDDLOp, req) :\n            this._execute(ops.TableDDLOp, req);\n    }\n\n    /**\n     * Note: this method is only supported when using the driver with the\n     * Cloud Service or Cloud Simulator.  When using the driver with\n     * On-Premise NoSQL Database (see {@link ServiceType.KVSTORE}), this\n     * method is a no-op.\n     * <p>\n     * Sets new limits of throughput and storage for existing table.\n     * <p>\n     * Same considerations as described in {@link NoSQLClient#tableDDL} about\n     * long-running operations, using {@link NoSQLClient#forCompletion} and\n     * options <em>opt.complete</em> and <em>opt.delay</em> apply to this API.\n     * See {@link NoSQLClient#tableDDL}.\n     * @async\n     * @param {string} tableName Table name\n     * @param {TableLimits} tableLimits New table limits for the table\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#ddlTimeout (if\n     * <em>opt.complete</em> is true, separate default timeouts are used for\n     * issuing the DDL operation and waiting for its completion, with values\n     * of {@link Config}#ddlTimeout and {@link Config}#tablePollTimeout\n     * correspondingly)\n     * @param {TableETag} [opt.matchETag] Cloud Service only. Entity tag that\n     * must be matched for the operation to proceed. See {@link TableETag}\n     * @param {boolean} [opt.complete] If set to true, the returned\n     * <em>Promise</em> will only resolve when the operation is completed and\n     * the table state becomes {@link TableState.ACTIVE}\n     * @param {number} [opt.delay] If <em>opt.complete</em> is true, specifies\n     * delay between successive polls while waiting for operation completion.\n     * Defaults to {@link Config}#tablePollDelay.  Has no effect if\n     * <em>opt.complete</em> is not enabled\n     * @returns {Promise} Promise of {@link TableResult}\n     * @see {@link TableResult}\n     * @see {@link NoSQLClient#tableDDL}\n     */\n    setTableLimits(tableName, tableLimits, opt) {\n        opt = this._assignOpt(opt, { tableLimits });\n        const req = {\n            api: this.setTableLimits,\n            tableName,\n            opt\n        };\n        return opt.complete ?\n            this._withCompletion(ops.TableLimitsOp, req) :\n            this._execute(ops.TableLimitsOp, req);\n    }\n\n    /**\n     * Note: this method is only supported when using the driver with the\n     * Cloud Service or Cloud Simulator.  When using the driver with\n     * On-Premise NoSQL Database (see {@link ServiceType.KVSTORE}), this\n     * method is a no-op.\n     * <p>\n     * Sets defined and free-form tags on existing table.\n     * <p> See {@link DefinedTags} and {@link FreeFormTags} for more\n     * information on tagging.\n     * <p>\n     * Same considerations as described in {@link NoSQLClient#tableDDL} about\n     * long-running operations, using {@link NoSQLClient#forCompletion} and\n     * options <em>opt.complete</em> and <em>opt.delay</em> apply to this API.\n     * See {@link NoSQLClient#tableDDL}.\n     * @async\n     * @param {string} tableName Table name\n     * @param {DefinedTags} definedTags Cloud Service only. Defined tags\n     * to use for the operation. See {@link DefinedTags}.  Pass <em>null</em>\n     * if you wish to set only free-form tags\n     * @param {FreeFormTags} [freeFormTags] Cloud Service only. Free-form\n     * tags to use for the operation.  See {@link FreeFormTags}. Pass\n     * <em>null</em> (or omit if not using <em>opt</em> parameter) if you with\n     * to set only defined tags.\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#ddlTimeout (if\n     * <em>opt.complete</em> is true, separate default timeouts are used for\n     * issuing the DDL operation and waiting for its completion, with values\n     * of {@link Config}#ddlTimeout and {@link Config}#tablePollTimeout\n     * correspondingly)\n     * @param {TableETag} [opt.matchETag] Cloud Service only. Entity tag that\n     * must be matched for the operation to proceed. See {@link TableETag}\n     * @param {boolean} [opt.complete] If set to true, the returned\n     * <em>Promise</em> will only resolve when the operation is completed and\n     * the table state becomes {@link TableState.ACTIVE}\n     * @param {number} [opt.delay] If <em>opt.complete</em> is true, specifies\n     * delay between successive polls while waiting for operation completion.\n     * Defaults to {@link Config}#tablePollDelay.  Has no effect if\n     * <em>opt.complete</em> is not enabled\n     * @returns {Promise} Promise of {@link TableResult}\n     * @see {@link DefinedTags}\n     * @see {@link FreeFormTags}\n     * @see {@link TableResult}\n     * @see {@link NoSQLClient#tableDDL}\n     */\n    setTableTags(tableName, definedTags, freeFormTags, opt) {\n        opt = this._assignOpt(opt, { definedTags, freeFormTags });\n        const req = {\n            api: this.setTableTags,\n            tableName,\n            opt\n        };\n        return opt.complete ?\n            this._withCompletion(ops.TableLimitsOp, req) :\n            this._execute(ops.TableLimitsOp, req);\n    }\n\n    /**\n     * Retrieves static information about a table, including its\n     * provisioned througput, capacity and schema, in the form of {@link\n     * TableResult}. Dynamic information such as usage() is obtained using\n     * {@link getTableUsage}\n     * @async\n     * @param {string|TableResult} table Either a table name or a\n     * {@link TableResult} object that was returned from a call to\n     * {@link NoSQLClient#tableDDL}. If the latter,\n     * error information for the DDL operation will be retrieved, so\n     * if the original call failed, this follow-on call will also fail with\n     * the same error.\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @returns {Promise} Promise of {@link TableResult}\n     * @see {@link NoSQLClient#tableDDL}\n     */\n    getTable(table, opt) {\n        return this._execute(ops.GetTableOp, {\n            api: this.getTable,\n            table,\n            opt\n        });\n    }\n\n    /**\n     * Waits asynchronously for the table to reach a desired state.  This is\n     * achieved by polling the table at specified intervals.\n     * <p>\n     * This API is used to ensure that the table is ready for data\n     * operations after it has been created or altered. It should only be used\n     * if the table DDL operation has been performed outside of the current\n     * flow of control (e.g. by another application) such that the\n     * {@link TableResult} of the DDL operation is not available.  To wait for\n     * completion of the table DDL operation that you issued, use\n     * {@link NoSQLClient#forCompletion}.  This API waits until\n     * the table has transitioned from an intermediate state like\n     * {@link TableState.CREATING} or {@link TableState.UPDATING} to a\n     * stable state like {@link TableState.ACTIVE}, at which point it\n     * can be used.\n     * <p>\n     * The result of this operation, if successful, is a {@link TableResult}\n     * that shows the table state from the last poll. The\n     * state of {@link TableState.DROPPED} is treated specially in\n     * that it will be returned as success, even if the table does not\n     * exist. Other states will throw an exception if the table is not\n     * found.\n     * @async\n     * @param {string} tableName Table name\n     * @param {TableState} tableState Desired table state\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds, i.e. how long to keep polling for desired table state.\n     * Defaults to {@link Config}#tablePollTimeout\n     * @param {number} [opt.delay] Delay in milliseconds between\n     * successive polls, determines how often the polls are performed.\n     * Defaults to {@link Config}#tablePollDelay\n     * @returns {Promise} Promise of {@link TableResult} representing\n     * result of the last poll\n     * @see {@link NoSQLClient#getTable}\n     * @see {@link NoSQLClient#tableDDL}\n     * @see {@link NoSQLClient#forCompletion}\n     */\n    forTableState(tableName, tableState, opt) {\n        return this._forTableState(tableName, tableState, opt);\n    }\n\n    /**\n     * Note: this method is only supported when using the driver with the\n     * Cloud Service.  It is not supported when using the driver with\n     * On-Premise NoSQL Database (see {@link ServiceType.KVSTORE}), in which\n     * case it will result in error.\n     * <p>\n     * Retrieves dynamic information associated with a table, as returned in\n     * {@link TableUsageResult}. This information includes a time series of\n     * usage snapshots, each indicating data such as read and write\n     * throughput, throttling events, etc, as found in {@link TableUsage}.\n     * <p>\n     * Usage information is collected in time slices and returned in\n     * individual usage records.  It is possible to return a range of usage\n     * records within a given time period.  Unless the time period is\n     * specified, only the most recent usage record is returned. Usage records\n     * are created on a regular basis and maintained for a period of time.\n     * Only records for time periods that have completed are returned so that\n     * a user never sees changing data for a specific range.\n     * <p>\n     * Because the number of table usage records can be very large, you may\n     * page the results over multiple calls to\n     * {@link NoSQLClient#getTableUsage} using <em>opt.startIndex</em> and\n     * <em>opt.limit</em> parameters as shown in the example.  However, the\n     * recommended way is to call {@link NoSQLClient#tableUsageIterable} and\n     * iterate over its result.\n     * @example <caption>Paging over table usage records</caption>\n     * // We iterate until the number of returned table usage records becomes\n     * // less than the limit (and possibly 0), which means that the last\n     * // partial result has been received.\n     * const now = Date.now();\n     * const opt = {\n     *     startTime: now - 3600 * 1000, // last 1 hour\n     *     endTime: now,\n     *     limit: 100\n     * };\n     * do {\n     *     const res = await client.getTableUsage('MyTable', opt);\n     *     for(const rec of res.usageRecords) {\n     *         console.log(rec);\n     *     }\n     *     opt.startIndex = res.nextIndex;\n     * } while(res.usageRecords.length === opt.limit);\n     * @async\n     * @param {string} tableName Table name\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {Date|string|number} [opt.startTime]  Start time for the time\n     * period.  Can be JavaScript Date, string representing date and time or\n     * number of milliseconds since epoch (January 1, 1970, 00:00:00 UTC).\n     * For string representation see <em>Date.parse()</em>.  If time\n     * range is not specified, the most recent complete usage record is\n     * returned\n     * @param {Date|string|number}  [opt.endTime]  End time for the time\n     * period, represented same as opt.startTime\n     * @param {number} [opt.limit]  Limit to the number of usage records\n     * desired. If not specified or value is 0, there is no limit, but not all\n     * usage records may be returned due to size limitations\n     * @param {number} [opt.startIndex=0] Index at which to start returning\n     * table usage records.  To page table usage records, set this value to\n     * {@link TableUsageResult}#nextIndex returned from previous call to\n     * {@link NoSQLClient#getTableUsage}. These operations are best done in a\n     * loop. See the example\n     * @returns {Promise} Promise of {@link TableUsageResult}\n     * @see {@link TableUsageResult}\n     * @see {@link #tableUsageIterable}\n     */\n    getTableUsage(tableName, opt) {\n        return this._execute(ops.TableUsageOp, {\n            api: this.getTableUsage,\n            tableName,\n            opt\n        });\n    }\n\n    /**\n     * Note: this method is only supported when using the driver with the\n     * Cloud Service.  It is not supported when using the driver with\n     * On-Premise NoSQL Database (see {@link ServiceType.KVSTORE}), in which\n     * case it will result in error.\n     * <p>\n     * Retrieves dynamic information associated with a table, as returned in\n     * {@link TableUsageResult}.\n     * <p>\n     * Use this API when you need to retrieve a\n     * large number of table usage records and you wish to page the results\n     * rather than returning the whole list at once.  The iteration is done\n     * by using <em>for-await-of</em> loop. The iteration is asynchronous and\n     * each step of the iteration returns a Promise of\n     * {@link TableUsageResult}. Using this API is equivalent to paging table\n     * usage records as shown in the example of\n     * {@link NoSQLClient#getTableUsage}.\n     * <p>\n     * Note that you must specify a time range (at least one of\n     * <em>opt.startTime</em> and <em>opt.endTime</em> for which to return\n     * table usage records, otherwise only one (the most recent) table usage\n     * record will be returned.\n     * <p>\n     * You may optionally specify a limit on the number of table usage records\n     * returned in each partial result using <em>opt.limit</em>. If not\n     * specified, a default system limit will be used.\n     * @example <caption>Paging table usage records</caption>\n     * const now = Date.now();\n     * const opt = {\n     *     startTime: now - 3600 * 1000, // last 1 hour\n     *     endTime: now,\n     *     limit: 100\n     * };\n     * for await(const res of client.tableUsageIterable('MyTable', opt)) {\n     *     for(const rec of res.usageRecords) {\n     *         console.log(rec);\n     *     }\n     * }\n     * @param {string} tableName Table name\n     * @param {object} opt Options object. See <em>opt</em> parameter of\n     * {@link NoSQLClient#getTableUsage}.  The same options are available,\n     * except <em>opt.startIndex</em>\n     * @returns {Promise} Promise of {@link TableUsageResult}\n     * @see {@link #getTableUsage}\n     * @since 5.4\n     */\n    tableUsageIterable(tableName, opt) {\n        return this._tableUsageIterable(tableName, opt);\n    }\n\n    /**\n     * Retrieves information about indexes of the table as array of\n     * {@link IndexInfo} objects.\n     * @async\n     * @param {string} tableName Table name\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {string} [opt.indexName]  Return information only about specific\n     * index, same as {@link NoSQLClient#getIndex}.  If not specified,\n     * information on all indexes is returned\n     * @returns {Promise} Promise of {@link IndexInfo}[]\n     * @see {@link IndexInfo}\n     */\n    getIndexes(tableName, opt) {\n        return this._execute(ops.GetIndexesOp, {\n            api: this.getIndexes,\n            tableName,\n            opt\n        });\n    }\n\n    /**\n     * Retrieves information about specific index of the table as\n     * {@link IndexInfo} object.\n     * @async\n     * @param {string} tableName Table name\n     * @param {string} indexName Index name\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @returns {Promise} Promise of {@link IndexInfo}\n     * @see {@link NoSQLClient#getIndexes}\n     */\n    getIndex(tableName, indexName, opt) {\n        return this._getIndex(tableName, indexName, opt);\n    }\n\n    /**\n     * Lists tables, returning table names. If further information about a\n     * specific table is desired the {@link NoSQLClient#getTable} API may be\n     * used.  If a given identity has access to a large number of tables\n     * the list may be paged by using startIndex and limit options.  The list\n     * is returned as string array in {@link ListTablesResult}.  Names\n     * are returned in alphabetical order to facilitate paging.\n     * @async\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information. Only tables belonging to the given compartment (but not\n     * its child compartments) will be listed\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {number} [opt.startIndex]  The index to use to start returning\n     * table names. This is related to the {@link ListTablesResult}#lastIndex\n     * from a previous request and can be used to page table names. If not\n     * set, the list starts at index 0\n     * @param {number} [opt.limit] The maximum number of table names to return\n     * in the operation. If not set or set to 0, there is no limit\n     * @param {string} [opt.namespace] On-premise only.  If set, list tables\n     * from given namespace only, otherwise list all tables for the user.\n     * @returns {Promise} Promise of {@link ListTablesResult}\n     * @see {@link ListTablesResult}\n     */\n    listTables(opt) {\n        return this._execute(ops.ListTablesOp, {\n            api: this.listTables,\n            opt\n        });\n    }\n\n    /**\n     * Gets the row associated with a primary key. On success the value of the\n     * row is available as property of {@link GetResult}. If there are no\n     * matching rows, the operation is still successful the row property will\n     * be set to null.\n     * @async\n     * @param {string} tableName Table name\n     * @param {Key} key Primary {@link Key} of the row\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {Consistency} [opt.consistency] {@link Consistency} used for\n     * the operation.  Defaults to {@link Config}#Consistency\n     * @returns {Promise} Promise of {@link GetResult}\n     * @see {@link Key}\n     * @see {@link GetResult}\n     */\n    get(tableName, key, opt) {\n        return this._execute(ops.GetOp, {\n            api: this.get,\n            tableName,\n            key,\n            opt\n        });\n    }\n\n    /**\n     * Puts a row into a table. This method creates a new row or overwrites\n     * an existing row entirely. The value used for the put must contain a\n     * complete primary key and all required fields.\n     * <p>\n     * It is not possible to put part of a row.  Any fields that are not\n     * provided will be defaulted, overwriting any existing value. Fields that\n     * are not nullable or defaulted must be provided or the operation will\n     * fail.\n     * <p>\n     * By default a put operation is unconditional, but put operations can be\n     * conditional based on existence, or not, of a previous value as well as\n     * conditional on the {@link Version} of the existing value:\n     * <ul>\n     * <li>Use <em>opt.isAbsent</em> to do a put only if there is no existing\n     * row that matches the primary key.</li>\n     * <li>Use <em>opt.ifPresent</em> to do a put only if there is an\n     * existing row that matches the primary key.</li>\n     * <li>Use <em>opt.matchVersion</em> to do a put only if there is an\n     * existing row that matches the primary key <em>and</em> its\n     * {@link Version} matches that provided by <em>opt.matchVersion</em>.\n     * </li>\n     * </ul>\n     * Note that only one of <em>opt.isAbsent</em>, <em>opt.ifPresent</em> or\n     * <em>opt.matchVersion</em> options may be specified for given put\n     * operation.\n     * <p>\n     * It is also possible, on failure, to return information about the\n     * existing row. The row, including its {@link Version} can be optionally\n     * returned if a put operation fails because of a Version mismatch or if\n     * the operation fails because the row already exists. The existing row\n     * information will only be returned if <em>opt.returnExisting</em> is\n     * true and one of the following occurs:\n     * <ul>\n     * <li><em>opt.isAbsent</em> is true and the operation fails because\n     * the row already exists.</li>\n     * <li><em>opt.matchVersion</em> is used and the operation fails because\n     * the row exists and its {@link Version} does not match.</li>\n     * </ul>\n     * The information about the result of the put operation is returned as\n     * {@link PutResult}.  Note that the failure cases discussed above that\n     * resulted from inability to satisfy <em>opt.isAbsent</em>,\n     * <em>opt.ifPresent</em> or <em>opt.matchVersion</em> options are still\n     * considered successful as API calls, i.e. they result in\n     * {@link PutResult} and not {@link NoSQLError}.  See\n     * {@link PutResult}#success.  However if put fails for other reasons,\n     * this API call will result in error instead.\n     *\n     * @async\n     * @param {string} tableName Table name\n     * @param {Row} row Table {@link Row}\n     * @param {object} [opt] Options object:\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {boolean} [opt.ifAbsent] If set to true, do put\n     * only if there is no existing row that matches the primary key\n     * @param {boolean} [opt.ifPresent] If set to true, do put only if\n     * there is existing row that matches the primary key\n     * @param {Version} [opt.matchVersion] If set, do a put only if there is\n     * an existing row that matches the primary key and its {@link Version}\n     * matches the value provided\n     * @param {boolean} [opt.returnExisting] If set to true, existing\n     * row and its version will be returned as part of {@link PutResult}\n     * if put operation fails as per discussion above\n     * @param {Durability} [opt.durability] On-premises only. Set the desired\n     * durability for master/replica sync/acks.  Defaults to\n     * {@link Config}#durability or if not set, the default server-side\n     * durability settings are used. See {@link Durability}\n     * @param {TimeToLive|number} [opt.ttl] Sets {@link TimeToLive} value,\n     * causing the time to live on the row to be set to the specified value\n     * on put. This value overrides any default time to live setting on\n     * the table\n     * @param {boolean} [opt.updateTTLToDefault] If set to true, and\n     * there is an existing row, causes the operation to update the time to\n     * live (TTL) value of the row based on the table's default TTL if set.\n     * If the table has no default TTL this state has no effect.  By default\n     * updating an existing row has no effect on its TTL.  This option cannot\n     * be specified if <em>opt.ttl</em> is specified\n     * @param {boolean} [opt.exactMatch] If true the value must be an exact\n     * match for the table schema or the operation will fail. An exact match\n     * means that there are no required fields missing and that there are no\n     * extra, unknown fields. The default behavior is to not require an exact\n     * match\n     * @param {number} [opt.identityCacheSize] Sets the number of generated\n     * identity values that are requested from the server during a put. This\n     * takes precedence over the DDL identity CACHE option set during creation\n     * of the identity column.  Must be positive integer.  If not set, the DDL\n     * identity CACHE value is used\n     * @returns {Promise} Promise of {@link PutResult}\n     * @see {@link Row}\n     * @see {@link Version}\n     * @see {@link TimeToLive}\n     * @see {@link PutResult}\n     */\n    put(tableName, row, opt) {\n        return this._execute(ops.PutOp, {\n            api: this.put,\n            tableName,\n            row,\n            opt\n        });\n    }\n\n    /**\n     * Performs a put if there is no existing row that matches the primary\n     * key.  This API is a shorthand for {@link NoSQLClient#put} with\n     * <em>opt.ifAbsent</em> set to true.\n     * @async\n     * @param {string} tableName Table name\n     * @param {Row} row Row, same as in {@link NoSQLClient#put}\n     * @param {object} opt Options object, see below\n     * @param {string} [opt.compartment] Same as in {@link NoSQLClient#put}\n     * @param {number} [opt.timeout] Same as in {@link NoSQLClient#put}\n     * @param {Durability} [opt.durability] Same as in {@link NoSQLClient#put}\n     * @param {boolean} [opt.returnExisting] Same as in\n     * {@link NoSQLClient#put}\n     * @param {TimeToLive|number} [opt.ttl] Same as in {@link NoSQLClient#put}\n     * @param {boolean} [opt.exactMatch] Same as in {@link NoSQLClient#put}\n     * @param {number} [opt.identityCacheSize] Same as in\n     * {@link NoSQLClient#put}\n     * @returns {Promise} Promise of {@link PutResult}\n     * @see {@link NoSQLClient#put}\n     */\n    putIfAbsent(tableName, row, opt) {\n        return this._execute(ops.PutOp, {\n            api: this.putIfAbsent,\n            tableName,\n            row,\n            opt: this._assignOpt(opt, { ifAbsent: true })\n        });\n    }\n\n    /**\n     * Performs a put if there is existing row that matches the primary\n     * key.  This API is a shorthand for {@link NoSQLClient#put} with\n     * <em>opt.ifPresent</em> set to true.\n     * @async\n     * @param {string} tableName Table name\n     * @param {Row} row Row, same as in {@link NoSQLClient#put}\n     * @param {object} opt Options object, see below\n     * @param {string} [opt.compartment] Same as in {@link NoSQLClient#put}\n     * @param {number} [opt.timeout] Same as in {@link NoSQLClient#put}\n     * @param {Durability} [opt.durability] Same as in {@link NoSQLClient#put}\n     * @param {TimeToLive|number} [opt.ttl] Same as in {@link NoSQLClient#put}\n     * @param {boolean} [opt.updateTTLToDefault] Same as in\n     * {@link NoSQLClient#put}\n     * @param {boolean} [opt.exactMatch] Same as in {@link NoSQLClient#put}\n     * @param {number} [opt.identityCacheSize] Same as in\n     * {@link NoSQLClient#put}\n     * @returns {Promise} Promise of {@link PutResult}\n     * @see {@link NoSQLClient#put}\n     */\n    putIfPresent(tableName, row, opt) {\n        return this._execute(ops.PutOp, {\n            api: this.putIfPresent,\n            tableName,\n            row,\n            opt: this._assignOpt(opt, { ifPresent: true })\n        });\n    }\n\n    /**\n     * Performs a put if there is an existing row that matches the primary key\n     * and its {@link Version} matches the value provided.  This API is a\n     * shorthand for {@link NoSQLClient#put} with <em>opt.matchVersion</em>\n     * specified.\n     * @async\n     * @param {string} tableName Table name\n     * @param {Row} row Row, same as in {@link NoSQLClient#put}\n     * @param {Version} matchVersion {@link Version} to match\n     * @param {object} opt Options object, see below\n     * @param {string} [opt.compartment] Same as in {@link NoSQLClient#put}\n     * @param {number} [opt.timeout] Same as in {@link NoSQLClient#put}\n     * @param {Durability} [opt.durability] Same as in {@link NoSQLClient#put}\n     * @param {boolean} [opt.returnExisting] Same as in\n     * {@link NoSQLClient#put}\n     * @param {TimeToLive|number} [opt.ttl] Same as in {@link NoSQLClient#put}\n     * @param {boolean} [opt.updateTTLToDefault] Same as in\n     * {@link NoSQLClient#put}\n     * @param {boolean} [opt.exactMatch] Same as in {@link NoSQLClient#put}\n     * @param {number} [opt.identityCacheSize] Same as in\n     * {@link NoSQLClient#put}\n     * @returns {Promise} Promise of {@link PutResult}\n     * @see {@link NoSQLClient#put}\n     */\n    putIfVersion(tableName, row, matchVersion, opt) {\n        return this._execute(ops.PutOp, {\n            api: this.putIfVersion,\n            tableName,\n            row,\n            opt: this._assignOpt(opt, { matchVersion })\n        });\n    }\n\n    /**\n     * Deletes a row from a table. The row is identified using a primary key\n     * value.\n     * <p>\n     * By default a delete operation is unconditional and will succeed if the\n     * specified row exists. Delete operations can be made conditional based\n     * on whether the {@link Version} of an existing row matches that supplied\n     * <em>opt.matchVersion</em>\n     * <p>\n     * It is also possible, on failure, to return information about the\n     * existing row.  The row and its version can be optionally returned as\n     * part of {@link DeleteResult} if a delete operation fails because of\n     * a version mismatch. The existing row information will only be returned\n     * if <em>opt.returnExisting</em> is true and <em>opt.matchVersion</em> is\n     * set and the operation fails because the row exists and its version does\n     * not match.  Use of <em>opt.returnExisting</em> may result in additional\n     * consumed read capacity. If the operation is successful there will be no\n     * information returned about the previous row.\n     * <p>\n     * The information about the result of the delete operation is returned as\n     * {@link DeleteResult}.  Note that the failures to delete if the row\n     * doesn't exist or if <em>opt.matchVersion</em> is set and the version\n     * did not match are still considered successful as API calls, i.e. they\n     * result in {@link DeleteResult} and not {@link NoSQLError}, see\n     * {@link DeleteResult}#success.  However if delete fails for other reasons,\n     * this API call will result in error instead.\n     * @async\n     * @param {string} tableName Table name\n     * @param {Key} key Primary {@link Key} of the row\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {boolean} [opt.returnExisting] If set to true, existing\n     * row and its version will be returned as part of {@link DeleteResult}\n     * if delete operation fails because of version mismatch as discussed\n     * above\n     * @param {Durability} [opt.durability] On-premises only. Set the desired\n     * durability for master/replica sync/acks.  Defaults to\n     * {@link Config}#durability or if not set, the default server-side\n     * durability settings are used. See {@link Durability}\n     * @param {Version} [opt.matchVersion] If set, delete only if\n     * there is an existing row that matches the primary key and its\n     * {@link Version} matches the value provided\n     * @returns {Promise} Promise of {@link DeleteResult}\n     * @see {@link Key}\n     * @see {@link Version}\n     * @see {@link DeleteResult}\n     */\n    delete(tableName, key, opt) {\n        return this._execute(ops.DeleteOp, {\n            api: this.delete,\n            tableName,\n            key,\n            opt\n        });\n    }\n\n    /**\n     * Performs a delete if there is an existing row that matches the primary\n     * key and its {@link Version} matches the value provided.  This API is a\n     * shorthand for {@link NoSQLClient#delete} with <em>opt.matchVersion</em>\n     * specified.\n     * @async\n     * @param {string} tableName Table name\n     * @param {Key} key Primary key, same as in {@link NoSQLClient#delete}\n     * @param {Version} matchVersion {@link Version} to match\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Same as in\n     * {@link NoSQLClient#delete}\n     * @param {number} [opt.timeout] Same as in {@link NoSQLClient#delete}\n     * @param {boolean} [opt.returnExisting] Same as in\n     * {@link NoSQLClient#delete}\n     * @param {Durability} [opt.durability] Same as in\n     * {@link NoSQLClient#delete}\n     * @returns {Promise} Promise of {@link DeleteResult}\n     * @see {@link NoSQLClient#delete}\n     */\n    deleteIfVersion(tableName, key, matchVersion, opt) {\n        return this._execute(ops.DeleteOp, {\n            api: this.deleteIfVersion,\n            tableName,\n            key,\n            opt: this._assignOpt(opt, { matchVersion })\n        });\n    }\n\n    /**\n     * Deletes multiple rows from a table residing on the same shard in an\n     * atomic operation.  A range of rows is specified using a partial primary\n     * key plus a field range based on the portion of the key that is not\n     * provided. The partial primary key must contain all of the fields that\n     * are in the shard key.  For example if a table's primary key is\n     * &lt;id, timestamp&gt; and the its shard key is the id, it is possible\n     * to delete a range of timestamp values for a specific id by providing\n     * a key with an id value but no timestamp value and providing a range\n     * of timestamp values in the <em>opt.fieldRange</em>.  If the field range\n     * is not provided, the operation will delete all rows matching the\n     * partial key.\n     * <p>\n     * The information about the result of this operation will be returned as\n     * [MultiDeleteResult]{@link MultiDeleteResult}.\n     * <p>\n     * Because this operation can exceed the maximum amount of data modified\n     * in a single operation it is possible that it will delete only part of\n     * the range of rows and a continuation key will be set in\n     * [MultiDeleteResult]{@link MultiDeleteResult} that can be\n     * used to continue the operation.\n     * @async\n     * @param {string} tableName Table name\n     * @param {Key} key Partial Primary {@link Key}\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {FieldRange} [opt.fieldRange] Field range based on columns not\n     * provided in partial key.  For more details, see {@link FieldRange}\n     * @param {number} [opt.maxWriteKB] The limit on the total KB write during\n     * this operation.  This value can only reduce the system defined limit.\n     * An attempt to increase the limit beyond the system defined limit will\n     * result in error\n     * @param {Durability} [opt.durability] On-premises only. Set the desired\n     * durability for master/replica sync/acks.  Defaults to\n     * {@link Config}#durability or if not set, the default server-side\n     * durability settings are used. See {@link Durability}\n     * @param {ContinuationKey} [opt.continuationKey] Continuation key\n     * returned in {@link MultiDeleteResult} from the previous call to this\n     * API and can be used to continue this operation.  Operations with a\n     * continuation key still require the primary key\n     * @returns {Promise} Promise of {@link MultiDeleteResult}\n     * @see {@link Key}\n     * @see {@link FieldRange}\n     * @see {@link MultiDeleteResult}\n     */\n    deleteRange(tableName, key, opt) {\n        return opt != null && opt.all ?\n            this._deleteRangeAll(tableName, key, opt) :\n            this._execute(ops.MultiDeleteOp, {\n                api: this.deleteRange,\n                tableName,\n                key,\n                opt\n            });\n    }\n\n    /**\n     * Executes a sequence of put and delete operations associated with\n     * a table or tables that share the same <em>shard key</em> portion of\n     * their primary keys, all the specified operations are executed within\n     * the scope of a single transaction, thus making the operation atomic.\n     * It is an efficient way to atomically modify multiple related rows.\n     * <p>\n     * There are some size-based limitations on this operation:\n     * <ul>\n     * <li>The max number of individual operations (put, delete) in a single\n     * call to this API is 50.</li>\n     * <li>The total request size is limited to 25MB.</li>\n     * </ul>\n     * The result of this operation is returned as\n     * {@link WriteMultipleResult}.  On successful completion, it will store\n     * array of the execution results of all sub operations.  If this\n     * operation was aborted because of failure of a sub operation which has\n     * <em>opt.abortOnFail</em> set to true, then the index and execution\n     * result of the failed sub operation will be stored in\n     * {@link WriteMultipleResult} (thus the API call in this case is still\n     * successful and no error results).\n     * <p>\n     * Note that in addition to <em>opt</em> argument of this API, each\n     * sub operation may have its own <em>opt</em> property as\n     * {@link WriteOperation}#opt specifying options pertaining to particular\n     * put or delete sub operation, see {@link NoSQLClient#put} and\n     * {@link NoSQLClient#delete} (the only exception is <em>timeout</em>\n     * which can only be specified for the whole operation in <em>opt</em>\n     * argument).  Each option value explicitly set in\n     * {@link WriteOperation#opt} will take precedence over its value in\n     * <em>opt</em> argument, otherwise the <em>opt</em> argument can be used\n     * to specify options that should be the same for all sub operations.\n     * <p>\n     * It is possible to issue operations for multiple tables as long as\n     * these tables have the same shard key.  This means that these tables\n     * must be part of the same parent/child table hierarchy that has a single\n     * ancestor table specifying the shard key (you may include operations for\n     * this ancestor table and/or any of its descendants).  To issue\n     * operations for multiple tables, omit the <em>tableName</em> parameter\n     * (and thus use <em>writeMany(operations[, opt])</em>) and specify\n     * table per operation as {@link WriteOperation}#tableName.\n     * @async\n     * @param {string} [tableName] Table name, if all operations are for a\n     * single table.  If issuing operations for multiple tables, omit this\n     * parameter and specify table name for each operation as\n     * {@link WriteOperation}#tableName. Specifying this parameter together\n     * with {@link WriteOperation}#tableName for any operation will result in\n     * error\n     * @param {WriteOperation[]} operations Array of\n     * {@link WriteOperation} objects each representing single put or delete\n     * operation, see {@link WriteOperation}\n     * @param {object} [opt] Options object, specifies options that should be\n     * same for all put and delete sub operations (options relevant\n     * only to put but not to delete will be ignored for delete operations).\n     * Options for specific sub operation, other than <em>timeout</em>,\n     * <em>compartment</em> and <em>durability</em> may be specified in\n     * {@link WriteOperation} and will override values specified here. For\n     * list of options, see {@link WriteOperation}\n     * @param {Durability} [opt.durability] On-premises only. Set the desired\n     * durability for master/replica sync/acks.  Defaults to\n     * {@link Config}#durability or if not set, the default server-side\n     * durability settings are used. See {@link Durability}\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @returns {Promise} Promise of {@link WriteMultipleResult}\n     */\n    writeMany(tableName, operations, opt) {\n        //Check if tableName parameter was omitted and operations is the first\n        //parameter.\n        if (Array.isArray(tableName) && !Array.isArray(operations)) {\n            opt = operations;\n            operations = tableName;\n            tableName = undefined;\n        }\n        return this._execute(ops.WriteMultipleOp, {\n            api: this.writeMany,\n            tableName,\n            ops: operations,\n            opt\n        });\n    }\n\n    /**\n     * Executes a sequence of put operations associated with a table that\n     * share the same <em>shard key</em> portion of their primary keys, all\n     * the specified operations are executed within the scope of single\n     * transaction, thus making the operation atomic.\n     * This API is a shortcut to {@link NoSQLClient#writeMany} with the\n     * following simplifications:\n     * <ul>\n     * <li>The sequence contains only put operations.</li>\n     * <li>All operations are for a single table.</li>\n     * <li>Options are specified only in the <em>opt</em> argument of this API\n     * and are same for all put sub operations (no per-sub-operation options).\n     * </li>\n     * </ul>\n     * This API may be more convenient to use than\n     * {@link NoSQLClient#writeMany} when applicable.\n     * @async\n     * @param {string} tableName\n     * @param {Row[]} rows Array of rows to put, see\n     * {@link Row}\n     * @param {object} [opt] Options object.  All options are the same as in\n     * {@link NoSQLClient#put}, besides an additional <em>abortOnFail</em>\n     * option, see below\n     * @param {boolean} [opt.abortOnFail] If set to true, aborts the whole\n     * transaction if any of the puts fails.  This is only applicable to\n     * failures due to inability to satisfy <em>opt.ifAbsent</em>,\n     * <em>opt.ifPresent</em> or <em>opt.matchVersion</em> options, see\n     * discussion in {@link NoSQLClient#put}.  Other failures will result\n     * in error\n     * @returns {Promise} Promise of {@link WriteMultipleResult}\n     */\n    putMany(tableName, rows, opt) {\n        return this._execute(ops.WriteMultipleOp, {\n            api: this.putMany,\n            tableName,\n            rows,\n            opt\n        });\n    }\n\n    /**\n     * Executes a sequence of delete operations associated with a table that\n     * share the same <em>shard key</em> portion of their primary keys, all\n     * the specified operations are executed within the scope of single\n     * transaction, thus making the operation atomic.\n     * This API is a shortcut to {@link NoSQLClient#writeMany} with the\n     * following simplifications:\n     * <ul>\n     * <li>The sequence contains only delete operations.</li>\n     * <li>All operations are for a single table.</li>\n     * <li>Options are specified only in the <em>opt</em> argument of this API\n     * and are same for all delete sub-operations (no per-sub-operation\n     * options).</li>\n     * </ul>\n     * This API may be more more convenient to use than\n     * {@link NoSQLClient#writeMany} when applicable.\n     * @async\n     * @param {string} tableName\n     * @param {Key[]} keys Array of primary keys to delete,\n     * see {@link Key}\n     * @param {object} [opt] Options object.  All options are the same as in\n     * {@link NoSQLClient#delete}, besides an additional <em>abortOnFail</em>\n     * option, see below\n     * @param {boolean} [opt.abortOnFail] If set to true, aborts the whole\n     * transaction if any of the deletes fails.  This is only applicable to\n     * failures due non-existence of the row or inability to match\n     * <em>opt.matchVersion</em>, see discussion in\n     * {@link NoSQLClient#delete}.  Other failures will result in error\n     * @returns {Promise} Promise of {@link WriteMultipleResult}\n     */\n    deleteMany(tableName, keys, opt) {\n        return this._execute(ops.WriteMultipleOp, {\n            api: this.deleteMany,\n            tableName,\n            keys,\n            opt\n        });\n    }\n\n    /**\n     * Prepares a query for execution and reuse. See {@link NoSQLClient#query}\n     * for general information and restrictions. It is recommended that\n     * prepared queries are used when the same query will run multiple times\n     * as execution is much more efficient than starting with a query string\n     * every time. The query language and API support query variables to\n     * assist with re-use.\n     * <p>\n     * The result of this operation is {@link PreparedStatement}.  It supports\n     * bind variables in queries which can be used to more easily reuse a\n     * query by parameterization, see {@link PreparedStatement} for details.\n     * @async\n     * @param {string} stmt Query SQL statement\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {boolean} [opt.getQueryPlan] If <em>true</em>, requests a\n     * printout of query execution plan to be included in the returned\n     * {@link PreparedStatement} as {@link PreparedStatement#queryPlan}\n     * @param {boolean} [opt.getResultSchema] If <em>true</em>, requests a\n     * JSON value of query result schema to be included in the returned\n     * {@link PreparedStatement} as {@link PreparedStatement#resultSchema}\n     * @returns {Promise} Promise of {@link PreparedStatement}\n     */\n    prepare(stmt, opt) {\n        return this._prepare(stmt, opt);\n    }\n\n    /**\n     * Queries a table based on the query statement.\n     * <p>\n     * Queries that include a full shard key will execute much more\n     * efficiently than more distributed queries that must go to multiple\n     * shards.\n     * <p>\n     * DDL-style queries such as \"CREATE TABLE ...\" or \"DROP TABLE ..\" are not\n     * supported by this API. Those operations must be performed using\n     * {@link NoSQLClient#tableDDL}.\n     * <p>\n     * For performance reasons prepared queries are preferred for queries that\n     * may be reused. Prepared queries bypass compilation of the query. They\n     * also allow for parameterized queries using bind variables, see\n     * {@link NoSQLClient#prepare}.\n     * <p>\n     * The result of this operation is returned as {@link QueryResult}.  It\n     * contains array of result records and may contain continuation key as\n     * {@link QueryResult}#continuationKey.\n     * <p>\n     * The amount of data read by a single query request is limited by a\n     * system default and can be further limited by setting\n     * <em>opt.maxReadKB</em>. This limits the amount of data <em>read</em>\n     * and not the amount of data <em>returned</em>, which means that a query\n     * can return zero results but still have more data to read. This\n     * situation is detected by checking if the {@link QueryResult} has a\n     * continuation key.  In addition, number of results returned by the query\n     * may be explicitly limited by setting <em>opt.limit</em>. For this\n     * reason queries should always operate in a loop, acquiring more results,\n     * until the continuation key is null, indicating that the query is done.\n     * Inside the loop the continuation key is applied to\n     * {@link NoSQLClient#query} by setting <em>opt.continuationKey</em>.\n     *\n     * @async\n     * @param {string|PreparedStatement} stmt Query statement, can be either\n     * SQL query string or a prepared query represented as\n     * {@link PreparedStatement}, see {@link NoSQLClient#prepare}\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#timeout\n     * @param {Consistency} [opt.consistency] {@link Consistency} used for the\n     * operation.  Defaults to {@link Config}#consistency\n     * @param {Durability} [opt.durability] On-premises only.\n     * {@link Durability} value used for the update query operation.  Defaults\n     * to {@link Config}#durability or if not set, default server-side\n     * durability settings are used. This option only applies for update\n     * queries, i.e. queries issued via INSERT, UPDATE, UPSERT and DELETE\n     * statements. For read-only SELECT queries this option is ignored\n     * @param {number} [opt.limit] Sets the limit on number of rows returned\n     * by the operation. This allows an operation to return less than the\n     * default amount of data\n     * @param {number} [opt.maxReadKB] Sets the limit on the total data read\n     * during this operation, in KB.  This value can only reduce the system\n     * defined limit. An attempt to increase the limit beyond the system\n     * defined limit will result in error. This limit is independent of read\n     * units consumed by the operation\n     * @param {number} [opt.maxWriteKB] Sets the limit on the total data\n     * written during this operation, in KB.  Relevant for update and delete\n     * queries.  This value can only reduce the system defined limit. An\n     * attempt to increase the limit beyond the system defined limit will\n     * result in error. This limit is independent of the write units consumed\n     * by the operation\n     * @param {number} [opt.maxMemoryMB] Maximum amount of memory in megabytes\n     * that may be used locally in this query execution for operations such as\n     * duplicate elimination (which may be required if using an index on an\n     * array or a map) and sorting. Such operations may require significant\n     * amount of memory as they need to cache full result set or a large\n     * subset of it in locally. If memory consumption exceeds this value,\n     * error will result.  Default is 1GB.  Defaults to\n     * {@link Config}#maxMemoryMB\n     * @param {ContinuationKey} [opt.continuationKey] Continuation key\n     * returned in {@link QueryResult} from previous call to this API used to\n     * continue the query.  If there are no more results,\n     * continuation key will be null.  Note that it is possible that\n     * continuation key is not null, but the query has no more\n     * results remaining.  In this case the next call to\n     * {@link NoSQLClient#query} will result in {@link QueryResult}#rows being\n     * empty array and next continuation key being null.  This is possible if\n     * the previous call to {@link NoSQLClient#query} fetched all remaing rows\n     * in the result set but was stopped due to the set limitations, including\n     * <em>opt.maxReadKB</em> or <em>opt.limit</em>.  In this case the server\n     * will not look ahead to check if any more results remain\n     * @returns {Promise} Promise of {@link QueryResult}\n     */\n    query(stmt, opt) {\n        return this._query(stmt, opt);\n    }\n\n    /**\n     * This API facilitates iteration over query results returned by\n     * {@link NoSQLClient#query} by using <em>for-await-of</em> loop.  The\n     * iteration over query results is necessary because of the limitations\n     * on the amount of data read during each query request as described in\n     * {@link NoSQLClient#query}.  The iteration is asynchronous and each\n     * step of the iteration returns a Promise of {@link QueryResult}.  Using\n     * this API is internally equivalent to calling {@link NoSQLClient#query}\n     * in a loop and using continuation key returned in {@link QueryResult} to\n     * continue the query.  Thus you do not need to explicitly manage\n     * continuation key when using this API.\n     * <p>\n     * Note that calling this API by itself does not start\n     * the query, the query is started when starting the iteration via\n     * <em>for-await-of</em> loop.\n     * <p>\n     * The returned iterable cannot be reused for multiple queries.\n     * To execute another query, call {@link NoSQLClient#queryIterable} again\n     * to create a new iterable.\n     * <p>\n     * All other considerations described in {@link NoSQLClient#query} apply\n     * when using this API.\n     * @example // Using {@link NoSQLClient#queryIterable}\n     * try {\n     *     const stmt = 'SELECT * from orders';\n     *     for await(const res of client.queryIterable(stmt)) {\n     *         console.log(`Retrieved ${res.rows.length} rows`);\n     *         // Do something with res.rows\n     *     }\n     * } catch(err) {\n     *     // handle errors\n     * }\n     * @param {string|PreparedStatement} stmt Query statement, same as for\n     * {@link NoSQLClient#query}\n     * @param {object} [opt] Options object.  All options are same as for\n     * {@link NoSQLClient#query}, except that <em>continuationKey</em> is not\n     * used (it will be ignored if set)\n     * @returns {object} Async iterable to iterate over query results using\n     * <em>for-await-of</em> loop.\n     * @see {@link NoSQLClient#query}\n     */\n    queryIterable(stmt, opt) {\n        return this._queryIterable(stmt, opt);\n    }\n\n    /**\n     * On-premise only.\n     * <p>\n     * Performs an administrative operation on the system.  The operations\n     * allowed are defined by Data Definition Language (DDL) portion of the\n     * query language that do not affect a specific table. For table-specific\n     * DLL operations use {@link NoSQLClient#tableDDL}.\n     * <p>\n     * Examples of statements passed to this method include:\n     * <ul>\n     * <li>CREATE NAMESPACE mynamespace</li>\n     * <li>CREATE USER some_user IDENTIFIED BY password</li>\n     * <li>CREATE ROLE some_role</li>\n     * <li>GRANT ROLE some_role TO USER some_user</li>\n     * </ul>\n     * <p>\n     * <p>\n     * Note that these are potentially long-running operations, so the\n     * result returned by this API does not imply operation completion.  The\n     * caller should use the {@link NoSQLClient#adminStatus} method to check\n     * the status of the operation or {@link NoSQLClient#forCompletion} to\n     * asynchronously wait for the operation completion.\n     * <p>\n     * Alternatively, if <em>opt.complete</em> is set to true, this API will\n     * complete (i.e. the returned <em>Promise</em> will resolve) only\n     * when the operation is completed.  This is equivalent to sequentially\n     * executing {@link NoSQLClient#adminDDL} and\n     * {@link NoSQLClient#forCompletion}.  In this case, <em>opt.timeout</em>\n     * covers the whole time interval until operation completion.\n     * If not specified, separate default timeouts are used for issuing the\n     * DDL operation and waiting for its completion, with values of\n     * {@link Config}#ddlTimeout and {@link Config}#adminPollTimeout\n     * correspondingly (the latter defaults to no timeout if\n     * {@link Config}#adminPollTimeout is not set).  You may also use\n     * <em>opt.delay</em> to specify polling delay (see\n     * {@link NoSQLClient#forCompletion}).\n     * <p>\n     * Note that some of the statements used by admin DDL may contain\n     * passwords in which case it is advisable to pass the statement as\n     * <em>Buffer</em> so that the memory can be subsequently cleared by the\n     * application.  The <em>Buffer</em> should contain the statement as\n     * UTF-8 encoded string.\n     * @async\n     * @param {Buffer|string} stmt Statement for the operation as string or\n     * Buffer containing UTF-8 encoded string\n     * @param {object} [opt] Options object, see below\n     * @param {number} [opt.timeout] Timeout for the operation in\n     * milliseconds.  Defaults to {@link Config}#ddlTimeout (if\n     * <em>opt.complete</em> is true, separate default timeouts are used for\n     * issuing the DDL operation and waiting for its completion, with values\n     * of {@link Config}#ddlTimeout and {@link Config}#adminPollTimeout\n     * correspondingly)\n     * @param {boolean} [opt.complete] If set to true, the returned\n     * <em>Promise</em> will only resolve when the operation is completed\n     * @param {number} [opt.delay] If <em>opt.complete</em> is true, specifies\n     * delay between successive polls while waiting for operation completion.\n     * Defaults to {@link Config}#adminPollDelay.  Has no effect if\n     * <em>opt.complete</em> is not enabled\n     * @returns {Promise} Promise of {@link AdminResult}\n     * @see {@link AdminResult}\n     * @see {@link NoSQLClient#forCompletion}\n     */\n    adminDDL(stmt, opt) {\n        const req = {\n            api: this.adminDDL,\n            stmt,\n            opt\n        };\n        return opt != null && opt.complete ?\n            this._withCompletion(ops.AdminDDLOp, req) :\n            this._execute(ops.AdminDDLOp, req);\n    }\n\n    /**\n     * On-premise only.\n     * <p>\n     * Check the status of the operation performed by\n     * {@link NoSQLClient#adminDDL}.  Returns the status of the operation\n     * as {@link AdminResult}, that includes operation state and operation\n     * output if any.\n     * @async\n     * @param {AdminResult} adminResult Result returned by\n     * {@link NoSQLClient#adminDDL}\n     * @param {object} [opt] Options object, see below\n     * @param {object} [opt.timeout]  Timeout for the operation in\n     * milliseconds, defaults to {@link Config}#timeout\n     * @returns {Promise} Promise of {@link AdminResult}\n     * @see {@link NoSQLClient#adminDDL}\n     * @see {@link AdminResult}\n     */\n    adminStatus(adminResult, opt) {\n        return this._adminStatus({\n            api: this.adminStatus,\n            adminResult,\n            opt\n        });\n    }\n\n    /**\n     * Asynchronously waits for DDL operation completion.\n     * <p>\n     * DDL operations are operations initiated by {@link NoSQLClient#tableDDL}\n     * and {@link NoSQLClient#adminDDL} (the latter On-premise only).  These\n     * are potentially long-running operations and the results returned by\n     * {@link NoSQLClient#tableDDL} or {@link NoSQLClient#adminDDL} do not\n     * imply operation completion.  {@link NoSQLClient#forCompletion} takes\n     * the result of either operation as an argument and completes (i.e. the\n     * returned <em>Promise</em> resolves) when the corresponding operation\n     * is completed by the service.  This is accomplished by polling the\n     * operation state at specified intervals using\n     * {@link NoSQLClient#getTable} for table DDL operations and\n     * {@link NoSQLClient#adminStatus} for admin DDL operations.\n     * <p>\n     * For table DDL operations initiated by {@link NoSQLClient#tableDDL} this\n     * method asynchronously waits for state {@link TableState.ACTIVE} for all\n     * operations except \"DROP TABLE\", in the latter case asynchronously\n     * waiting for {@link TableState.DROPPED}.\n     * <p>\n     * The result of this method is {@link TableResult} or {@link AdminResult}\n     * representing the state of the operation at the last poll.  If the\n     * operation fails, this method will result in error (i.e. the returned\n     * <em>Promise</em> will reject with error) contaning information about\n     * the operation failure.\n     * <p>\n     * Note that on operation completion, the passed {@link TableResult} or\n     * {@link AdminResult} is modified in place (to reflect operation\n     * completion) in addition to being returned.\n     * <p>\n     * As a more convenient way to perform DDL operations to completion, you\n     * may pass <em>opt.complete</em> to {@link NoSQLClient#tableDDL} or\n     * {@link NoSQLClient#adminDDL}.  In this case, after DDL operation is\n     * initiated, these methods will internally use\n     * {@link NoSQLClient#forCompletion} to await operation completion.\n     * @example // Using {@link NoSQLClient#forCompletion}\n     * try {\n     *     let res = await client.tableDDL('DROP TABLE.....');\n     *     await client.forCompletion(res);\n     *     res = await client.adminDDL('CREATE NAMESPACE.....');\n     *     await client.forCompletion(res);\n     * } catch(err) {\n     *     // May be caused by client.forCompletion() if long running DDL\n     *     // operation was unsuccessful.\n     * }\n     * @async\n     * @param {TableResult|AdminResult} res Result of\n     * {@link NoSQLClient#tableDDL} or {@link NoSQLClient#adminDDL}.  This\n     * result is modified by this method on operation completion.\n     * @param {object} [opt] Options object, see below\n     * @param {string} [opt.compartment] Cloud service only. Compartment id\n     * or name to use for this operation. Defaults to\n     * {@link Config}#compartment. See {@link Config}#compartment for more\n     * information\n     * @param {number} [opt.timeout] Timeout in milliseconds, i.e. how\n     * long to keep polling for operation completion.  Defaults to\n     * {@link Config}#tablePollTimeout for table DDL operations or to\n     * {@link Config}#adminPollTimeout for admin DDL operations\n     * @param {number} [opt.delay] Delay in milliseconds between\n     * successive polls, determines how often the polls are performed.\n     * Defaults to {@link Config}#tablePollDelay for table DDL operations or\n     * to {@link Config}#adminPollDelay for admin DDL operations\n     * @returns {Promise} Promise of {@link TableResult} or\n     * {@link AdminResult}, which is the object passed as first argument and\n     * modified to reflect operation completion\n     * @see {@link NoSQLClient#tableDDL}\n     * @see {@link NoSQLClient#getTable}\n     * @see {@link TableResult}\n     * @see {@link NoSQLClient#adminDDL}\n     * @see {@link NoSQLClient#adminStatus}\n     * @see {@link AdminResult}\n     */\n    forCompletion(res, opt) {\n        return this._forCompletion(res, opt);\n    }\n\n    /**\n     * On-premise only.\n     * <p>\n     * Returns the namespaces in the store as an array of strings.  If no\n     * namespaces are found, empty array is returned.\n     * <p>\n     * This operation entails executing admin DDL and waiting for the\n     * operation completion.\n     * @async\n     * @param {object} [opt] Options object, see below\n     * @param {number} [opt.timeout=30000] Timeout for the operation in\n     * milliseconds\n     * @param {number} [opt.delay] Same as in {@link NoSQLClient#adminDDL}\n     * @returns {Promise} Promise of string[] of namespace names\n     * @see {@link NoSQLClient#adminDDL}\n     */\n    listNamespaces(opt) {\n        return this._listNamespaces(opt);\n    }\n\n    /**\n     * On-premise only.\n     * <p>\n     * Returns the users in the store as an array of {@link UserInfo}.  If no\n     * users are found, empty array is returned.\n     * <p>\n     * This operation entails executing admin DDL and waiting for the\n     * operation completion.\n     * @async\n     * @param {object} [opt] Options object, see below\n     * @param {number} [opt.timeout=30000] Timeout for the operation in\n     * milliseconds\n     * @param {number} [opt.delay] Same as in {@link NoSQLClient#adminDDL}\n     * @returns {Promise} Promise of {@link UserInfo}[] of objects containing\n     * information about each user\n     * @see {@link UserInfo}\n     * @see {@link NoSQLClient#adminDDL}\n     */\n    listUsers(opt) {\n        return this._listUsers(opt);\n    }\n\n    /**\n     * On-premise only.\n     * <p>\n     * Returns the roles in the store as an array of strings.  If no\n     * roles are found, empty array is returned.\n     * <p>\n     * This operation entails executing admin DDL and waiting for the\n     * operation completion.\n     * @async\n     * @param {object} [opt] Options object, see below\n     * @param {number} [opt.timeout=30000] Timeout for the operation in\n     * milliseconds\n     * @param {number} [opt.delay] Same as in {@link NoSQLClient#adminDDL}\n     * @returns {Promise} Promise of string[] of role names\n     * @see {@link NoSQLClient#adminDDL}\n     */\n    listRoles(opt) {\n        return this._listRoles(opt);\n    }\n\n    addReplica(tableName, region, opt) {\n        const req = {\n            api: this.addReplica,\n            tableName,\n            region,\n            opt\n        };\n        return opt != null && opt.complete ?\n            this._withCompletion(ops.AddReplicaOp, req) :\n            this._execute(ops.AddReplicaOp, req);\n    }\n\n    dropReplica(tableName, region, opt) {\n        const req = {\n            api: this.dropReplica,\n            tableName,\n            region,\n            opt\n        };\n        return opt != null && opt.complete ?\n            this._withCompletion(ops.DropReplicaOp, req) :\n            this._execute(ops.DropReplicaOp, req);\n    }\n\n    forLocalReplicaInit(tableName, opt) {\n        return this._forLocalReplicaInit(tableName, opt);\n    }\n\n    getReplicaStats(tableName, opt) {\n        return this._execute(ops.ReplicaStatsOp, {\n            api: this.getReplicaStats,\n            tableName,\n            opt\n        });\n    }\n\n    /**\n     * For testing only.\n     * @returns {number} The current serial version in use\n     */\n    getSerialVersion() {\n        return this._getSerialVersion();\n    }\n}\n\n/**\n * NoSQLClient error event.\n *\n * Emitted when any {@link NoSQLClient} method results in error.  This event\n * is not emitted when automatic retries are performed, only when the error is\n * final.\n * <p>\n * Also mote that this event will not be emitted if it has no listeners, so it\n * is not necessary to subscribe to it.\n *\n * @event NoSQLClient#error\n * @param {NoSQLError} err Error of type NoSQLError or one of its subclasses\n * @param {Operation} op Object describing operation that\n * caused the error, see {@link Operation}\n */\n\n/**\n * NoSQLClient retryable event.\n *\n * Emitted when error from {@link NoSQLClient} operation will result in\n * automatic retry of operation.  It will be emitted on each subsequent retry.\n * @see {@link RetryConfig} for explanation of retries\n *\n * @event NoSQLClient#retryable\n * @param {NoSQLError} err Error of type NoSQLError or one of its subclasses\n * that caused the retry\n * @param {Operation} op Object describing operation that caused the error,\n * see {@link Operation}\n * @param {number} numRetries Number of retries performed so far for this\n * operation, not counting the original API invokation or the retry about to\n * be performed\n */\n\n/**\n * NoSQLClient consumedCapacity event.\n *\n * Emitted by {@link NoSQLClient} method calls that return\n * {@link ConsumedCapacity} as part of their result.  These methods include\n * all data manipulation and query methods.  This event may be used to\n * calculate relevant statistsics.\n *\n * @event NoSQLClient#consumedCapacity\n * @param {ConsumedCapacity} consumedCapacity Capacity consumed by the method\n * call, {@link ConsumedCapacity}\n * @param {Operation} op Object describing operation that returned this consumed\n * capacity, see {@link Operation}\n */\n\n/**\n * NoSQLClient tableState event.\n *\n * Emitted by {@link NoSQLClient} method calls that return table state as part\n * of their result, such as {@link NoSQLClient#getTable},\n * {@link NoSQLClient#tableDDL} and {@link NoSQLClient#setTableLimits} and\n * also while table is polled waiting for DDL operation completion using\n * {@link NoSQLClient#forCompletion}.  Can be used to perform actions on a\n * table reaching certain state.  Note that this event may be emitted mutliple\n * times even while the table state did not change.\n *\n * @event NoSQLClient#tableState\n * @param {string} tableName Table name\n * @param {TableState} tableState Current table state, see {@link TableState}\n */\n\nmodule.exports = NoSQLClient;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC5B,MAAMC,eAAe,GAAGD,OAAO,CAAC,qBAAqB,CAAC;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,WAAW,SAASD,eAAe,CAAC;EAEtC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;EACjB;;EAEA;AACJ;AACA;AACA;EACI,WAAWC,OAAOA,CAAA,EAAG;IACjB,OAAOL,OAAO,CAAC,aAAa,CAAC,CAACM,eAAe;EACjD;;EAEA;AACJ;AACA;AACA;EACI,IAAIC,WAAWA,CAAA,EAAG;IACd,OAAO,IAAI,CAACC,OAAO,CAACD,WAAW;EACnC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,KAAKA,CAAA,EAAG;IACJ,OAAO,KAAK,CAACA,KAAK,CAAC,CAAC;EACxB;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAYA,CAAA,EAAG;IACX,OAAO,KAAK,CAACC,aAAa,CAAC,CAAC;EAChC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQA,CAACC,IAAI,EAAEC,GAAG,EAAE;IAChB,MAAMC,GAAG,GAAG;MACRC,GAAG,EAAE,IAAI,CAACJ,QAAQ;MAClBC,IAAI;MACJC;IACJ,CAAC;IACD,OAAOA,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACG,QAAQ,GAC9B,IAAI,CAACC,eAAe,CAACnB,GAAG,CAACoB,UAAU,EAAEJ,GAAG,CAAC,GACzC,IAAI,CAACK,QAAQ,CAACrB,GAAG,CAACoB,UAAU,EAAEJ,GAAG,CAAC;EAC1C;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIM,cAAcA,CAACC,SAAS,EAAEC,WAAW,EAAET,GAAG,EAAE;IACxCA,GAAG,GAAG,IAAI,CAACU,UAAU,CAACV,GAAG,EAAE;MAAES;IAAY,CAAC,CAAC;IAC3C,MAAMR,GAAG,GAAG;MACRC,GAAG,EAAE,IAAI,CAACK,cAAc;MACxBC,SAAS;MACTR;IACJ,CAAC;IACD,OAAOA,GAAG,CAACG,QAAQ,GACf,IAAI,CAACC,eAAe,CAACnB,GAAG,CAAC0B,aAAa,EAAEV,GAAG,CAAC,GAC5C,IAAI,CAACK,QAAQ,CAACrB,GAAG,CAAC0B,aAAa,EAAEV,GAAG,CAAC;EAC7C;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIW,YAAYA,CAACJ,SAAS,EAAEK,WAAW,EAAEC,YAAY,EAAEd,GAAG,EAAE;IACpDA,GAAG,GAAG,IAAI,CAACU,UAAU,CAACV,GAAG,EAAE;MAAEa,WAAW;MAAEC;IAAa,CAAC,CAAC;IACzD,MAAMb,GAAG,GAAG;MACRC,GAAG,EAAE,IAAI,CAACU,YAAY;MACtBJ,SAAS;MACTR;IACJ,CAAC;IACD,OAAOA,GAAG,CAACG,QAAQ,GACf,IAAI,CAACC,eAAe,CAACnB,GAAG,CAAC0B,aAAa,EAAEV,GAAG,CAAC,GAC5C,IAAI,CAACK,QAAQ,CAACrB,GAAG,CAAC0B,aAAa,EAAEV,GAAG,CAAC;EAC7C;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIc,QAAQA,CAACC,KAAK,EAAEhB,GAAG,EAAE;IACjB,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACgC,UAAU,EAAE;MACjCf,GAAG,EAAE,IAAI,CAACa,QAAQ;MAClBC,KAAK;MACLhB;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkB,aAAaA,CAACV,SAAS,EAAEW,UAAU,EAAEnB,GAAG,EAAE;IACtC,OAAO,IAAI,CAACoB,cAAc,CAACZ,SAAS,EAAEW,UAAU,EAAEnB,GAAG,CAAC;EAC1D;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIqB,aAAaA,CAACb,SAAS,EAAER,GAAG,EAAE;IAC1B,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACqC,YAAY,EAAE;MACnCpB,GAAG,EAAE,IAAI,CAACmB,aAAa;MACvBb,SAAS;MACTR;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIuB,kBAAkBA,CAACf,SAAS,EAAER,GAAG,EAAE;IAC/B,OAAO,IAAI,CAACwB,mBAAmB,CAAChB,SAAS,EAAER,GAAG,CAAC;EACnD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIyB,UAAUA,CAACjB,SAAS,EAAER,GAAG,EAAE;IACvB,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACyC,YAAY,EAAE;MACnCxB,GAAG,EAAE,IAAI,CAACuB,UAAU;MACpBjB,SAAS;MACTR;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI2B,QAAQA,CAACnB,SAAS,EAAEoB,SAAS,EAAE5B,GAAG,EAAE;IAChC,OAAO,IAAI,CAAC6B,SAAS,CAACrB,SAAS,EAAEoB,SAAS,EAAE5B,GAAG,CAAC;EACpD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI8B,UAAUA,CAAC9B,GAAG,EAAE;IACZ,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAAC8C,YAAY,EAAE;MACnC7B,GAAG,EAAE,IAAI,CAAC4B,UAAU;MACpB9B;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIgC,GAAGA,CAACxB,SAAS,EAAEyB,GAAG,EAAEjC,GAAG,EAAE;IACrB,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACiD,KAAK,EAAE;MAC5BhC,GAAG,EAAE,IAAI,CAAC8B,GAAG;MACbxB,SAAS;MACTyB,GAAG;MACHjC;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImC,GAAGA,CAAC3B,SAAS,EAAE4B,GAAG,EAAEpC,GAAG,EAAE;IACrB,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACoD,KAAK,EAAE;MAC5BnC,GAAG,EAAE,IAAI,CAACiC,GAAG;MACb3B,SAAS;MACT4B,GAAG;MACHpC;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIsC,WAAWA,CAAC9B,SAAS,EAAE4B,GAAG,EAAEpC,GAAG,EAAE;IAC7B,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACoD,KAAK,EAAE;MAC5BnC,GAAG,EAAE,IAAI,CAACoC,WAAW;MACrB9B,SAAS;MACT4B,GAAG;MACHpC,GAAG,EAAE,IAAI,CAACU,UAAU,CAACV,GAAG,EAAE;QAAEuC,QAAQ,EAAE;MAAK,CAAC;IAChD,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAYA,CAAChC,SAAS,EAAE4B,GAAG,EAAEpC,GAAG,EAAE;IAC9B,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACoD,KAAK,EAAE;MAC5BnC,GAAG,EAAE,IAAI,CAACsC,YAAY;MACtBhC,SAAS;MACT4B,GAAG;MACHpC,GAAG,EAAE,IAAI,CAACU,UAAU,CAACV,GAAG,EAAE;QAAEyC,SAAS,EAAE;MAAK,CAAC;IACjD,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAYA,CAAClC,SAAS,EAAE4B,GAAG,EAAEO,YAAY,EAAE3C,GAAG,EAAE;IAC5C,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACoD,KAAK,EAAE;MAC5BnC,GAAG,EAAE,IAAI,CAACwC,YAAY;MACtBlC,SAAS;MACT4B,GAAG;MACHpC,GAAG,EAAE,IAAI,CAACU,UAAU,CAACV,GAAG,EAAE;QAAE2C;MAAa,CAAC;IAC9C,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,MAAMA,CAACpC,SAAS,EAAEyB,GAAG,EAAEjC,GAAG,EAAE;IACxB,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAAC4D,QAAQ,EAAE;MAC/B3C,GAAG,EAAE,IAAI,CAAC0C,MAAM;MAChBpC,SAAS;MACTyB,GAAG;MACHjC;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI8C,eAAeA,CAACtC,SAAS,EAAEyB,GAAG,EAAEU,YAAY,EAAE3C,GAAG,EAAE;IAC/C,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAAC4D,QAAQ,EAAE;MAC/B3C,GAAG,EAAE,IAAI,CAAC4C,eAAe;MACzBtC,SAAS;MACTyB,GAAG;MACHjC,GAAG,EAAE,IAAI,CAACU,UAAU,CAACV,GAAG,EAAE;QAAE2C;MAAa,CAAC;IAC9C,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,WAAWA,CAACvC,SAAS,EAAEyB,GAAG,EAAEjC,GAAG,EAAE;IAC7B,OAAOA,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACgD,GAAG,GACzB,IAAI,CAACC,eAAe,CAACzC,SAAS,EAAEyB,GAAG,EAAEjC,GAAG,CAAC,GACzC,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACiE,aAAa,EAAE;MAC7BhD,GAAG,EAAE,IAAI,CAAC6C,WAAW;MACrBvC,SAAS;MACTyB,GAAG;MACHjC;IACJ,CAAC,CAAC;EACV;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImD,SAASA,CAAC3C,SAAS,EAAE4C,UAAU,EAAEpD,GAAG,EAAE;IAClC;IACA;IACA,IAAIqD,KAAK,CAACC,OAAO,CAAC9C,SAAS,CAAC,IAAI,CAAC6C,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,EAAE;MACxDpD,GAAG,GAAGoD,UAAU;MAChBA,UAAU,GAAG5C,SAAS;MACtBA,SAAS,GAAG+C,SAAS;IACzB;IACA,OAAO,IAAI,CAACjD,QAAQ,CAACrB,GAAG,CAACuE,eAAe,EAAE;MACtCtD,GAAG,EAAE,IAAI,CAACiD,SAAS;MACnB3C,SAAS;MACTvB,GAAG,EAAEmE,UAAU;MACfpD;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIyD,OAAOA,CAACjD,SAAS,EAAEkD,IAAI,EAAE1D,GAAG,EAAE;IAC1B,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACuE,eAAe,EAAE;MACtCtD,GAAG,EAAE,IAAI,CAACuD,OAAO;MACjBjD,SAAS;MACTkD,IAAI;MACJ1D;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI2D,UAAUA,CAACnD,SAAS,EAAEoD,IAAI,EAAE5D,GAAG,EAAE;IAC7B,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACuE,eAAe,EAAE;MACtCtD,GAAG,EAAE,IAAI,CAACyD,UAAU;MACpBnD,SAAS;MACToD,IAAI;MACJ5D;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI6D,OAAOA,CAAC9D,IAAI,EAAEC,GAAG,EAAE;IACf,OAAO,IAAI,CAAC8D,QAAQ,CAAC/D,IAAI,EAAEC,GAAG,CAAC;EACnC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+D,KAAKA,CAAChE,IAAI,EAAEC,GAAG,EAAE;IACb,OAAO,IAAI,CAACgE,MAAM,CAACjE,IAAI,EAAEC,GAAG,CAAC;EACjC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIiE,aAAaA,CAAClE,IAAI,EAAEC,GAAG,EAAE;IACrB,OAAO,IAAI,CAACkE,cAAc,CAACnE,IAAI,EAAEC,GAAG,CAAC;EACzC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImE,QAAQA,CAACpE,IAAI,EAAEC,GAAG,EAAE;IAChB,MAAMC,GAAG,GAAG;MACRC,GAAG,EAAE,IAAI,CAACiE,QAAQ;MAClBpE,IAAI;MACJC;IACJ,CAAC;IACD,OAAOA,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACG,QAAQ,GAC9B,IAAI,CAACC,eAAe,CAACnB,GAAG,CAACmF,UAAU,EAAEnE,GAAG,CAAC,GACzC,IAAI,CAACK,QAAQ,CAACrB,GAAG,CAACmF,UAAU,EAAEnE,GAAG,CAAC;EAC1C;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIoE,WAAWA,CAACC,WAAW,EAAEtE,GAAG,EAAE;IAC1B,OAAO,IAAI,CAACuE,YAAY,CAAC;MACrBrE,GAAG,EAAE,IAAI,CAACmE,WAAW;MACrBC,WAAW;MACXtE;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIwE,aAAaA,CAACC,GAAG,EAAEzE,GAAG,EAAE;IACpB,OAAO,IAAI,CAAC0E,cAAc,CAACD,GAAG,EAAEzE,GAAG,CAAC;EACxC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI2E,cAAcA,CAAC3E,GAAG,EAAE;IAChB,OAAO,IAAI,CAAC4E,eAAe,CAAC5E,GAAG,CAAC;EACpC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI6E,SAASA,CAAC7E,GAAG,EAAE;IACX,OAAO,IAAI,CAAC8E,UAAU,CAAC9E,GAAG,CAAC;EAC/B;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+E,SAASA,CAAC/E,GAAG,EAAE;IACX,OAAO,IAAI,CAACgF,UAAU,CAAChF,GAAG,CAAC;EAC/B;EAEAiF,UAAUA,CAACzE,SAAS,EAAE0E,MAAM,EAAElF,GAAG,EAAE;IAC/B,MAAMC,GAAG,GAAG;MACRC,GAAG,EAAE,IAAI,CAAC+E,UAAU;MACpBzE,SAAS;MACT0E,MAAM;MACNlF;IACJ,CAAC;IACD,OAAOA,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACG,QAAQ,GAC9B,IAAI,CAACC,eAAe,CAACnB,GAAG,CAACkG,YAAY,EAAElF,GAAG,CAAC,GAC3C,IAAI,CAACK,QAAQ,CAACrB,GAAG,CAACkG,YAAY,EAAElF,GAAG,CAAC;EAC5C;EAEAmF,WAAWA,CAAC5E,SAAS,EAAE0E,MAAM,EAAElF,GAAG,EAAE;IAChC,MAAMC,GAAG,GAAG;MACRC,GAAG,EAAE,IAAI,CAACkF,WAAW;MACrB5E,SAAS;MACT0E,MAAM;MACNlF;IACJ,CAAC;IACD,OAAOA,GAAG,IAAI,IAAI,IAAIA,GAAG,CAACG,QAAQ,GAC9B,IAAI,CAACC,eAAe,CAACnB,GAAG,CAACoG,aAAa,EAAEpF,GAAG,CAAC,GAC5C,IAAI,CAACK,QAAQ,CAACrB,GAAG,CAACoG,aAAa,EAAEpF,GAAG,CAAC;EAC7C;EAEAqF,mBAAmBA,CAAC9E,SAAS,EAAER,GAAG,EAAE;IAChC,OAAO,IAAI,CAACuF,oBAAoB,CAAC/E,SAAS,EAAER,GAAG,CAAC;EACpD;EAEAwF,eAAeA,CAAChF,SAAS,EAAER,GAAG,EAAE;IAC5B,OAAO,IAAI,CAACM,QAAQ,CAACrB,GAAG,CAACwG,cAAc,EAAE;MACrCvF,GAAG,EAAE,IAAI,CAACsF,eAAe;MACzBhF,SAAS;MACTR;IACJ,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;EACI0F,gBAAgBA,CAAA,EAAG;IACf,OAAO,IAAI,CAACC,iBAAiB,CAAC,CAAC;EACnC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAGzG,WAAW","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}