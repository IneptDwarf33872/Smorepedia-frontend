{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst PlanIterator = require('./common').PlanIterator;\nconst ArithOpcode = require('./common').ArithOpcode;\nconst isNumeric = require('./utils').isNumeric;\n\n//Avoid ReferenceError(s) in case bigint is not supported.\nconst BigIntCons = typeof BigInt === 'function' ? BigInt : Number;\n\n//Just in case it is not supported in some browsers.\nif (!Math.trunc) {\n  Math.trunc = function (val) {\n    return val > 0 ? Math.floor(val) : Math.ceil(val);\n  };\n}\n\n//3rd party number library may not support any operations with bigint, so we\n//have to convert bigint to the 3rd party number object. Going through string\n//ensures the precision is preserved.\nfunction _bigint2dbnum(ctx, val) {\n  return typeof val !== 'bigint' ? val : ctx._dbNumber.create(val.toString());\n}\n\n//Always create 3rd party number object, going through string for bigint to\n//preserve precision.\nfunction _val2dbnum(ctx, val) {\n  return ctx._dbNumber.create(typeof val !== 'bigint' ? val : val.toString());\n}\n\n//Assuming this function will be inlined.\nfunction _has1bigint(val1, val2) {\n  return typeof val1 === 'bigint' != (typeof val2 === 'bigint');\n}\n\n//This function assumes that one of val1, val2 is bigint and the other one is\n//number.  Unfortunately we don't have the db type information for the value\n//of type number to determine if both should be treated as db type Long or\n//Double.  Assume that number value representing exact integer should be\n//coerced to bigint if the other argument is bigint.\nfunction _normalizeArgsWithBigint(val1, val2) {\n  if (typeof val1 === 'bigint') {\n    if (Number.isSafeInteger(val2)) {\n      val2 = BigIntCons(val2);\n    } else {\n      val1 = Number(val1);\n    }\n  } else {\n    //typeof val2 === 'bigint'\n    if (Number.isSafeInteger(val1)) {\n      val1 = BigIntCons(val1);\n    } else {\n      val2 = Number(val2);\n    }\n  }\n  return {\n    val1,\n    val2\n  };\n}\nfunction _add(ctx, val1, val2) {\n  if (ctx._dbNumber != null) {\n    if (ctx._dbNumber.isInstance(val1)) {\n      return ctx._dbNumber.add(val1, _bigint2dbnum(ctx, val2));\n    }\n    if (ctx._dbNumber.isInstance(val2)) {\n      return ctx._dbNumber.add(val2, _bigint2dbnum(ctx, val1));\n    }\n  }\n  if (_has1bigint(val1, val2)) {\n    ({\n      val1,\n      val2\n    } = _normalizeArgsWithBigint(val1, val2));\n  }\n  return val1 + val2;\n}\nfunction _sub(ctx, val1, val2) {\n  if (ctx._dbNumber != null) {\n    if (ctx._dbNumber.isInstance(val1)) {\n      return ctx._dbNumber.subtract(val1, _bigint2dbnum(ctx, val2));\n    }\n    if (ctx._dbNumber.isInstance(val2)) {\n      return ctx._dbNumber.subtract(_val2dbnum(ctx, val1), val2);\n    }\n  }\n  if (_has1bigint(val1, val2)) {\n    ({\n      val1,\n      val2\n    } = _normalizeArgsWithBigint(val1, val2));\n  }\n  return val1 - val2;\n}\nfunction _mul(ctx, val1, val2) {\n  if (ctx._dbNumber != null) {\n    if (ctx._dbNumber.isInstance(val1)) {\n      return ctx._dbNumber.multiply(val1, _bigint2dbnum(ctx, val2));\n    }\n    if (ctx._dbNumber.isInstance(val2)) {\n      return ctx._dbNumber.multiply(val2, _bigint2dbnum(ctx, val1));\n    }\n  }\n  if (_has1bigint(val1, val2)) {\n    ({\n      val1,\n      val2\n    } = _normalizeArgsWithBigint(val1, val2));\n  }\n  return val1 * val2;\n}\n\n//If any of the arguments is number, unfortunately we cannot determine if it\n//came from int, long or double field.  We perform floating-point division if\n//at least one of the arguments is number.  If both arguments are bigint, we\n//perform integer division.\nfunction _div(ctx, val1, val2) {\n  if (ctx._dbNumber != null) {\n    if (ctx._dbNumber.isInstance(val1)) {\n      return ctx._dbNumber.divide(val1, _bigint2dbnum(ctx, val2));\n    }\n    if (ctx._dbNumber.isInstance(val2)) {\n      return ctx._dbNumber.divide(_val2dbnum(ctx, val1), val2);\n    }\n  }\n  if (_has1bigint(val1, val2)) {\n    val1 = Number(val1);\n    val2 = Number(val2);\n  }\n  //Perform integer division if both arguments are bigint, otherwise\n  //perform floating-point division.\n  return val1 / val2;\n}\nfunction _fpDiv(ctx, val1, val2) {\n  if (ctx._dbNumber != null) {\n    if (ctx._dbNumber.isInstance(val1)) {\n      return ctx._dbNumber.divide(val1, _bigint2dbnum(ctx, val2));\n    }\n    if (ctx._dbNumber.isInstance(val2)) {\n      return ctx._dbNumber.divide(_val2dbnum(ctx, val1), val2);\n    }\n  }\n  //Bigints don't support floating point division, so we always convert them\n  //to numbers.\n  if (typeof val1 === 'bigint') {\n    val1 = Number(val1);\n  }\n  if (typeof val2 === 'bigint') {\n    val2 = Number(val2);\n  }\n  return val1 / val2;\n}\n\n/*\n * Iterator to implement the arithmetic operators\n *\n * any_atomic? ArithOp(any?, ....)\n *\n * An instance of this iterator implements either addition/substraction among\n * two or more input values, or multiplication/division among two or more\n * input values. For example,\n * arg1 + arg2 - arg3 + arg4, or arg1 * arg2 * arg3 / arg4.\n *\n * The only arithmetic op that is strictly needed for the driver is the div\n * (real division) op, to compute an AVG aggregate function as the division of\n * a SUM by a COUNT. However, having all the arithmetic ops implemented allows\n * for expressions in the SELECT list that do arithmetic among aggregate\n * functions (for example: select a, sum(x) + sum(y) from foo group by a).\n */\nclass ArithOpIterator extends PlanIterator {\n  constructor(qpExec, step) {\n    super(qpExec, step);\n    this._argIters = step.args.map(arg => {\n      const it = qpExec.makeIterator(arg);\n      if (it._isAsync) {\n        throw this.illegalState(`Unexpected async input iterator \\\n${it._step.displayName} for ArithOpIterator`);\n      }\n      return it;\n    });\n  }\n\n  /*\n   * If step.opcode == ArithOpcode.OP_ADD_SUB, step.ops is a string of \"+\"\n   * and/or \"-\" chars, containing one such char per input value. For\n   * example, if the arithmetic expression is (arg1 + arg2 - arg3 + arg4)\n   * step.ops is \"++-+\".\n   *\n   * If step.opcode == ArithOpcode.OP_MULT_DIV, step.ops is a string of\n   * \"*\", \"/\", and/or \"d\" chars, containing one such char per input value.\n   * For example, if the arithmetic expression is\n   * (arg1 * arg2 * arg3 / arg4) step.ops is \"***\\/\". The \"d\" char is used\n   * for the div operator.\n   */\n\n  _doOp(op, val1, val2) {\n    if (this._step.opcode === ArithOpcode.OP_ADD_SUB) {\n      switch (op) {\n        case '+':\n          return _add(this, val1, val2);\n        case '-':\n          return _sub(this, val1, val2);\n        default:\n          break;\n      }\n    } else {\n      assert(this._step.opcode === ArithOpcode.OP_MULT_DIV);\n      switch (op) {\n        case '*':\n          return _mul(this, val1, val2);\n        case '/':\n          return _div(this, val1, val2);\n        case 'd':\n          return _fpDiv(this, val1, val2);\n        default:\n          break;\n      }\n    }\n    throw this.illegalState(`Invalid operation ${op} for \\\n            function code ${this._step.opcode.name}`);\n  }\n  next() {\n    let res = this._step.opcode === ArithOpcode.OP_ADD_SUB ? 0 : 1;\n    for (let i = 0; i < this._argIters.length; i++) {\n      const it = this._argIters[i];\n      if (!it.next()) {\n        return false;\n      }\n      const val = it.result;\n      if (val == null) {\n        this.result = undefined;\n        return true;\n      }\n      if (!isNumeric(this, val)) {\n        throw this.illegalArg(`Non-numeric operand for arithmetic \\\noperation: ${util.inspect(val)}`);\n      }\n      res = this._doOp(this._step.ops[i], res, val);\n    }\n    this.result = res;\n    return true;\n  }\n  reset() {\n    for (let it of this._argIters) {\n      it.reset();\n    }\n  }\n}\nmodule.exports = {\n  ArithOpIterator,\n  add: _add\n};","map":{"version":3,"names":["assert","require","util","PlanIterator","ArithOpcode","isNumeric","BigIntCons","BigInt","Number","Math","trunc","val","floor","ceil","_bigint2dbnum","ctx","_dbNumber","create","toString","_val2dbnum","_has1bigint","val1","val2","_normalizeArgsWithBigint","isSafeInteger","_add","isInstance","add","_sub","subtract","_mul","multiply","_div","divide","_fpDiv","ArithOpIterator","constructor","qpExec","step","_argIters","args","map","arg","it","makeIterator","_isAsync","illegalState","_step","displayName","_doOp","op","opcode","OP_ADD_SUB","OP_MULT_DIV","name","next","res","i","length","result","undefined","illegalArg","inspect","ops","reset","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/query/arith.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst util = require('util');\nconst PlanIterator = require('./common').PlanIterator;\nconst ArithOpcode = require('./common').ArithOpcode;\nconst isNumeric = require('./utils').isNumeric;\n\n//Avoid ReferenceError(s) in case bigint is not supported.\nconst BigIntCons = typeof BigInt === 'function' ? BigInt : Number;\n\n//Just in case it is not supported in some browsers.\nif (!Math.trunc) {\n    Math.trunc = function(val) {\n        return val > 0 ? Math.floor(val) : Math.ceil(val);\n    };\n}\n\n//3rd party number library may not support any operations with bigint, so we\n//have to convert bigint to the 3rd party number object. Going through string\n//ensures the precision is preserved.\nfunction _bigint2dbnum(ctx, val) {\n    return typeof val !== 'bigint' ?\n        val : ctx._dbNumber.create(val.toString());\n}\n\n//Always create 3rd party number object, going through string for bigint to\n//preserve precision.\nfunction _val2dbnum(ctx, val) {\n    return ctx._dbNumber.create(\n        typeof val !== 'bigint' ? val : val.toString());\n}\n\n//Assuming this function will be inlined.\nfunction _has1bigint(val1, val2) {\n    return (typeof val1 === 'bigint') != (typeof val2 === 'bigint');\n}\n\n//This function assumes that one of val1, val2 is bigint and the other one is\n//number.  Unfortunately we don't have the db type information for the value\n//of type number to determine if both should be treated as db type Long or\n//Double.  Assume that number value representing exact integer should be\n//coerced to bigint if the other argument is bigint.\nfunction _normalizeArgsWithBigint(val1, val2) {\n    if (typeof val1 === 'bigint') {\n        if (Number.isSafeInteger(val2)) {\n            val2 = BigIntCons(val2);\n        } else {\n            val1 = Number(val1);\n        }\n    } else { //typeof val2 === 'bigint'\n        if (Number.isSafeInteger(val1)) {\n            val1 = BigIntCons(val1);\n        } else {\n            val2 = Number(val2);\n        }\n    }\n    return { val1, val2 };\n}\n\nfunction _add(ctx, val1, val2) {\n    if (ctx._dbNumber != null) {\n        if (ctx._dbNumber.isInstance(val1)) {\n            return ctx._dbNumber.add(val1, _bigint2dbnum(ctx, val2));\n        }\n        if (ctx._dbNumber.isInstance(val2)) {\n            return ctx._dbNumber.add(val2, _bigint2dbnum(ctx, val1));\n        }\n    }\n    if (_has1bigint(val1, val2)) {\n        ({ val1, val2 } = _normalizeArgsWithBigint(val1, val2));\n    }\n    return val1 + val2;\n}\n\nfunction _sub(ctx, val1, val2) {\n    if (ctx._dbNumber != null) {\n        if (ctx._dbNumber.isInstance(val1)) {\n            return ctx._dbNumber.subtract(val1, _bigint2dbnum(ctx, val2));\n        }\n        if (ctx._dbNumber.isInstance(val2)) {\n            return ctx._dbNumber.subtract(_val2dbnum(ctx, val1), val2);\n        }\n    }\n    if (_has1bigint(val1, val2)) {\n        ({ val1, val2 } = _normalizeArgsWithBigint(val1, val2));\n    }\n    return val1 - val2;\n}\n\nfunction _mul(ctx, val1, val2) {\n    if (ctx._dbNumber != null) {\n        if (ctx._dbNumber.isInstance(val1)) {\n            return ctx._dbNumber.multiply(val1, _bigint2dbnum(ctx, val2));\n        }\n        if (ctx._dbNumber.isInstance(val2)) {\n            return ctx._dbNumber.multiply(val2, _bigint2dbnum(ctx, val1));\n        }\n    }\n    if (_has1bigint(val1, val2)) {\n        ({ val1, val2 } = _normalizeArgsWithBigint(val1, val2));\n    }\n    return val1 * val2;\n}\n\n//If any of the arguments is number, unfortunately we cannot determine if it\n//came from int, long or double field.  We perform floating-point division if\n//at least one of the arguments is number.  If both arguments are bigint, we\n//perform integer division.\nfunction _div(ctx, val1, val2) {\n    if (ctx._dbNumber != null) {\n        if (ctx._dbNumber.isInstance(val1)) {\n            return ctx._dbNumber.divide(val1, _bigint2dbnum(ctx, val2));\n        }\n        if (ctx._dbNumber.isInstance(val2)) {\n            return ctx._dbNumber.divide(_val2dbnum(ctx, val1), val2);\n        }\n    }\n    if (_has1bigint(val1, val2)) {\n        val1 = Number(val1);\n        val2 = Number(val2);\n    }\n    //Perform integer division if both arguments are bigint, otherwise\n    //perform floating-point division.\n    return val1 / val2;\n}\n\nfunction _fpDiv(ctx, val1, val2) {\n    if (ctx._dbNumber != null) {\n        if (ctx._dbNumber.isInstance(val1)) {\n            return ctx._dbNumber.divide(val1, _bigint2dbnum(ctx, val2));\n        }\n        if (ctx._dbNumber.isInstance(val2)) {\n            return ctx._dbNumber.divide(_val2dbnum(ctx, val1), val2);\n        }\n    }\n    //Bigints don't support floating point division, so we always convert them\n    //to numbers.\n    if (typeof val1 === 'bigint') {\n        val1 = Number(val1);\n    }\n    if (typeof val2 === 'bigint') {\n        val2 = Number(val2);\n    }\n    return val1 / val2;\n}\n\n/*\n * Iterator to implement the arithmetic operators\n *\n * any_atomic? ArithOp(any?, ....)\n *\n * An instance of this iterator implements either addition/substraction among\n * two or more input values, or multiplication/division among two or more\n * input values. For example,\n * arg1 + arg2 - arg3 + arg4, or arg1 * arg2 * arg3 / arg4.\n *\n * The only arithmetic op that is strictly needed for the driver is the div\n * (real division) op, to compute an AVG aggregate function as the division of\n * a SUM by a COUNT. However, having all the arithmetic ops implemented allows\n * for expressions in the SELECT list that do arithmetic among aggregate\n * functions (for example: select a, sum(x) + sum(y) from foo group by a).\n */\nclass ArithOpIterator extends PlanIterator {\n    \n    constructor(qpExec, step) {\n        super(qpExec, step);\n        this._argIters = step.args.map(arg => {\n            const it = qpExec.makeIterator(arg);\n            if (it._isAsync) {\n                throw this.illegalState(`Unexpected async input iterator \\\n${it._step.displayName} for ArithOpIterator`);\n            }\n            return it;\n        });\n    }\n\n    /*\n     * If step.opcode == ArithOpcode.OP_ADD_SUB, step.ops is a string of \"+\"\n     * and/or \"-\" chars, containing one such char per input value. For\n     * example, if the arithmetic expression is (arg1 + arg2 - arg3 + arg4)\n     * step.ops is \"++-+\".\n     *\n     * If step.opcode == ArithOpcode.OP_MULT_DIV, step.ops is a string of\n     * \"*\", \"/\", and/or \"d\" chars, containing one such char per input value.\n     * For example, if the arithmetic expression is\n     * (arg1 * arg2 * arg3 / arg4) step.ops is \"***\\/\". The \"d\" char is used\n     * for the div operator.\n     */\n\n    _doOp(op, val1, val2) {\n        if (this._step.opcode === ArithOpcode.OP_ADD_SUB) {\n            switch(op) {\n            case '+':\n                return _add(this, val1, val2);\n            case '-':\n                return _sub(this, val1, val2);\n            default:\n                break;\n            }\n        } else {\n            assert(this._step.opcode === ArithOpcode.OP_MULT_DIV);\n            switch(op) {\n            case '*':\n                return _mul(this, val1, val2);\n            case '/':\n                return _div(this, val1, val2);\n            case 'd': \n                return _fpDiv(this, val1, val2);\n            default:\n                break;\n            }\n        }\n        throw this.illegalState(`Invalid operation ${op} for \\\n            function code ${this._step.opcode.name}`);\n    }\n\n    next() {\n        let res = (this._step.opcode === ArithOpcode.OP_ADD_SUB) ? 0 : 1;\n        for(let i = 0; i < this._argIters.length; i++) {\n            const it = this._argIters[i];\n            if (!it.next()) {\n                return false;\n            }\n            const val = it.result;\n            if (val == null) {\n                this.result = undefined;\n                return true;\n            }\n            if (!isNumeric(this, val)) {\n                throw this.illegalArg(`Non-numeric operand for arithmetic \\\noperation: ${util.inspect(val)}`);\n            }\n            res = this._doOp(this._step.ops[i], res, val);\n        }\n        this.result = res;\n        return true;\n    }\n\n    reset() {\n        for(let it of this._argIters) {\n            it.reset();\n        }\n    }\n\n}\n\nmodule.exports = {\n    ArithOpIterator,\n    add: _add\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}