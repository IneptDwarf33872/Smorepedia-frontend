{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst ErrorCode = require('../error_code');\nconst NoSQLError = require('../error').NoSQLError;\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\nconst Consistency = require('../constants').Consistency;\nconst SyncPolicy = require('../durability').SyncPolicy;\nconst ReplicaAckPolicy = require('../durability').ReplicaAckPolicy;\nconst Limits = require('../constants').Limits;\nconst Config = require('../config');\nconst isPosInt32 = require('../utils').isPosInt32;\nconst isPlainObject = require('../utils').isPlainObject;\nconst hasOwnProperty = require('../utils').hasOwnProperty;\nclass Op {\n  static _chkTblName(req) {\n    if (!req.tableName || typeof req.tableName !== 'string') {\n      throw new NoSQLArgumentError('Missing or invalid table name', req);\n    }\n  }\n  static _notSuppByProto(desc, suppVer, req) {\n    throw NoSQLError.create(ErrorCode.OPERATION_NOT_SUPPORTED, `${desc} is not supported because it requires minimum \\\nprotocol version ${suppVer}.  The service is running protocol version \\\n${req._serialVersion}`, null, req);\n  }\n  static _chkProtoVer(desc, suppVer, req) {\n    if (req._serialVersion < suppVer) {\n      throw this._notSuppByProto(desc, suppVer, req);\n    }\n  }\n  static _chkKey(req) {\n    if (typeof req.key === 'string') {\n      try {\n        req.key = JSON.parse(req.key);\n      } catch (err) {\n        throw new NoSQLArgumentError('Invalid JSON key', req, err);\n      }\n    }\n    if (!isPlainObject(req.key)) {\n      throw new NoSQLArgumentError('Invalid or missing key', req);\n    }\n  }\n  static _chkRow(req) {\n    if (typeof req.row === 'string') {\n      try {\n        req.row = JSON.parse(req.row);\n      } catch (err) {\n        throw new NoSQLArgumentError('Invalid JSON row', req, err);\n      }\n    }\n    if (!isPlainObject(req.row)) {\n      throw new NoSQLArgumentError('Invalid or missing row', req);\n    }\n  }\n  static _chkConsistency(req) {\n    if (!(req.opt.consistency instanceof Consistency)) {\n      throw new NoSQLArgumentError('Invalid consistency', req);\n    }\n  }\n  static _chkMatchVersion(req) {\n    if (req.opt.matchVersion != null && !(req.opt.matchVersion instanceof Buffer)) {\n      throw new NoSQLArgumentError('matchVersion must be instance of Buffer', req);\n    }\n  }\n  static _chkContinuationKey(req) {\n    const cc = req.opt.continuationKey;\n    if (cc != null && !Buffer.isBuffer(cc) && !cc[Op.ccAsObj]) {\n      throw new NoSQLArgumentError('Invalid continuation key', req);\n    }\n  }\n  static _validateDelay(req) {\n    if (!isPosInt32(req.opt.delay)) {\n      throw new NoSQLArgumentError('Invalid delay', req);\n    }\n    if (req.opt.timeout < req.opt.delay) {\n      throw new NoSQLArgumentError('Timeout cannot be less than delay', req);\n    }\n  }\n  static _validateFieldRange(req) {\n    const fr = req.opt.fieldRange;\n    if (fr == null) {\n      return;\n    }\n    if (typeof fr !== 'object') {\n      throw new NoSQLArgumentError('Invalid field range', req);\n    }\n    if (typeof fr.fieldName !== 'string' || !fr.fieldName.length) {\n      throw new NoSQLArgumentError('Invalid field name in field range', req);\n    }\n    if (fr.startWith == null && fr.startAfter == null && fr.endWith == null && fr.endBefore == null) {\n      throw new NoSQLArgumentError('Missing bounds in field range');\n    }\n    if (fr.startWith != null && fr.startAfter != null || fr.endWith != null && fr.endBefore != null) {\n      throw new NoSQLArgumentError('Both inclusive and exclusive bound \\\nspecified for one end of field range');\n    }\n  }\n\n  //Here we will conver the value to Date so that we don't have to do this\n  //again during serialization.  We accept any valid Date values as well as\n  //any number or string value passed to Date constructor (we will use\n  //the value from the resulting Date.getTime()).  Javascript Date range is\n  //+-100000 days since/before epoch, which is subset of java.util.Date\n  //range so we should be ok on the server side.\n  static _validateDateField(req, obj, field) {\n    if (obj[field] == null) {\n      return;\n    }\n    const d = obj[field];\n    //Date constructor accepts other types such as arrays but we don't\n    //allow this.\n    const v = d instanceof Date ? d : new Date(typeof d === 'number' || typeof d === 'string' ? d : NaN);\n    if (!Number.isFinite(v.getTime())) {\n      // NaN for invalid date\n      throw new NoSQLArgumentError(`Invalid ${field} value`, req);\n    }\n    obj[field] = v;\n  }\n  static _validateOpt(req) {\n    //Check that opt did not specify properties that it is not allowed\n    //to override\n    for (let key of this.NO_OVERRIDE_OPTS) {\n      if (hasOwnProperty(req.opt, key)) {\n        throw new NoSQLArgumentError(`Options may not override ${key}`, req);\n      }\n    }\n  }\n  static _validateTimeout(req) {\n    if (!isPosInt32(req.opt.timeout)) {\n      throw new NoSQLArgumentError(`Invalid timeout: ${req.opt.timeout}`, req);\n    }\n  }\n  static _validateDurability(req) {\n    if (req.opt == null || req.opt.durability == null) {\n      return;\n    }\n    if (!(req.opt.durability.masterSync instanceof SyncPolicy)) {\n      throw new NoSQLArgumentError(`Invalid durability.masterSync: \\\n${req.opt.durability.masterSync}`, req);\n    }\n    if (!(req.opt.durability.replicaSync instanceof SyncPolicy)) {\n      throw new NoSQLArgumentError(`Invalid durability.replicaSync: \\\n${req.opt.durability.replicaSync}`, req);\n    }\n    if (!(req.opt.durability.replicaAck instanceof ReplicaAckPolicy)) {\n      throw new NoSQLArgumentError(`Invalid durability.replicaAck: \\\n${req.opt.durability.replicaAck}`, req);\n    }\n  }\n  static _validateRequest(req) {\n    this._validateOpt(req);\n    this._validateTimeout(req);\n    //set timeout to use for single request (vs timeout across retries)\n    req.opt.requestTimeout = Math.min(req.opt.timeout, Limits.MAX_REQUEST_TIMEOUT);\n  }\n  static _validateReadRequest(req) {\n    this._validateRequest(req);\n    this._chkTblName(req);\n    this._chkConsistency(req);\n  }\n  static _validateWriteRequest(req, isSubRequest) {\n    if (!isSubRequest) {\n      this._validateRequest(req);\n      this._chkTblName(req);\n    } else {\n      this._validateOpt(req);\n    }\n    this._validateDurability(req);\n  }\n  static get REQUEST_SIZE_LIMIT() {\n    return Limits.REQUEST_SIZE;\n  }\n  static _chkRequestSizeLimit(req, len) {\n    if (len > this.REQUEST_SIZE_LIMIT) {\n      throw new NoSQLError(ErrorCode.REQUEST_SIZE_LIMIT_EXCEEDED, `Request size ${len} exceeds the limit of ` + `${this.REQUEST_SIZE_LIMIT}`, null, req);\n    }\n  }\n  static chkRequestSizeLimit(pm, buf, req) {\n    this._chkRequestSizeLimit(req, pm.getContentLength(buf));\n  }\n  static serialize(pm, buf, req) {\n    const writer = pm.getWriter(buf);\n    pm.startWrite(writer, req);\n    const serializer = pm.serializer(this.name);\n    assert(serializer != null);\n    serializer.serialize(writer, req, req._serialVersion);\n    this.chkRequestSizeLimit(pm, buf, req);\n  }\n  static deserialize(pm, buf, req) {\n    const reader = pm.getReader(buf);\n    pm.startRead(reader, req);\n    const serializer = pm.serializer(this.name);\n    assert(serializer != null);\n    return serializer.deserialize(reader, req, req._serialVersion);\n  }\n  static applyDefaults(req, def) {\n    req.opt = Config.inheritOpt(req.opt, def, req);\n  }\n  static validate() {}\n  static onResult(client, req, res) {\n    if (res.consumedCapacity) {\n      client.emit('consumedCapacity', res.consumedCapacity, req);\n    }\n    //query topology may be received by any dml/query result\n    if (res._topoInfo && (!client._config._topoInfo || client._config._topoInfo.seqNum < res._topoInfo.seqNum)) {\n      client._config._topoInfo = res._topoInfo;\n    }\n  }\n\n  //Subclasses may provide req as an argument if needed\n  static shouldRetry() {\n    return true;\n  }\n\n  //The following are used by rate limiter\n\n  static get supportsRateLimiting() {\n    return false;\n  }\n  static getTableName(req) {\n    return req.tableName;\n  }\n  static doesReads() {\n    return false;\n  }\n  static doesWrites() {\n    return false;\n  }\n\n  //Cloud only. Requests that may require cross-region auth in the proxy\n  //have to have their content signed (via \"x-content-sha256\" header).\n  static needsContentSigned() {\n    return false;\n  }\n\n  //The reason for dealing with protocol versions here is to abstract this\n  //logic from HttpClient, because now we have to deal with both serial\n  //version and query version. Prepare and query operations can override\n  //the 2 methods below to add code to deal with query version change (it\n  //also allows for operation-specific versioning of other operations if\n  //ever needed).\n\n  static setProtocolVersion(client, req) {\n    req._serialVersion = client._pm.serialVersion;\n  }\n\n  //Returns true if the operation can be retried immediately because we\n  //received UNSUPPORTED_PROTOCOL error.\n  static handleUnsupportedProtocol(client, req, err) {\n    //Check if we got UNSUPPORTED_PROTOCOL error and can can retry with\n    //older protocol, in which case we can immediately retry (otherwise\n    //use retry handler as usual).\n    if (err.errorCode === ErrorCode.UNSUPPORTED_PROTOCOL) {\n      if (!client._decrementSerialVersion(req._serialVersion)) {\n        throw err;\n      }\n      return true;\n    }\n    return false;\n  }\n  static protocolChanged(client, req) {\n    return req._serialVersion !== client._pm.serialVersion;\n  }\n}\n\n//These parameters have to be specified in initial configuration and may not\n//be overriden in options.\nOp.NO_OVERRIDE_OPTS = ['serviceType', 'retry', 'auth'];\n\n//For advanced queries and other possible cases where continuation key is\n//an object, this allows us to validate that user did not supply a bogus\n//value that could cause internal failures down the line\nOp.ccAsObj = Symbol('ccAsObj');\nmodule.exports = Op;","map":{"version":3,"names":["assert","require","ErrorCode","NoSQLError","NoSQLArgumentError","Consistency","SyncPolicy","ReplicaAckPolicy","Limits","Config","isPosInt32","isPlainObject","hasOwnProperty","Op","_chkTblName","req","tableName","_notSuppByProto","desc","suppVer","create","OPERATION_NOT_SUPPORTED","_serialVersion","_chkProtoVer","_chkKey","key","JSON","parse","err","_chkRow","row","_chkConsistency","opt","consistency","_chkMatchVersion","matchVersion","Buffer","_chkContinuationKey","cc","continuationKey","isBuffer","ccAsObj","_validateDelay","delay","timeout","_validateFieldRange","fr","fieldRange","fieldName","length","startWith","startAfter","endWith","endBefore","_validateDateField","obj","field","d","v","Date","NaN","Number","isFinite","getTime","_validateOpt","NO_OVERRIDE_OPTS","_validateTimeout","_validateDurability","durability","masterSync","replicaSync","replicaAck","_validateRequest","requestTimeout","Math","min","MAX_REQUEST_TIMEOUT","_validateReadRequest","_validateWriteRequest","isSubRequest","REQUEST_SIZE_LIMIT","REQUEST_SIZE","_chkRequestSizeLimit","len","REQUEST_SIZE_LIMIT_EXCEEDED","chkRequestSizeLimit","pm","buf","getContentLength","serialize","writer","getWriter","startWrite","serializer","name","deserialize","reader","getReader","startRead","applyDefaults","def","inheritOpt","validate","onResult","client","res","consumedCapacity","emit","_topoInfo","_config","seqNum","shouldRetry","supportsRateLimiting","getTableName","doesReads","doesWrites","needsContentSigned","setProtocolVersion","_pm","serialVersion","handleUnsupportedProtocol","errorCode","UNSUPPORTED_PROTOCOL","_decrementSerialVersion","protocolChanged","Symbol","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/ops/op.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst ErrorCode = require('../error_code');\nconst NoSQLError = require('../error').NoSQLError;\nconst NoSQLArgumentError = require('../error').NoSQLArgumentError;\nconst Consistency = require('../constants').Consistency;\nconst SyncPolicy = require('../durability').SyncPolicy;\nconst ReplicaAckPolicy = require('../durability').ReplicaAckPolicy;\nconst Limits = require('../constants').Limits;\nconst Config = require('../config');\nconst isPosInt32 = require('../utils').isPosInt32;\nconst isPlainObject = require('../utils').isPlainObject;\nconst hasOwnProperty = require('../utils').hasOwnProperty;\n\nclass Op {\n\n    static _chkTblName(req) {\n        if (!req.tableName || typeof req.tableName !== 'string') {\n            throw new NoSQLArgumentError('Missing or invalid table name',\n                req);\n        }\n    }\n\n    static _notSuppByProto(desc, suppVer, req) {\n        throw NoSQLError.create(ErrorCode.OPERATION_NOT_SUPPORTED,\n            `${desc} is not supported because it requires minimum \\\nprotocol version ${suppVer}.  The service is running protocol version \\\n${req._serialVersion}`, null, req);\n    }\n\n    static _chkProtoVer(desc, suppVer, req) {\n        if (req._serialVersion < suppVer) {\n            throw this._notSuppByProto(desc, suppVer, req);\n        }\n    }\n\n    static _chkKey(req) {\n        if (typeof req.key === 'string') {\n            try {\n                req.key = JSON.parse(req.key);\n            } catch(err) {\n                throw new NoSQLArgumentError('Invalid JSON key', req, err);\n            }\n        }\n        if (!isPlainObject(req.key)) {\n            throw new NoSQLArgumentError('Invalid or missing key', req);\n        }\n    }\n\n    static _chkRow(req) {\n        if (typeof req.row === 'string') {\n            try {\n                req.row = JSON.parse(req.row);\n            } catch(err) {\n                throw new NoSQLArgumentError('Invalid JSON row', req, err);\n            }\n        }\n        if (!isPlainObject(req.row)) {\n            throw new NoSQLArgumentError('Invalid or missing row', req);\n        }\n    }\n\n    static _chkConsistency(req) {\n        if (!(req.opt.consistency instanceof Consistency)) {\n            throw new NoSQLArgumentError('Invalid consistency', req);\n        }\n    }\n\n    static _chkMatchVersion(req) {\n        if (req.opt.matchVersion != null &&\n            !(req.opt.matchVersion instanceof Buffer)) {\n            throw new NoSQLArgumentError(\n                'matchVersion must be instance of Buffer', req);\n        }\n    }\n\n    static _chkContinuationKey(req) {\n        const cc = req.opt.continuationKey;\n        if (cc != null && !Buffer.isBuffer(cc) && !cc[Op.ccAsObj]) {\n            throw new NoSQLArgumentError('Invalid continuation key', req);\n        }\n    }\n\n    static _validateDelay(req) {\n        if (!isPosInt32(req.opt.delay)) {\n            throw new NoSQLArgumentError('Invalid delay', req);\n        }\n        if (req.opt.timeout < req.opt.delay) {\n            throw new NoSQLArgumentError('Timeout cannot be less than delay',\n                req);\n        }\n    }\n\n    static _validateFieldRange(req) {\n        const fr = req.opt.fieldRange;\n        if (fr == null) {\n            return;\n        }\n        if (typeof fr !== 'object') {\n            throw new NoSQLArgumentError('Invalid field range', req);\n        }\n        if (typeof fr.fieldName !== 'string' || !fr.fieldName.length) {\n            throw new NoSQLArgumentError('Invalid field name in field range',\n                req);\n        }\n        if (fr.startWith == null && fr.startAfter == null &&\n            fr.endWith == null && fr.endBefore == null) {\n            throw new NoSQLArgumentError('Missing bounds in field range');\n        }\n        if ((fr.startWith != null && fr.startAfter != null) ||\n            (fr.endWith != null && fr.endBefore != null)) {\n            throw new NoSQLArgumentError('Both inclusive and exclusive bound \\\nspecified for one end of field range');\n        }\n    }\n\n    //Here we will conver the value to Date so that we don't have to do this\n    //again during serialization.  We accept any valid Date values as well as\n    //any number or string value passed to Date constructor (we will use\n    //the value from the resulting Date.getTime()).  Javascript Date range is\n    //+-100000 days since/before epoch, which is subset of java.util.Date\n    //range so we should be ok on the server side.\n    static _validateDateField(req, obj, field) {\n        if (obj[field] == null) {\n            return;\n        }\n        const d = obj[field];\n        //Date constructor accepts other types such as arrays but we don't\n        //allow this.\n        const v = d instanceof Date ? d : new Date(\n            (typeof d === 'number' || typeof d === 'string') ? d : NaN);\n        if (!Number.isFinite(v.getTime())) { // NaN for invalid date\n            throw new NoSQLArgumentError(`Invalid ${field} value`, req);\n        }\n        obj[field] = v;\n    }\n\n    static _validateOpt(req) {\n        //Check that opt did not specify properties that it is not allowed\n        //to override\n        for(let key of this.NO_OVERRIDE_OPTS) {\n            if (hasOwnProperty(req.opt, key)) {\n                throw new NoSQLArgumentError(\n                    `Options may not override ${key}`, req);\n            }\n        }\n    }\n\n    static _validateTimeout(req) {\n        if (!isPosInt32(req.opt.timeout)) {\n            throw new NoSQLArgumentError(\n                `Invalid timeout: ${req.opt.timeout}`, req);\n        }\n    }\n\n    static _validateDurability(req) {\n        if (req.opt == null || req.opt.durability == null) {\n            return;\n        }\n        if (!(req.opt.durability.masterSync instanceof SyncPolicy)) {\n            throw new NoSQLArgumentError(\n                `Invalid durability.masterSync: \\\n${req.opt.durability.masterSync}`, req);\n        }\n        if (!(req.opt.durability.replicaSync instanceof SyncPolicy)) {\n            throw new NoSQLArgumentError(\n                `Invalid durability.replicaSync: \\\n${req.opt.durability.replicaSync}`, req);\n        }\n        if (!(req.opt.durability.replicaAck instanceof ReplicaAckPolicy)) {\n            throw new NoSQLArgumentError(\n                `Invalid durability.replicaAck: \\\n${req.opt.durability.replicaAck}`, req);\n        }\n    }\n\n    static _validateRequest(req) {\n        this._validateOpt(req);\n        this._validateTimeout(req);\n        //set timeout to use for single request (vs timeout across retries)\n        req.opt.requestTimeout = Math.min(req.opt.timeout,\n            Limits.MAX_REQUEST_TIMEOUT);\n    }\n\n    static _validateReadRequest(req) {\n        this._validateRequest(req);\n        this._chkTblName(req);\n        this._chkConsistency(req);\n    }\n\n    static _validateWriteRequest(req, isSubRequest) {\n        if (!isSubRequest) {\n            this._validateRequest(req);\n            this._chkTblName(req);\n        } else {\n            this._validateOpt(req);\n        }\n        this._validateDurability(req);\n    }\n\n    static get REQUEST_SIZE_LIMIT() {\n        return Limits.REQUEST_SIZE;\n    }\n\n    static _chkRequestSizeLimit(req, len) {\n        if (len > this.REQUEST_SIZE_LIMIT) {\n            throw new NoSQLError(ErrorCode.REQUEST_SIZE_LIMIT_EXCEEDED,\n                `Request size ${len} exceeds the limit of ` +\n                `${this.REQUEST_SIZE_LIMIT}`,\n                null,\n                req);\n        }\n    }\n\n    static chkRequestSizeLimit(pm, buf, req) {\n        this._chkRequestSizeLimit(req, pm.getContentLength(buf));\n    }\n\n    static serialize(pm, buf, req) {\n        const writer = pm.getWriter(buf);\n        pm.startWrite(writer, req);\n        const serializer = pm.serializer(this.name);\n        assert(serializer != null);\n        serializer.serialize(writer, req, req._serialVersion);\n        this.chkRequestSizeLimit(pm, buf, req);\n    }\n\n    static deserialize(pm, buf, req) {\n        const reader = pm.getReader(buf);\n        pm.startRead(reader, req);\n        const serializer = pm.serializer(this.name);\n        assert(serializer != null);\n        return serializer.deserialize(reader, req, req._serialVersion);\n    }\n\n    static applyDefaults(req, def) {\n        req.opt = Config.inheritOpt(req.opt, def, req);\n    }\n\n    static validate() {}\n\n    static onResult(client, req, res) {\n        if (res.consumedCapacity) {\n            client.emit('consumedCapacity', res.consumedCapacity, req);\n        }\n        //query topology may be received by any dml/query result\n        if (res._topoInfo && (!client._config._topoInfo ||\n            client._config._topoInfo.seqNum < res._topoInfo.seqNum)) {\n            client._config._topoInfo = res._topoInfo;\n        }\n    }\n\n    //Subclasses may provide req as an argument if needed\n    static shouldRetry() {\n        return true;\n    }\n\n    //The following are used by rate limiter\n\n    static get supportsRateLimiting() {\n        return false;\n    }\n\n    static getTableName(req) {\n        return req.tableName;\n    }\n\n    static doesReads() {\n        return false;\n    }\n\n    static doesWrites() {\n        return false;\n    }\n\n    //Cloud only. Requests that may require cross-region auth in the proxy\n    //have to have their content signed (via \"x-content-sha256\" header).\n    static needsContentSigned() {\n        return false;\n    }\n\n    //The reason for dealing with protocol versions here is to abstract this\n    //logic from HttpClient, because now we have to deal with both serial\n    //version and query version. Prepare and query operations can override\n    //the 2 methods below to add code to deal with query version change (it\n    //also allows for operation-specific versioning of other operations if\n    //ever needed).\n\n    static setProtocolVersion(client, req) {\n        req._serialVersion = client._pm.serialVersion;\n    }\n\n    //Returns true if the operation can be retried immediately because we\n    //received UNSUPPORTED_PROTOCOL error.\n    static handleUnsupportedProtocol(client, req, err) {\n        //Check if we got UNSUPPORTED_PROTOCOL error and can can retry with\n        //older protocol, in which case we can immediately retry (otherwise\n        //use retry handler as usual).\n        if (err.errorCode === ErrorCode.UNSUPPORTED_PROTOCOL) {\n            if (!client._decrementSerialVersion(req._serialVersion)) {\n                throw err;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    static protocolChanged(client, req) {\n        return req._serialVersion !== client._pm.serialVersion;\n    }\n\n}\n\n//These parameters have to be specified in initial configuration and may not\n//be overriden in options.\nOp.NO_OVERRIDE_OPTS = [ 'serviceType', 'retry', 'auth' ];\n\n//For advanced queries and other possible cases where continuation key is\n//an object, this allows us to validate that user did not supply a bogus\n//value that could cause internal failures down the line\nOp.ccAsObj = Symbol('ccAsObj');\n\nmodule.exports = Op;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}