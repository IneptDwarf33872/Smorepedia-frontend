{"ast":null,"code":"/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst process = require('process');\nconst sleep = require('../utils').sleep;\nconst NoSQLTimeoutError = require('../error').NoSQLTimeoutError;\nconst NANOS_IN_SEC = 1000000000;\nconst NANOS_IN_MS = 1000000;\n\n/**\n * @classdesc\n * Cloud Service or Cloud Simulator only.\n * <p>\n * Default implementation of rate limiter class used by the driver.\n * Two rate limiter instances are used per each table in use, one for reads\n * and another for writes.  See {@link RateLimiter}.\n * <p>\n * This implementation uses a token bucket based algorithm, although\n * the state is kept in terms of nano time instead of tokens.  It is assumed\n * that the units refill at constant rate being equivalent to the set limit\n * of units per second.  The state is kept in terms of <em>nextNano</em> which\n * is the time when the next operation can proceed without waiting, meaning\n * the limiter is at its limit.  All operations issued before\n * <em>nextNano</em> will have to wait accordingly.  Based on the value of\n * <em>nextNano</em> and the current time, the appropriate wait time may be\n * computed before the wait begins.  If current time is >= <em>nextNano</em>,\n * no wait is needed.\n * <p>\n * Note that when {@link SimpleRateLimiter#consumeUnits} is called, the\n * entered units will only affect the wait time of subsequent operations and\n * not the current operation, which will use the value of <em>nextNano</em> as\n * it was to determine its wait time.  This should avoid needless wait time\n * when the operations come in rarely.\n * <p> Because every time when {@link SimpleRateLimiter#consumeUnits} is\n * called with units > 0, <em>nextNano</em> is pushed forward, the operations\n * will be effectively staggered in time accoridng to the order of their\n * arrival with no preferrential treatment given to any operation, thus\n * avoiding starvation.\n * <p>\n * This limiter uses burst mode, allowing a set maximum number of stored units\n * that has not been used to be consumed immediately without waiting. This\n * value is expressed as <em>maxBurstSecs</em> or duration, which is\n * effectively a maximum number of seconds worth of unused stored units.\n * The minimum duration is internally bound such that at least one unused unit\n * may be consumed without waiting.  The default value of duration is\n * 30 seconds.\n * \n * @see {@link RateLimiter}\n * @see {@link Config}\n */\nclass SimpleRateLimiter {\n  /**\n   * Constructs an instance of SimpleRateLimiter\n   * @param {number} [maxBurstSecs=30] Duration as described above\n   */\n  constructor(maxBurstSecs = 30) {\n    this._nanosPerUnit = null;\n    this._durationNanos = BigInt(maxBurstSecs * NANOS_IN_SEC);\n    this._removePast = true;\n    this._nextNano = BigInt(0);\n  }\n  _consume(units, nowNanos, timeout) {\n    /* If disabled, just return success */\n    if (this._nanosPerUnit == null) {\n      return 0;\n    }\n\n    /* determine how many nanos we need to add based on units requested */\n    const nanosNeeded = units * this._nanosPerUnit;\n\n    /* ensure we never use more from the past than duration allows */\n    let maxPast;\n    if (this._removePast) {\n      maxPast = nowNanos;\n      this._removePast = false;\n    } else {\n      maxPast = nowNanos - this._durationNanos;\n    }\n    if (this._nextNano < maxPast) {\n      this._nextNano = maxPast;\n    }\n\n    /* compute the new \"next nano used\" */\n    const newNext = this._nextNano + BigInt(Math.round(nanosNeeded));\n\n    /* if units < 0, we're \"returning\" them */\n    if (units < 0) {\n      /* consume the units */\n      this._nextNano = newNext;\n      return 0;\n    }\n\n    /*\n     * if the limiter is currently under its limit, the consume\n     * succeeds immediately (no sleep required).\n     */\n    if (this._nextNano <= nowNanos) {\n      /* consume the units */\n      this._nextNano = newNext;\n      return 0;\n    }\n\n    /*\n     * determine the amount of time that the caller needs to sleep\n     * for this limiter to go below its limit. Note that the limiter\n     * is not guaranteed to be below the limit after this time, as\n     * other consume calls may come in after this one and push the\n     * \"at the limit time\" further out.\n     */\n    let sleepMs = Number(this._nextNano - nowNanos) / NANOS_IN_MS;\n    if (sleepMs < 1) {\n      sleepMs = 1;\n    }\n    if (timeout == null || sleepMs < timeout) {\n      this._nextNano = newNext;\n    }\n    return sleepMs;\n  }\n\n  /**\n   * Implements {@link RateLimiter#consumeUnits}\n   * @async\n   * @see {@link RateLimiter}\n   * @param {number} units Number of units to consume\n   * @param {number} timeout Timeout in milliseconds\n   * @param {boolean} consumeOnTimeout Whether to consume units on timeout\n   * or throw an error, see {@link RateLimiter#consumeUnits}\n   * @returns {Promise}  Promise resolved with sleeping time in milliseconds\n   * or rejected with {@link NoSQLTimeoutError}\n   */\n  async consumeUnits(units, timeout, consumeOnTimeout) {\n    const msToSleep = this._consume(units, process.hrtime.bigint(), consumeOnTimeout ? null : timeout);\n    if (msToSleep === 0) {\n      return 0;\n    }\n    if (timeout != null && msToSleep >= timeout) {\n      //If timeout is reached we sleep for timeout ms\n      await sleep(timeout);\n      if (consumeOnTimeout) {\n        return timeout;\n      }\n      //If timeout is reached and units were not consumed, we throw\n      //timeout error.\n      throw new NoSQLTimeoutError(`Rate limiter timed out waiting \\\n${timeout} ms for ${units} units`);\n    }\n    await sleep(msToSleep);\n    return msToSleep;\n  }\n\n  /**\n   * Implements {@link RateLimiter#setLimit}.  Sets the limiter limit\n   * (rate) in units per second.  Also, enforces minimum duration to be able\n   * to store at least one unused unit.  When changing table limits, will\n   * prorate any unused units according to the new limit.\n   * @param {number} limit Limit in units\n   */\n  setLimit(limit) {\n    //If limit is not positive, assume that the limiter is disabled\n    if (limit <= 0) {\n      this._nanosPerUnit = null;\n      return;\n    }\n    const oldNanosPerUnit = this._nanosPerUnit;\n    this._nanosPerUnit = NANOS_IN_SEC / limit;\n    if (this._durationNanos < this._nanosPerUnit) {\n      this._durationNanos = BigInt(Math.round(this._nanosPerUnit));\n    }\n    if (oldNanosPerUnit != null) {\n      const nowNanos = process.hrtime.bigint();\n      //prorate any unused capacity?\n      if (this._nextNano < nowNanos) {\n        this._nextNano = nowNanos - BigInt(Math.round(Number(nowNanos - this._nextNano) * this._nanosPerUnit / oldNanosPerUnit));\n      }\n    }\n  }\n\n  /**\n   * Implements {@link RateLimiter#onThrottle}.  Called when throttling\n   * error occurs when using this rate limiter instance.  Current\n   * implementation will remove any stored units by ensuring that\n   * <em>nextNano</em> is at least the current time.\n   */\n  onThrottle() {\n    this._removePast = true;\n  }\n}\nmodule.exports = SimpleRateLimiter;","map":{"version":3,"names":["process","require","sleep","NoSQLTimeoutError","NANOS_IN_SEC","NANOS_IN_MS","SimpleRateLimiter","constructor","maxBurstSecs","_nanosPerUnit","_durationNanos","BigInt","_removePast","_nextNano","_consume","units","nowNanos","timeout","nanosNeeded","maxPast","newNext","Math","round","sleepMs","Number","consumeUnits","consumeOnTimeout","msToSleep","hrtime","bigint","setLimit","limit","oldNanosPerUnit","onThrottle","module","exports"],"sources":["C:/Users/teddy/Desktop/VSCodeProjects/Smorepedia/smoresapp/node_modules/oracle-nosqldb/lib/rate_limiter/simple_rate_limiter.js"],"sourcesContent":["/*-\n * Copyright (c) 2018, 2024 Oracle and/or its affiliates. All rights reserved.\n *\n * Licensed under the Universal Permissive License v 1.0 as shown at\n *  https://oss.oracle.com/licenses/upl/\n */\n\n'use strict';\n\nconst process = require('process');\n\nconst sleep = require('../utils').sleep;\nconst NoSQLTimeoutError = require('../error').NoSQLTimeoutError;\n\nconst NANOS_IN_SEC = 1000000000;\nconst NANOS_IN_MS = 1000000;\n\n/**\n * @classdesc\n * Cloud Service or Cloud Simulator only.\n * <p>\n * Default implementation of rate limiter class used by the driver.\n * Two rate limiter instances are used per each table in use, one for reads\n * and another for writes.  See {@link RateLimiter}.\n * <p>\n * This implementation uses a token bucket based algorithm, although\n * the state is kept in terms of nano time instead of tokens.  It is assumed\n * that the units refill at constant rate being equivalent to the set limit\n * of units per second.  The state is kept in terms of <em>nextNano</em> which\n * is the time when the next operation can proceed without waiting, meaning\n * the limiter is at its limit.  All operations issued before\n * <em>nextNano</em> will have to wait accordingly.  Based on the value of\n * <em>nextNano</em> and the current time, the appropriate wait time may be\n * computed before the wait begins.  If current time is >= <em>nextNano</em>,\n * no wait is needed.\n * <p>\n * Note that when {@link SimpleRateLimiter#consumeUnits} is called, the\n * entered units will only affect the wait time of subsequent operations and\n * not the current operation, which will use the value of <em>nextNano</em> as\n * it was to determine its wait time.  This should avoid needless wait time\n * when the operations come in rarely.\n * <p> Because every time when {@link SimpleRateLimiter#consumeUnits} is\n * called with units > 0, <em>nextNano</em> is pushed forward, the operations\n * will be effectively staggered in time accoridng to the order of their\n * arrival with no preferrential treatment given to any operation, thus\n * avoiding starvation.\n * <p>\n * This limiter uses burst mode, allowing a set maximum number of stored units\n * that has not been used to be consumed immediately without waiting. This\n * value is expressed as <em>maxBurstSecs</em> or duration, which is\n * effectively a maximum number of seconds worth of unused stored units.\n * The minimum duration is internally bound such that at least one unused unit\n * may be consumed without waiting.  The default value of duration is\n * 30 seconds.\n * \n * @see {@link RateLimiter}\n * @see {@link Config}\n */\nclass SimpleRateLimiter {\n\n    /**\n     * Constructs an instance of SimpleRateLimiter\n     * @param {number} [maxBurstSecs=30] Duration as described above\n     */\n    constructor(maxBurstSecs = 30) {\n        this._nanosPerUnit = null;\n        this._durationNanos = BigInt(maxBurstSecs * NANOS_IN_SEC);\n        this._removePast = true;\n        this._nextNano = BigInt(0);\n    }\n\n    _consume(units, nowNanos, timeout) {\n        /* If disabled, just return success */\n        if (this._nanosPerUnit == null) {\n            return 0;\n        }\n\n        /* determine how many nanos we need to add based on units requested */\n        const nanosNeeded = units * this._nanosPerUnit;\n\n        /* ensure we never use more from the past than duration allows */\n        let maxPast;\n        if (this._removePast) {\n            maxPast = nowNanos;\n            this._removePast = false;\n        } else {\n            maxPast = nowNanos - this._durationNanos;\n        }\n\n        if (this._nextNano < maxPast) {\n            this._nextNano = maxPast;\n        }\n\n        /* compute the new \"next nano used\" */\n        const newNext = this._nextNano + BigInt(Math.round(nanosNeeded));\n\n        /* if units < 0, we're \"returning\" them */\n        if (units < 0) {\n            /* consume the units */\n            this._nextNano = newNext;\n            return 0;\n        }\n\n        /*\n         * if the limiter is currently under its limit, the consume\n         * succeeds immediately (no sleep required).\n         */\n        if (this._nextNano <= nowNanos) {\n            /* consume the units */\n            this._nextNano = newNext;\n            return 0;\n        }\n\n        /*\n         * determine the amount of time that the caller needs to sleep\n         * for this limiter to go below its limit. Note that the limiter\n         * is not guaranteed to be below the limit after this time, as\n         * other consume calls may come in after this one and push the\n         * \"at the limit time\" further out.\n         */\n        let sleepMs = Number(this._nextNano - nowNanos) / NANOS_IN_MS;\n        if (sleepMs < 1) {\n            sleepMs = 1;\n        }\n\n        if (timeout == null || sleepMs < timeout) {\n            this._nextNano = newNext;\n        }\n\n        return sleepMs;\n    }\n\n    /**\n     * Implements {@link RateLimiter#consumeUnits}\n     * @async\n     * @see {@link RateLimiter}\n     * @param {number} units Number of units to consume\n     * @param {number} timeout Timeout in milliseconds\n     * @param {boolean} consumeOnTimeout Whether to consume units on timeout\n     * or throw an error, see {@link RateLimiter#consumeUnits}\n     * @returns {Promise}  Promise resolved with sleeping time in milliseconds\n     * or rejected with {@link NoSQLTimeoutError}\n     */\n    async consumeUnits(units, timeout, consumeOnTimeout) {\n        const msToSleep = this._consume(units, process.hrtime.bigint(),\n            consumeOnTimeout ? null : timeout);\n\n        if (msToSleep === 0) {\n            return 0;\n        }\n        \n        if (timeout != null && msToSleep >= timeout) {\n            //If timeout is reached we sleep for timeout ms\n            await sleep(timeout);\n            if (consumeOnTimeout) {\n                return timeout;\n            }\n            //If timeout is reached and units were not consumed, we throw\n            //timeout error.\n            throw new NoSQLTimeoutError(`Rate limiter timed out waiting \\\n${timeout} ms for ${units} units`);\n        }\n\n        await sleep(msToSleep);\n        return msToSleep;\n    }\n\n    /**\n     * Implements {@link RateLimiter#setLimit}.  Sets the limiter limit\n     * (rate) in units per second.  Also, enforces minimum duration to be able\n     * to store at least one unused unit.  When changing table limits, will\n     * prorate any unused units according to the new limit.\n     * @param {number} limit Limit in units\n     */\n    setLimit(limit) {\n        //If limit is not positive, assume that the limiter is disabled\n        if (limit <= 0) {\n            this._nanosPerUnit = null;\n            return;\n        }\n\n        const oldNanosPerUnit = this._nanosPerUnit;\n        this._nanosPerUnit = NANOS_IN_SEC / limit;\n\n        if (this._durationNanos < this._nanosPerUnit) {\n            this._durationNanos = BigInt(Math.round(this._nanosPerUnit));\n        }\n\n        if (oldNanosPerUnit != null) {\n            const nowNanos = process.hrtime.bigint();\n            //prorate any unused capacity?\n            if (this._nextNano < nowNanos) {\n                this._nextNano = nowNanos -\n                    (BigInt)(Math.round(((Number)(nowNanos - this._nextNano) *\n                    this._nanosPerUnit / oldNanosPerUnit)));\n            }\n        }\n    }\n\n    /**\n     * Implements {@link RateLimiter#onThrottle}.  Called when throttling\n     * error occurs when using this rate limiter instance.  Current\n     * implementation will remove any stored units by ensuring that\n     * <em>nextNano</em> is at least the current time.\n     */\n    onThrottle() {\n        this._removePast = true;\n    }\n\n}\n\nmodule.exports = SimpleRateLimiter;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}